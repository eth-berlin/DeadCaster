import { ethers, BigNumberish, TypedDataDomain, TypedDataField, BlockTag, TransactionRequest } from 'ethers';
import type { CamelCasedProperties, RequireExactlyOne } from 'type-fest';
import { Cipher } from './cipher.js';
import { Ethers5Signer } from './interfaces.js';
export declare function signedCallEIP712Params(chainId: number): {
    domain: TypedDataDomain;
    types: Record<string, TypedDataField[]>;
};
/**
 * Parameters that define a signed call that shall be
 * CBOR-encoded and sent as the call's `data` field.
 */
export declare class SignedCallDataPack {
    #private;
    readonly leash: Leash;
    /** A signature over the call and leash as generated by `signCall`. */
    readonly signature: Uint8Array;
    /**
     * An oasis-sdk `Call` without the optional fields.
     *
     * After encryption, `body` would be encrypted and this field would contain a
     * `format` field. The runtime would decode the data as a `types::transaction::Call`.
     **/
    readonly data?: Uint8Array | undefined;
    static make(call: EthCall | TransactionRequest, signer: Ethers5Signer | ethers.Signer, overrides?: PrepareSignedCallOverrides): Promise<SignedCallDataPack>;
    private constructor();
    encode(): string;
    /** Encodes the data pack after encrypting the signed call data. */
    encryptEncode(cipher: Cipher): Promise<string>;
}
export declare function makeSignableCall(call: EthCall | TransactionRequest, leash: Leash): SignableEthCall;
export type PrepareSignedCallOverrides = Partial<{
    leash: LeashOverrides;
    chainId: number;
}>;
export type LeashOverrides = Partial<{
    nonce: number;
    blockRange: number;
} & RequireExactlyOne<{
    block: BlockId;
    blockTag: BlockTag;
}>>;
export type EthCall = {
    /** 0x-prefixed hex-encoded address. */
    from?: string;
    /** Optional 0x-prefixed hex-encoded address. */
    to?: string;
    value?: BigNumberish;
    gasPrice?: BigNumberish;
    data?: ethers.BytesLike;
} & Partial<RequireExactlyOne<{
    gas: number | string;
    gasLimit: BigNumberish;
}>>;
/**
 * The structure passed to eth_signTypedData_v4.
 *
 * `uint256`, `address`, and `bytes` are required to be hex-stringified.
 */
export type SignableEthCall = {
    from: string;
    to: string;
    gasLimit?: number;
    gasPrice?: bigint;
    value?: bigint;
    data?: string;
    leash: CamelCasedProperties<Leash>;
};
export type Leash = {
    /** The largest sender account nonce whence the call will be valid. */
    nonce: number;
    /** The block number whence the call will be valid. */
    block_number: number;
    /** The expected block hash to be found at `block_number`. */
    block_hash: Uint8Array | string;
    /** The number of blocks past the block at `block_number` whence the call will be valid. */
    block_range: number;
};
export type BlockId = {
    hash: string;
    number: number;
};
//# sourceMappingURL=signed_calls.d.ts.map