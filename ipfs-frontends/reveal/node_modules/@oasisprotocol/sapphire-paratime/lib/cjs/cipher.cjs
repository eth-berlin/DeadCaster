"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mock = exports.X25519DeoxysII = exports.Plain = exports.Cipher = exports.Kind = void 0;
const cbor = __importStar(require("cborg"));
const ethers_1 = require("ethers");
const deoxysii_1 = __importDefault(require("@oasisprotocol/deoxysii"));
const sha512_1 = require("@noble/hashes/sha512");
const hmac_1 = require("@noble/hashes/hmac");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const index_js_1 = require("./index.cjs");
var Kind;
(function (Kind) {
    Kind[Kind["Plain"] = 0] = "Plain";
    Kind[Kind["X25519DeoxysII"] = 1] = "X25519DeoxysII";
    Kind[Kind["Mock"] = Number.MAX_SAFE_INTEGER] = "Mock";
})(Kind = exports.Kind || (exports.Kind = {}));
class Cipher {
    /** Encrypts the plaintext and encodes it for sending. */
    encryptEncode(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            const envelope = yield this.encryptEnvelope(plaintext);
            return envelope ? (0, ethers_1.hexlify)(cbor.encode(envelope)) : '';
        });
    }
    /** Encrypts the plaintext and formats it into an envelope. */
    encryptEnvelope(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (plaintext === undefined)
                return;
            if (!(0, ethers_1.isBytesLike)(plaintext)) {
                throw new Error('Attempted to sign tx having non-byteslike data.');
            }
            if (plaintext.length === 0)
                return; // Txs without data are just balance transfers, and all data in those is public.
            const { data, nonce } = yield this.encryptCallData((0, ethers_1.getBytes)(plaintext));
            const pk = this.publicKey;
            const epoch = this.epoch;
            const body = pk.length && nonce.length ? { pk, nonce, data, epoch } : data;
            if (this.kind === Kind.Plain)
                return { body };
            return { format: this.kind, body };
        });
    }
    encryptCallData(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = cbor.encode({ body: plaintext });
            const { ciphertext: data, nonce } = yield this.encrypt(body);
            return { data, nonce };
        });
    }
    /**
     *  Decrypts the data contained within call
     *
     *  This is useful for creating tools, and also decoding
     *  previously-sent transactions that have used the same
     *  encryption key.
     */
    decryptCallData(nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            return cbor.decode(yield this.decrypt(nonce, ciphertext)).body;
        });
    }
    /**
     * @hidden Encrypts a CallResult in the same way as would be returned by the runtime.
     * This method is not part of the SemVer interface and may be subject to change.
     */
    encryptCallResult(result, reportUnknown = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (result.fail)
                return cbor.encode(result);
            const encodedResult = cbor.encode(result);
            const { ciphertext, nonce } = yield this.encrypt(encodedResult);
            const prop = reportUnknown ? 'unknown' : 'ok';
            return cbor.encode({ [prop]: { nonce, data: ciphertext } });
        });
    }
    /** Decrypts the data contained within a hex-encoded serialized envelope. */
    decryptEncoded(callResult) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, ethers_1.hexlify)(yield this.decryptCallResult(cbor.decode((0, ethers_1.getBytes)(callResult))));
        });
    }
    /** Decrypts the data contained within a result envelope. */
    decryptCallResult(res) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            function formatFailure(fail) {
                if (fail.message)
                    return fail.message;
                return `Call failed in module '${fail.module}' with code '${fail.code}'`;
            }
            if (res.fail)
                throw new index_js_1.CallError(formatFailure(res.fail), res.fail);
            if (res.ok && (typeof res.ok === 'string' || res.ok instanceof Uint8Array))
                return (0, ethers_1.getBytes)(res.ok);
            const { nonce, data } = (_a = res.ok) !== null && _a !== void 0 ? _a : res.unknown;
            const inner = cbor.decode(yield this.decrypt(nonce, data));
            if (inner.ok)
                return (0, ethers_1.getBytes)(inner.ok);
            if (inner.fail)
                throw new index_js_1.CallError(formatFailure(inner.fail), inner.fail);
            throw new index_js_1.CallError(`Unexpected inner call result: ${JSON.stringify(inner)}`, inner);
        });
    }
}
exports.Cipher = Cipher;
/**
 * A {@link Cipher} that does not encrypt data.
 *
 * This cipher is useful for debugging and sending messages that
 * you would prefer everyone to be able to see (e.g., for auditing purposes).
 */
class Plain extends Cipher {
    constructor() {
        super(...arguments);
        this.kind = Kind.Plain;
        this.publicKey = new Uint8Array();
        this.epoch = undefined;
    }
    encrypt(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            return { ciphertext: plaintext, nonce: new Uint8Array() };
        });
    }
    decrypt(_nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            return ciphertext;
        });
    }
    encryptCallData(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            return { data: plaintext, nonce: new Uint8Array() };
        });
    }
}
exports.Plain = Plain;
/**
 * A {@link Cipher} that derives a shared secret using X25519 and then uses DeoxysII for encrypting using that secret.
 *
 * This is the default cipher.
 */
class X25519DeoxysII extends Cipher {
    /** Creates a new cipher using an ephemeral keypair stored in memory. */
    static ephemeral(peerPublicKey, epoch) {
        const keypair = tweetnacl_1.default.box.keyPair();
        return new X25519DeoxysII(keypair, (0, ethers_1.getBytes)(peerPublicKey), epoch);
    }
    static fromSecretKey(secretKey, peerPublicKey, epoch) {
        const keypair = tweetnacl_1.default.box.keyPair.fromSecretKey((0, ethers_1.getBytes)(secretKey));
        return new X25519DeoxysII(keypair, (0, ethers_1.getBytes)(peerPublicKey), epoch);
    }
    constructor(keypair, peerPublicKey, epoch) {
        super();
        this.kind = Kind.X25519DeoxysII;
        this.publicKey = keypair.publicKey;
        // Derive a shared secret using X25519 (followed by hashing to remove ECDH bias).
        this.epoch = epoch;
        const keyBytes = hmac_1.hmac
            .create(sha512_1.sha512_256, new TextEncoder().encode('MRAE_Box_Deoxys-II-256-128'))
            .update(tweetnacl_1.default.scalarMult(keypair.secretKey, peerPublicKey))
            .digest().buffer;
        this.key = new Uint8Array(keyBytes);
        this.cipher = new deoxysii_1.default.AEAD(new Uint8Array(this.key)); // deoxysii owns the input
    }
    encrypt(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            const nonce = tweetnacl_1.default.randomBytes(deoxysii_1.default.NonceSize);
            const ciphertext = this.cipher.encrypt(nonce, plaintext);
            return { nonce, ciphertext };
        });
    }
    decrypt(nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.cipher.decrypt(nonce, ciphertext);
        });
    }
}
exports.X25519DeoxysII = X25519DeoxysII;
/** A cipher that pretends to be an encrypting cipher. Used for tests. */
class Mock extends Cipher {
    constructor() {
        super(...arguments);
        this.kind = Kind.Mock;
        this.publicKey = new Uint8Array([1, 2, 3]);
        this.epoch = undefined;
    }
    encrypt(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            return { nonce: Mock.NONCE, ciphertext: plaintext };
        });
    }
    decrypt(nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((0, ethers_1.hexlify)(nonce) !== (0, ethers_1.hexlify)(Mock.NONCE))
                throw new Error('incorrect nonce');
            return ciphertext;
        });
    }
}
exports.Mock = Mock;
Mock.NONCE = new Uint8Array([10, 20, 30, 40]);
//# sourceMappingURL=cipher.js.map