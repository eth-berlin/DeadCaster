import { UpstreamProvider } from './interfaces.js';
import { Cipher, Mock as MockCipher } from './cipher.js';
export interface CallDataPublicKey {
    key: Uint8Array;
    checksum: Uint8Array;
    signature: Uint8Array;
    epoch: number;
    chainId: number;
    fetched: Date;
}
export declare function fetchRuntimePublicKeyByChainId(chainId: number, opts?: {
    fetch?: typeof fetch;
}): Promise<CallDataPublicKey>;
/**
 * Picks the most user-trusted runtime calldata public key source based on what
 * connections are available.
 *
 * NOTE: MetaMask does not support Web3 methods it doesn't know about, so we have to
 *       fall-back to manually querying the default gateway.
 */
export declare function fetchRuntimePublicKey(upstream: UpstreamProvider): Promise<CallDataPublicKey>;
export declare abstract class AbstractKeyFetcher {
    abstract fetch(upstream: UpstreamProvider): Promise<CallDataPublicKey>;
    abstract cipher(upstream: UpstreamProvider): Promise<Cipher>;
}
export declare class KeyFetcher extends AbstractKeyFetcher {
    readonly timeoutMilliseconds: number;
    pubkey?: CallDataPublicKey;
    constructor(in_timeoutMilliseconds?: number);
    /**
     * Retrieve cached key if possible, otherwise fetch a fresh one
     *
     * @param upstream Upstream ETH JSON-RPC provider
     * @returns calldata public key
     */
    fetch(upstream: UpstreamProvider): Promise<CallDataPublicKey>;
    cipher(upstream: UpstreamProvider): Promise<Cipher>;
}
export declare class MockKeyFetcher extends AbstractKeyFetcher {
    #private;
    constructor(in_cipher: MockCipher);
    fetch(): Promise<CallDataPublicKey>;
    cipher(): Promise<Cipher>;
}
//# sourceMappingURL=calldatapublickey.d.ts.map