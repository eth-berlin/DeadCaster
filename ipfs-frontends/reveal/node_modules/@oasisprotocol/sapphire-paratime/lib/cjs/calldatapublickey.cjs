"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MockKeyFetcher__cipher;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockKeyFetcher = exports.KeyFetcher = exports.AbstractKeyFetcher = exports.fetchRuntimePublicKey = exports.fetchRuntimePublicKeyByChainId = void 0;
const ethers_1 = require("ethers");
const index_js_1 = require("./index.cjs");
const networks_js_1 = require("./networks.cjs");
const cipher_js_1 = require("./cipher.cjs");
const DEFAULT_PUBKEY_CACHE_EXPIRATION_MS = 60 * 5 * 1000; // 5 minutes in milliseconds
function toCallDataPublicKey(result, chainId) {
    const key = (0, ethers_1.getBytes)(result.key);
    return {
        key,
        checksum: (0, ethers_1.getBytes)(result.checksum),
        signature: (0, ethers_1.getBytes)(result.signature),
        epoch: result.epoch,
        chainId,
        fetched: new Date(),
    };
}
// TODO: remove, this is unecessary, node has `fetch` now?
function fetchRuntimePublicKeyNode(gwUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        // Import http or https, depending on the URI scheme.
        const https = yield (_a = gwUrl.split(':')[0], Promise.resolve().then(() => __importStar(require(_a))));
        const body = makeCallDataPublicKeyBody();
        return new Promise((resolve, reject) => {
            const opts = {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    'content-length': body.length,
                },
            };
            const req = https.request(gwUrl, opts, (res) => {
                const chunks = [];
                res.on('error', (err) => reject(err));
                res.on('data', (chunk) => chunks.push(chunk));
                res.on('end', () => {
                    resolve(JSON.parse(Buffer.concat(chunks).toString()));
                });
            });
            req.on('error', (err) => reject(err));
            req.write(body);
            req.end();
        });
    });
}
function fetchRuntimePublicKeyBrowser(gwUrl, fetchImpl) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield fetchImpl(gwUrl, {
            method: 'POST',
            headers: {
                'content-type': 'application/json',
            },
            body: makeCallDataPublicKeyBody(),
        });
        if (!res.ok) {
            throw new index_js_1.CallError('Failed to fetch runtime public key.', res);
        }
        return yield res.json();
    });
}
function makeCallDataPublicKeyBody() {
    return JSON.stringify({
        jsonrpc: '2.0',
        id: Math.floor(Math.random() * 1e9),
        method: index_js_1.OASIS_CALL_DATA_PUBLIC_KEY,
        params: [],
    });
}
function fetchRuntimePublicKeyByChainId(chainId, opts) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const { defaultGateway } = networks_js_1.NETWORKS[chainId];
        if (!defaultGateway)
            throw new Error(`Unable to fetch runtime public key for network with unknown ID: ${chainId}.`);
        const fetchImpl = (_a = opts === null || opts === void 0 ? void 0 : opts.fetch) !== null && _a !== void 0 ? _a : globalThis === null || globalThis === void 0 ? void 0 : globalThis.fetch;
        const res = yield (fetchImpl
            ? fetchRuntimePublicKeyBrowser(defaultGateway, fetchImpl)
            : fetchRuntimePublicKeyNode(defaultGateway));
        return toCallDataPublicKey(res.result, chainId);
    });
}
exports.fetchRuntimePublicKeyByChainId = fetchRuntimePublicKeyByChainId;
function fromQuantity(x) {
    if (typeof x === 'string') {
        if (x.startsWith('0x')) {
            return parseInt(x, 16);
        }
        return parseInt(x); // Assumed to be base 10
    }
    return x;
}
/**
 * Picks the most user-trusted runtime calldata public key source based on what
 * connections are available.
 *
 * NOTE: MetaMask does not support Web3 methods it doesn't know about, so we have to
 *       fall-back to manually querying the default gateway.
 */
function fetchRuntimePublicKey(upstream) {
    return __awaiter(this, void 0, void 0, function* () {
        const provider = 'provider' in upstream ? upstream['provider'] : upstream;
        let chainId;
        if (provider) {
            let resp;
            // It's probably an EIP-1193 provider
            if ('request' in provider) {
                const source = provider;
                chainId = fromQuantity((yield source.request({ method: 'eth_chainId' })));
                try {
                    resp = yield source.request({
                        method: index_js_1.OASIS_CALL_DATA_PUBLIC_KEY,
                        params: [],
                    });
                }
                catch (ex) {
                    // don't do anything, move on to try next
                }
            }
            // If it's a `send` provider
            else if ('send' in provider) {
                const source = provider;
                chainId = fromQuantity(yield source.send('eth_chainId', []));
                try {
                    resp = yield source.send(index_js_1.OASIS_CALL_DATA_PUBLIC_KEY, []);
                }
                catch (ex) {
                    // don't do anything, move on to try chainId fetch
                }
            }
            // Otherwise, we have no idea what to do with this provider!
            else {
                throw new Error('fetchRuntimePublicKey does not support non-request non-send provier!');
            }
            if (resp && 'key' in resp) {
                return toCallDataPublicKey(resp, chainId);
            }
        }
        if (!chainId) {
            throw new Error('fetchRuntimePublicKey failed to retrieve chainId from provider');
        }
        return fetchRuntimePublicKeyByChainId(chainId);
    });
}
exports.fetchRuntimePublicKey = fetchRuntimePublicKey;
class AbstractKeyFetcher {
}
exports.AbstractKeyFetcher = AbstractKeyFetcher;
class KeyFetcher extends AbstractKeyFetcher {
    constructor(in_timeoutMilliseconds) {
        super();
        if (!in_timeoutMilliseconds) {
            in_timeoutMilliseconds = DEFAULT_PUBKEY_CACHE_EXPIRATION_MS;
        }
        this.timeoutMilliseconds = in_timeoutMilliseconds;
    }
    /**
     * Retrieve cached key if possible, otherwise fetch a fresh one
     *
     * @param upstream Upstream ETH JSON-RPC provider
     * @returns calldata public key
     */
    fetch(upstream) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pubkey) {
                const pk = this.pubkey;
                const expiry = Date.now() - this.timeoutMilliseconds;
                if (pk.fetched && pk.fetched.valueOf() > expiry) {
                    // XXX: if provider switch chain, may return cached key for wrong chain
                    return pk;
                }
            }
            return (this.pubkey = yield fetchRuntimePublicKey(upstream));
        });
    }
    cipher(upstream) {
        return __awaiter(this, void 0, void 0, function* () {
            const kp = yield this.fetch(upstream);
            return cipher_js_1.X25519DeoxysII.ephemeral(kp.key, kp.epoch);
        });
    }
}
exports.KeyFetcher = KeyFetcher;
class MockKeyFetcher extends AbstractKeyFetcher {
    constructor(in_cipher) {
        super();
        _MockKeyFetcher__cipher.set(this, void 0);
        __classPrivateFieldSet(this, _MockKeyFetcher__cipher, in_cipher, "f");
    }
    fetch() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("MockKeyFetcher doesn't support fetch(), only cipher()");
        });
    }
    cipher() {
        return __awaiter(this, void 0, void 0, function* () {
            return __classPrivateFieldGet(this, _MockKeyFetcher__cipher, "f");
        });
    }
}
exports.MockKeyFetcher = MockKeyFetcher;
_MockKeyFetcher__cipher = new WeakMap();
//# sourceMappingURL=calldatapublickey.js.map