var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as cbor from 'cborg';
import { isBytesLike, hexlify, getBytes } from 'ethers';
import deoxysii from '@oasisprotocol/deoxysii';
import { sha512_256 } from '@noble/hashes/sha512';
import { hmac } from '@noble/hashes/hmac';
import nacl from 'tweetnacl';
import { CallError } from './index.js';
export var Kind;
(function (Kind) {
    Kind[Kind["Plain"] = 0] = "Plain";
    Kind[Kind["X25519DeoxysII"] = 1] = "X25519DeoxysII";
    Kind[Kind["Mock"] = Number.MAX_SAFE_INTEGER] = "Mock";
})(Kind || (Kind = {}));
export class Cipher {
    /** Encrypts the plaintext and encodes it for sending. */
    encryptEncode(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            const envelope = yield this.encryptEnvelope(plaintext);
            return envelope ? hexlify(cbor.encode(envelope)) : '';
        });
    }
    /** Encrypts the plaintext and formats it into an envelope. */
    encryptEnvelope(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (plaintext === undefined)
                return;
            if (!isBytesLike(plaintext)) {
                throw new Error('Attempted to sign tx having non-byteslike data.');
            }
            if (plaintext.length === 0)
                return; // Txs without data are just balance transfers, and all data in those is public.
            const { data, nonce } = yield this.encryptCallData(getBytes(plaintext));
            const pk = this.publicKey;
            const epoch = this.epoch;
            const body = pk.length && nonce.length ? { pk, nonce, data, epoch } : data;
            if (this.kind === Kind.Plain)
                return { body };
            return { format: this.kind, body };
        });
    }
    encryptCallData(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = cbor.encode({ body: plaintext });
            const { ciphertext: data, nonce } = yield this.encrypt(body);
            return { data, nonce };
        });
    }
    /**
     *  Decrypts the data contained within call
     *
     *  This is useful for creating tools, and also decoding
     *  previously-sent transactions that have used the same
     *  encryption key.
     */
    decryptCallData(nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            return cbor.decode(yield this.decrypt(nonce, ciphertext)).body;
        });
    }
    /**
     * @hidden Encrypts a CallResult in the same way as would be returned by the runtime.
     * This method is not part of the SemVer interface and may be subject to change.
     */
    encryptCallResult(result, reportUnknown = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (result.fail)
                return cbor.encode(result);
            const encodedResult = cbor.encode(result);
            const { ciphertext, nonce } = yield this.encrypt(encodedResult);
            const prop = reportUnknown ? 'unknown' : 'ok';
            return cbor.encode({ [prop]: { nonce, data: ciphertext } });
        });
    }
    /** Decrypts the data contained within a hex-encoded serialized envelope. */
    decryptEncoded(callResult) {
        return __awaiter(this, void 0, void 0, function* () {
            return hexlify(yield this.decryptCallResult(cbor.decode(getBytes(callResult))));
        });
    }
    /** Decrypts the data contained within a result envelope. */
    decryptCallResult(res) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            function formatFailure(fail) {
                if (fail.message)
                    return fail.message;
                return `Call failed in module '${fail.module}' with code '${fail.code}'`;
            }
            if (res.fail)
                throw new CallError(formatFailure(res.fail), res.fail);
            if (res.ok && (typeof res.ok === 'string' || res.ok instanceof Uint8Array))
                return getBytes(res.ok);
            const { nonce, data } = (_a = res.ok) !== null && _a !== void 0 ? _a : res.unknown;
            const inner = cbor.decode(yield this.decrypt(nonce, data));
            if (inner.ok)
                return getBytes(inner.ok);
            if (inner.fail)
                throw new CallError(formatFailure(inner.fail), inner.fail);
            throw new CallError(`Unexpected inner call result: ${JSON.stringify(inner)}`, inner);
        });
    }
}
/**
 * A {@link Cipher} that does not encrypt data.
 *
 * This cipher is useful for debugging and sending messages that
 * you would prefer everyone to be able to see (e.g., for auditing purposes).
 */
export class Plain extends Cipher {
    constructor() {
        super(...arguments);
        this.kind = Kind.Plain;
        this.publicKey = new Uint8Array();
        this.epoch = undefined;
    }
    encrypt(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            return { ciphertext: plaintext, nonce: new Uint8Array() };
        });
    }
    decrypt(_nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            return ciphertext;
        });
    }
    encryptCallData(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            return { data: plaintext, nonce: new Uint8Array() };
        });
    }
}
/**
 * A {@link Cipher} that derives a shared secret using X25519 and then uses DeoxysII for encrypting using that secret.
 *
 * This is the default cipher.
 */
export class X25519DeoxysII extends Cipher {
    /** Creates a new cipher using an ephemeral keypair stored in memory. */
    static ephemeral(peerPublicKey, epoch) {
        const keypair = nacl.box.keyPair();
        return new X25519DeoxysII(keypair, getBytes(peerPublicKey), epoch);
    }
    static fromSecretKey(secretKey, peerPublicKey, epoch) {
        const keypair = nacl.box.keyPair.fromSecretKey(getBytes(secretKey));
        return new X25519DeoxysII(keypair, getBytes(peerPublicKey), epoch);
    }
    constructor(keypair, peerPublicKey, epoch) {
        super();
        this.kind = Kind.X25519DeoxysII;
        this.publicKey = keypair.publicKey;
        // Derive a shared secret using X25519 (followed by hashing to remove ECDH bias).
        this.epoch = epoch;
        const keyBytes = hmac
            .create(sha512_256, new TextEncoder().encode('MRAE_Box_Deoxys-II-256-128'))
            .update(nacl.scalarMult(keypair.secretKey, peerPublicKey))
            .digest().buffer;
        this.key = new Uint8Array(keyBytes);
        this.cipher = new deoxysii.AEAD(new Uint8Array(this.key)); // deoxysii owns the input
    }
    encrypt(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            const nonce = nacl.randomBytes(deoxysii.NonceSize);
            const ciphertext = this.cipher.encrypt(nonce, plaintext);
            return { nonce, ciphertext };
        });
    }
    decrypt(nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.cipher.decrypt(nonce, ciphertext);
        });
    }
}
/** A cipher that pretends to be an encrypting cipher. Used for tests. */
export class Mock extends Cipher {
    constructor() {
        super(...arguments);
        this.kind = Kind.Mock;
        this.publicKey = new Uint8Array([1, 2, 3]);
        this.epoch = undefined;
    }
    encrypt(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            return { nonce: Mock.NONCE, ciphertext: plaintext };
        });
    }
    decrypt(nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (hexlify(nonce) !== hexlify(Mock.NONCE))
                throw new Error('incorrect nonce');
            return ciphertext;
        });
    }
}
Mock.NONCE = new Uint8Array([10, 20, 30, 40]);
//# sourceMappingURL=cipher.js.map