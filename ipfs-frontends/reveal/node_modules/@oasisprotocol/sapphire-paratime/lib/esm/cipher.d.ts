import { BytesLike } from 'ethers';
import { BoxKeyPair } from 'tweetnacl';
export declare enum Kind {
    Plain = 0,
    X25519DeoxysII = 1,
    Mock
}
export type Envelope = {
    format?: Kind;
    body: Uint8Array | {
        pk: Uint8Array;
        nonce: Uint8Array;
        data: Uint8Array;
    };
};
type AeadEnvelope = {
    nonce: Uint8Array;
    data: Uint8Array;
};
export type CallResult = {
    ok?: string | Uint8Array | AeadEnvelope;
    fail?: CallFailure;
    unknown?: AeadEnvelope;
};
export type CallFailure = {
    module: string;
    code: number;
    message?: string;
};
export declare abstract class Cipher {
    abstract kind: Kind;
    abstract publicKey: Uint8Array;
    abstract epoch: number | undefined;
    abstract encrypt(plaintext: Uint8Array): Promise<{
        ciphertext: Uint8Array;
        nonce: Uint8Array;
    }>;
    abstract decrypt(nonce: Uint8Array, ciphertext: Uint8Array): Promise<Uint8Array>;
    /** Encrypts the plaintext and encodes it for sending. */
    encryptEncode(plaintext?: BytesLike): Promise<string>;
    /** Encrypts the plaintext and formats it into an envelope. */
    encryptEnvelope(plaintext?: BytesLike): Promise<Envelope | undefined>;
    protected encryptCallData(plaintext: Uint8Array): Promise<AeadEnvelope>;
    /**
     *  Decrypts the data contained within call
     *
     *  This is useful for creating tools, and also decoding
     *  previously-sent transactions that have used the same
     *  encryption key.
     */
    decryptCallData(nonce: Uint8Array, ciphertext: Uint8Array): Promise<Uint8Array>;
    /**
     * @hidden Encrypts a CallResult in the same way as would be returned by the runtime.
     * This method is not part of the SemVer interface and may be subject to change.
     */
    encryptCallResult(result: CallResult, reportUnknown?: boolean): Promise<Uint8Array>;
    /** Decrypts the data contained within a hex-encoded serialized envelope. */
    decryptEncoded(callResult: BytesLike): Promise<string>;
    /** Decrypts the data contained within a result envelope. */
    decryptCallResult(res: CallResult): Promise<Uint8Array>;
}
/**
 * A {@link Cipher} that does not encrypt data.
 *
 * This cipher is useful for debugging and sending messages that
 * you would prefer everyone to be able to see (e.g., for auditing purposes).
 */
export declare class Plain extends Cipher {
    readonly kind: Kind;
    readonly publicKey: Uint8Array;
    readonly epoch: undefined;
    encrypt(plaintext: Uint8Array): Promise<{
        ciphertext: Uint8Array;
        nonce: Uint8Array;
    }>;
    decrypt(_nonce: Uint8Array, ciphertext: Uint8Array): Promise<Uint8Array>;
    encryptCallData(plaintext: Uint8Array): Promise<{
        data: Uint8Array;
        nonce: Uint8Array;
    }>;
}
/**
 * A {@link Cipher} that derives a shared secret using X25519 and then uses DeoxysII for encrypting using that secret.
 *
 * This is the default cipher.
 */
export declare class X25519DeoxysII extends Cipher {
    readonly kind: Kind;
    readonly publicKey: Uint8Array;
    readonly epoch: number | undefined;
    private cipher;
    private key;
    /** Creates a new cipher using an ephemeral keypair stored in memory. */
    static ephemeral(peerPublicKey: BytesLike, epoch?: number): X25519DeoxysII;
    static fromSecretKey(secretKey: BytesLike, peerPublicKey: BytesLike, epoch?: number): X25519DeoxysII;
    constructor(keypair: BoxKeyPair, peerPublicKey: Uint8Array, epoch?: number);
    encrypt(plaintext: Uint8Array): Promise<{
        ciphertext: Uint8Array;
        nonce: Uint8Array;
    }>;
    decrypt(nonce: Uint8Array, ciphertext: Uint8Array): Promise<Uint8Array>;
}
/** A cipher that pretends to be an encrypting cipher. Used for tests. */
export declare class Mock extends Cipher {
    readonly kind: Kind;
    readonly publicKey: Uint8Array;
    readonly epoch: undefined;
    static readonly NONCE: Uint8Array;
    encrypt(plaintext: Uint8Array): Promise<{
        ciphertext: Uint8Array;
        nonce: Uint8Array;
    }>;
    decrypt(nonce: Uint8Array, ciphertext: Uint8Array): Promise<Uint8Array>;
}
export {};
//# sourceMappingURL=cipher.d.ts.map