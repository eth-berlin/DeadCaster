var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as cbor from 'cborg';
import { AbstractSigner, BrowserProvider, JsonRpcProvider, Transaction, getBytes, isBytesLike, AbstractProvider, hexlify, } from 'ethers';
import { Kind as CipherKind } from './cipher.js';
import { CallError } from './index.js';
import { SignedCallDataPack } from './signed_calls.js';
import { KeyFetcher } from './calldatapublickey.js';
const SAPPHIRE_PROP = 'sapphire';
function fillOptions(options) {
    if (!options) {
        options = {};
    }
    if (!options.fetcher) {
        options.fetcher = new KeyFetcher();
    }
    return options;
}
export function wrap(upstream, options) {
    // Already wrapped, so don't wrap it again.
    if (typeof upstream !== 'string' &&
        Reflect.get(upstream, SAPPHIRE_PROP) !== undefined) {
        return upstream;
    }
    if (typeof upstream === 'string') {
        upstream = new JsonRpcProvider(upstream);
    }
    const filled_options = fillOptions(options);
    if (isEthersSigner(upstream)) {
        return wrapEthersSigner(upstream, filled_options);
    }
    if (isEthersProvider(upstream)) {
        return wrapEthersProvider(upstream, filled_options);
    }
    // The only other thing we wrap is EIP-1193 compatible providers
    if (isEIP1193Provider(upstream)) {
        return wrapEIP1193Provider(upstream, filled_options);
    }
    throw new TypeError('Unable to wrap unsupported provider.');
}
// -----------------------------------------------------------------------------
// Wrap an EIP-1193 compatible provider
// Under the hood, we wrap it in an ethers BrowserProvider to be used internally
function isEIP1193Provider(upstream) {
    return 'request' in upstream;
}
function wrapEIP1193Provider(upstream, options) {
    const filled_options = fillOptions(options);
    const browserProvider = new BrowserProvider(upstream);
    const request = hookEIP1193Request(browserProvider, filled_options);
    const hooks = {
        request: request,
    };
    if ('send' in upstream) {
        // Send is deprecated, but still used by ethers
        hooks['send'] = (...args) => __awaiter(this, void 0, void 0, function* () {
            return yield request({ method: args[0], params: args[1] });
        });
    }
    if ('sendAsync' in upstream) {
        // sendAsync is deprecated, it historically has an incoherent interface
        hooks['sendAsync'] = () => {
            throw new Error('sendAsync not supported by Sapphire wrapper!');
        };
    }
    return makeProxy(upstream, filled_options, hooks);
}
function hookEIP1193Request(provider, options) {
    return (args) => __awaiter(this, void 0, void 0, function* () {
        const signer = yield provider.getSigner();
        const cipher = yield options.fetcher.cipher(provider);
        const { method, params } = yield prepareRequest(args, signer, cipher);
        const res = yield signer.provider.send(method, params !== null && params !== void 0 ? params : []);
        if (method === 'eth_call') {
            return yield cipher.decryptEncoded(res);
        }
        return res;
    });
}
// -----------------------------------------------------------------------------
function makeProxy(upstream, options, hooks) {
    return new Proxy(upstream, {
        get(upstream, prop) {
            if (prop === SAPPHIRE_PROP)
                return options;
            if (prop in hooks)
                return Reflect.get(hooks, prop);
            const value = Reflect.get(upstream, prop);
            return typeof value === 'function' ? value.bind(upstream) : value;
        },
    });
}
// -----------------------------------------------------------------------------
export function wrapEthersSigner(upstream, options) {
    const filled_options = fillOptions(options);
    let signer;
    if (upstream.provider) {
        try {
            const x = wrapEthersProvider(upstream.provider, filled_options, upstream);
            signer = upstream.connect(x);
        }
        catch (e) {
            if (e.code !== 'UNSUPPORTED_OPERATION')
                throw e;
            signer = upstream;
        }
    }
    else {
        signer = upstream;
    }
    const hooks = {
        sendTransaction: hookEthersSend(signer.sendTransaction.bind(signer), filled_options, signer),
        signTransaction: hookEthersSend(signer.signTransaction.bind(signer), filled_options, signer),
        call: hookEthersCall(signer, 'call', filled_options),
        estimateGas: hookEthersCall(signer, 'estimateGas', filled_options),
        connect(provider) {
            const wp = signer.connect(provider);
            return wrapEthersSigner(wp, filled_options);
        },
    };
    return makeProxy(signer, filled_options, hooks);
}
export function wrapEthersProvider(provider, options, signer) {
    const filled_options = fillOptions(options);
    // Already wrapped, so don't wrap it again.
    if (Reflect.get(provider, SAPPHIRE_PROP) !== undefined) {
        return provider;
    }
    const hooks = {
        // Calls can be unsigned, but must be enveloped.
        call: hookEthersCall(provider, 'call', filled_options),
        estimateGas: hookEthersCall(provider, 'estimateGas', filled_options),
    };
    // When a signer is also provided, we can re-pack transactions
    // But only if they've been signed by the same address as the signer
    if (signer) {
        // Ethers v6 `sendTransaction` takes `TransactionRequest`
        //  v6 equivalent to `sendTransaction` is `broadcastTransaction`
        if ('broadcastTransaction' in provider) {
            hooks['broadcastTransaction'] = ((raw) => __awaiter(this, void 0, void 0, function* () {
                const cipher = yield filled_options.fetcher.cipher(provider);
                const repacked = yield repackRawTx(raw, cipher, signer);
                return provider.broadcastTransaction(repacked);
            }));
        }
        else {
            // Ethers v5 doesn't have `broadcastTransaction`
            // Ethers v5 `sendTransaction` takes hex encoded byte string
            hooks['sendTransaction'] = (((raw) => __awaiter(this, void 0, void 0, function* () {
                const cipher = yield filled_options.fetcher.cipher(provider);
                const repacked = yield repackRawTx(raw, cipher, signer);
                return provider.sendTransaction(repacked);
            })));
        }
    }
    return makeProxy(provider, filled_options, hooks);
}
function isEthers5Signer(upstream) {
    return Reflect.get(upstream, '_isSigner') === true;
}
function isEthers6Signer(upstream) {
    return (upstream instanceof AbstractSigner ||
        (Reflect.get(upstream, 'signTypedData') !== undefined &&
            Reflect.get(upstream, 'signTransaction') !== undefined));
}
function isEthersSigner(upstream) {
    return isEthers5Signer(upstream) || isEthers6Signer(upstream);
}
function isEthers5Provider(upstream) {
    return Reflect.get(upstream, '_isProvider') === true;
}
function isEthers6Provider(upstream) {
    return (upstream instanceof AbstractProvider ||
        (Reflect.get(upstream, 'waitForBlock') &&
            Reflect.get(upstream, 'destroy') &&
            Reflect.get(upstream, 'broadcastTransaction')));
}
function isEthersProvider(upstream) {
    return isEthers5Provider(upstream) || isEthers6Provider(upstream);
}
function hookEthersCall(runner, method, options) {
    const sendUnsignedCall = (runner, call, is_already_enveloped, cipher) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        let call_data = call.data;
        if (!is_already_enveloped) {
            call_data = yield cipher.encryptEncode((_a = call.data) !== null && _a !== void 0 ? _a : new Uint8Array());
        }
        const result = yield runner[method](Object.assign(Object.assign({}, call), { data: hexlify(call_data) }));
        return result;
    });
    return (call) => __awaiter(this, void 0, void 0, function* () {
        // Ethers v6 uses `populateCall` internally to fill in the `from` field etc.
        // It's necessary to call this, if it exists, otherwise signed queries won't work
        const populateCall = Reflect.get(runner, 'populateCall');
        if (populateCall !== undefined) {
            call = yield populateCall.bind(runner)(call);
        }
        let res;
        const is_already_enveloped = isCalldataEnveloped(call.data, true);
        const cipher = yield options.fetcher.cipher(runner);
        if (!is_already_enveloped && isEthersSigner(runner)) {
            const signer = runner;
            if (!signer.provider)
                throw new Error('signer not connected to a provider');
            const provider = signer.provider;
            if (yield callNeedsSigning(call)) {
                const dataPack = yield SignedCallDataPack.make(call, signer);
                res = yield provider[method](Object.assign(Object.assign({}, call), { data: yield dataPack.encryptEncode(cipher) }));
            }
            else {
                res = yield sendUnsignedCall(provider, call, is_already_enveloped, cipher);
            }
        }
        else {
            res = yield sendUnsignedCall(runner, call, is_already_enveloped, cipher);
        }
        // NOTE: if it's already enveloped, caller will decrypt it (not us)
        if (!is_already_enveloped && typeof res === 'string') {
            return yield cipher.decryptEncoded(res);
        }
        return res;
    });
}
function hookEthersSend(send, options, signer) {
    return ((tx, ...rest) => __awaiter(this, void 0, void 0, function* () {
        if (tx.data) {
            const cipher = yield options.fetcher.cipher(signer);
            tx.data = yield cipher.encryptEncode(tx.data);
        }
        return send(tx, ...rest);
    }));
}
// -----------------------------------------------------------------------------
function callNeedsSigning(callP) {
    return __awaiter(this, void 0, void 0, function* () {
        const [from, to] = yield Promise.all([callP.from, callP.to]);
        return (!!to && !!from && typeof from === 'string' && !/^(0x)?0{40}$/.test(from));
    });
}
function prepareRequest({ method, params }, signer, cipher) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!Array.isArray(params))
            return { method, params };
        if (method === 'eth_sendRawTransaction') {
            return {
                method,
                params: [yield repackRawTx(params[0], cipher, signer)],
            };
        }
        if ((method === 'eth_call' || method === 'eth_estimateGas') &&
            (yield callNeedsSigning(params[0]))) {
            const dataPack = yield SignedCallDataPack.make(params[0], signer);
            const signedCall = Object.assign(Object.assign({}, params[0]), { data: yield dataPack.encryptEncode(cipher) });
            return {
                method,
                params: [signedCall, ...params.slice(1)],
            };
        }
        if (/^eth_((send|sign)Transaction|call|estimateGas)$/.test(method) &&
            params[0].data // Ignore balance transfers without calldata
        ) {
            params[0].data = yield cipher.encryptEncode(params[0].data);
            return { method, params };
        }
        return { method, params };
    });
}
class EnvelopeError extends Error {
}
const REPACK_ERROR = 'Un-enveloped data was passed to sendRawTransaction, which is likely incorrect. Is the dapp using the Sapphire compat lib correctly?';
/** Repacks and signs a sendRawTransaction if needed and possible. */
function repackRawTx(raw, cipher, signer) {
    return __awaiter(this, void 0, void 0, function* () {
        const tx = Transaction.from(raw);
        // If raw transaction is enveloped & signed correctly, bypass re-packing
        if (isCalldataEnveloped(tx.data, false)) {
            return raw;
        }
        // When transaction is signed by another keypair and we don't have that signer
        // bypass re-packing, this allows repacking to pass-thru pre-signed txs
        if (tx.isSigned() && (!signer || (yield signer.getAddress()) !== tx.from)) {
            return raw;
        }
        tx.data = yield cipher.encryptEncode(tx.data);
        try {
            return signer.signTransaction(tx);
        }
        catch (e) {
            // Many JSON-RPC providers, Ethers included, will not let you directly
            // sign transactions, which is necessary to re-encrypt the calldata!
            // Throw an error here to prevent calls which should've been encrypted
            // from being submitted unencrypted.
            throw new CallError(REPACK_ERROR, e);
        }
    });
}
function isSignedQuery(x) {
    return 'data' in x && 'leash' in x && 'signature' in x;
}
function isCalldataEnveloped(calldata, allowSignedQuery) {
    try {
        const outer_envelope = cbor.decode(getBytes(calldata));
        let envelope;
        if (isSignedQuery(outer_envelope)) {
            if (!allowSignedQuery) {
                throw new EnvelopeError('Got unexpected signed query!');
            }
            envelope = outer_envelope.data;
        }
        else {
            envelope = outer_envelope;
        }
        if (!envelopeFormatOk(envelope)) {
            throw new EnvelopeError('Bogus Sapphire enveloped data found in transaction!');
        }
        return true;
    }
    catch (e) {
        if (e instanceof EnvelopeError)
            throw e;
    }
    return false;
}
function envelopeFormatOk(envelope) {
    const { format, body } = envelope, extra = __rest(envelope, ["format", "body"]);
    if (Object.keys(extra).length > 0)
        return false;
    if (!body)
        return false;
    if (format !== null && format !== CipherKind.Plain) {
        if (isBytesLike(body))
            return false;
        if (!isBytesLike(body.data))
            return false;
    }
    return true;
}
//# sourceMappingURL=compat.js.map