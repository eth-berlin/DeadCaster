{"ast":null,"code":"import { is } from './is.js';\nimport { Token, Type } from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)];\n    }\n    return [new Token(Type.array, obj.length), entries];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [objectToTokens(key, options, refStack), objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)];\n    }\n    return [new Token(Type.map, length), entries];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport { objectToTokens, encode, encodeCustom, Ref };","map":{"version":3,"names":["is","Token","Type","Bl","encodeErrPrefix","quickEncodeToken","asU8A","encodeUint","encodeNegint","encodeBytes","encodeString","encodeArray","encodeMap","encodeTag","encodeFloat","defaultEncodeOptions","float64","mapSorter","makeCborEncoders","encoders","uint","major","negint","bytes","string","array","map","tag","float","cborEncoders","buf","Ref","constructor","obj","parent","includes","p","createCheck","stack","Error","simpleTokens","null","undefined","true","false","emptyArray","emptyMap","typeEncoders","number","_typ","_options","_refStack","Number","isInteger","isSafeInteger","bigint","BigInt","Uint8Array","boolean","_obj","ArrayBuffer","DataView","buffer","byteOffset","byteLength","Array","options","refStack","length","addBreakTokens","break","entries","i","e","objectToTokens","Object","typ","isMap","keys","size","key","get","sortMapEntries","Map","Buffer","split","customTypeEncoder","tokens","typeEncoder","sort","e1","e2","keyToken1","isArray","keyToken2","type","compare","tcmp","compareTokens","console","warn","tokensToEncoded","token","encodeCustom","data","quickBytes","encoder","encodedSize","chunks","reset","toBytes","encode","assign"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/cborg/esm/lib/encode.js"],"sourcesContent":["import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}