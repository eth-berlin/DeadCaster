{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport * as cbor from 'cborg';\nimport { isBytesLike, hexlify, getBytes } from 'ethers';\nimport deoxysii from '@oasisprotocol/deoxysii';\nimport { sha512_256 } from '@noble/hashes/sha512';\nimport { hmac } from '@noble/hashes/hmac';\nimport nacl from 'tweetnacl';\nimport { CallError } from './index.js';\nexport var Kind;\n(function (Kind) {\n  Kind[Kind[\"Plain\"] = 0] = \"Plain\";\n  Kind[Kind[\"X25519DeoxysII\"] = 1] = \"X25519DeoxysII\";\n  Kind[Kind[\"Mock\"] = Number.MAX_SAFE_INTEGER] = \"Mock\";\n})(Kind || (Kind = {}));\nexport class Cipher {\n  /** Encrypts the plaintext and encodes it for sending. */\n  encryptEncode(plaintext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const envelope = yield this.encryptEnvelope(plaintext);\n      return envelope ? hexlify(cbor.encode(envelope)) : '';\n    });\n  }\n  /** Encrypts the plaintext and formats it into an envelope. */\n  encryptEnvelope(plaintext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (plaintext === undefined) return;\n      if (!isBytesLike(plaintext)) {\n        throw new Error('Attempted to sign tx having non-byteslike data.');\n      }\n      if (plaintext.length === 0) return; // Txs without data are just balance transfers, and all data in those is public.\n      const {\n        data,\n        nonce\n      } = yield this.encryptCallData(getBytes(plaintext));\n      const pk = this.publicKey;\n      const epoch = this.epoch;\n      const body = pk.length && nonce.length ? {\n        pk,\n        nonce,\n        data,\n        epoch\n      } : data;\n      if (this.kind === Kind.Plain) return {\n        body\n      };\n      return {\n        format: this.kind,\n        body\n      };\n    });\n  }\n  encryptCallData(plaintext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const body = cbor.encode({\n        body: plaintext\n      });\n      const {\n        ciphertext: data,\n        nonce\n      } = yield this.encrypt(body);\n      return {\n        data,\n        nonce\n      };\n    });\n  }\n  /**\n   *  Decrypts the data contained within call\n   *\n   *  This is useful for creating tools, and also decoding\n   *  previously-sent transactions that have used the same\n   *  encryption key.\n   */\n  decryptCallData(nonce, ciphertext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return cbor.decode(yield this.decrypt(nonce, ciphertext)).body;\n    });\n  }\n  /**\n   * @hidden Encrypts a CallResult in the same way as would be returned by the runtime.\n   * This method is not part of the SemVer interface and may be subject to change.\n   */\n  encryptCallResult(result, reportUnknown = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (result.fail) return cbor.encode(result);\n      const encodedResult = cbor.encode(result);\n      const {\n        ciphertext,\n        nonce\n      } = yield this.encrypt(encodedResult);\n      const prop = reportUnknown ? 'unknown' : 'ok';\n      return cbor.encode({\n        [prop]: {\n          nonce,\n          data: ciphertext\n        }\n      });\n    });\n  }\n  /** Decrypts the data contained within a hex-encoded serialized envelope. */\n  decryptEncoded(callResult) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return hexlify(yield this.decryptCallResult(cbor.decode(getBytes(callResult))));\n    });\n  }\n  /** Decrypts the data contained within a result envelope. */\n  decryptCallResult(res) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      function formatFailure(fail) {\n        if (fail.message) return fail.message;\n        return `Call failed in module '${fail.module}' with code '${fail.code}'`;\n      }\n      if (res.fail) throw new CallError(formatFailure(res.fail), res.fail);\n      if (res.ok && (typeof res.ok === 'string' || res.ok instanceof Uint8Array)) return getBytes(res.ok);\n      const {\n        nonce,\n        data\n      } = (_a = res.ok) !== null && _a !== void 0 ? _a : res.unknown;\n      const inner = cbor.decode(yield this.decrypt(nonce, data));\n      if (inner.ok) return getBytes(inner.ok);\n      if (inner.fail) throw new CallError(formatFailure(inner.fail), inner.fail);\n      throw new CallError(`Unexpected inner call result: ${JSON.stringify(inner)}`, inner);\n    });\n  }\n}\n/**\n * A {@link Cipher} that does not encrypt data.\n *\n * This cipher is useful for debugging and sending messages that\n * you would prefer everyone to be able to see (e.g., for auditing purposes).\n */\nexport class Plain extends Cipher {\n  constructor() {\n    super(...arguments);\n    this.kind = Kind.Plain;\n    this.publicKey = new Uint8Array();\n    this.epoch = undefined;\n  }\n  encrypt(plaintext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        ciphertext: plaintext,\n        nonce: new Uint8Array()\n      };\n    });\n  }\n  decrypt(_nonce, ciphertext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return ciphertext;\n    });\n  }\n  encryptCallData(plaintext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        data: plaintext,\n        nonce: new Uint8Array()\n      };\n    });\n  }\n}\n/**\n * A {@link Cipher} that derives a shared secret using X25519 and then uses DeoxysII for encrypting using that secret.\n *\n * This is the default cipher.\n */\nexport class X25519DeoxysII extends Cipher {\n  /** Creates a new cipher using an ephemeral keypair stored in memory. */\n  static ephemeral(peerPublicKey, epoch) {\n    const keypair = nacl.box.keyPair();\n    return new X25519DeoxysII(keypair, getBytes(peerPublicKey), epoch);\n  }\n  static fromSecretKey(secretKey, peerPublicKey, epoch) {\n    const keypair = nacl.box.keyPair.fromSecretKey(getBytes(secretKey));\n    return new X25519DeoxysII(keypair, getBytes(peerPublicKey), epoch);\n  }\n  constructor(keypair, peerPublicKey, epoch) {\n    super();\n    this.kind = Kind.X25519DeoxysII;\n    this.publicKey = keypair.publicKey;\n    // Derive a shared secret using X25519 (followed by hashing to remove ECDH bias).\n    this.epoch = epoch;\n    const keyBytes = hmac.create(sha512_256, new TextEncoder().encode('MRAE_Box_Deoxys-II-256-128')).update(nacl.scalarMult(keypair.secretKey, peerPublicKey)).digest().buffer;\n    this.key = new Uint8Array(keyBytes);\n    this.cipher = new deoxysii.AEAD(new Uint8Array(this.key)); // deoxysii owns the input\n  }\n  encrypt(plaintext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const nonce = nacl.randomBytes(deoxysii.NonceSize);\n      const ciphertext = this.cipher.encrypt(nonce, plaintext);\n      return {\n        nonce,\n        ciphertext\n      };\n    });\n  }\n  decrypt(nonce, ciphertext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.cipher.decrypt(nonce, ciphertext);\n    });\n  }\n}\n/** A cipher that pretends to be an encrypting cipher. Used for tests. */\nexport class Mock extends Cipher {\n  constructor() {\n    super(...arguments);\n    this.kind = Kind.Mock;\n    this.publicKey = new Uint8Array([1, 2, 3]);\n    this.epoch = undefined;\n  }\n  encrypt(plaintext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        nonce: Mock.NONCE,\n        ciphertext: plaintext\n      };\n    });\n  }\n  decrypt(nonce, ciphertext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (hexlify(nonce) !== hexlify(Mock.NONCE)) throw new Error('incorrect nonce');\n      return ciphertext;\n    });\n  }\n}\nMock.NONCE = new Uint8Array([10, 20, 30, 40]);","map":{"version":3,"names":["cbor","isBytesLike","hexlify","getBytes","deoxysii","sha512_256","hmac","nacl","CallError","Kind","Number","MAX_SAFE_INTEGER","Cipher","encryptEncode","plaintext","envelope","encryptEnvelope","encode","undefined","Error","length","data","nonce","encryptCallData","pk","publicKey","epoch","body","kind","Plain","format","ciphertext","encrypt","decryptCallData","decode","decrypt","encryptCallResult","result","reportUnknown","fail","encodedResult","prop","decryptEncoded","callResult","decryptCallResult","res","formatFailure","message","module","code","ok","Uint8Array","_a","unknown","inner","JSON","stringify","constructor","_nonce","X25519DeoxysII","ephemeral","peerPublicKey","keypair","box","keyPair","fromSecretKey","secretKey","keyBytes","create","TextEncoder","update","scalarMult","digest","buffer","key","cipher","AEAD","randomBytes","NonceSize","Mock","NONCE"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@oasisprotocol/sapphire-paratime/src/cipher.ts"],"sourcesContent":["import * as cbor from 'cborg';\nimport { BytesLike, isBytesLike, hexlify, getBytes } from 'ethers';\nimport deoxysii from '@oasisprotocol/deoxysii';\nimport { sha512_256 } from '@noble/hashes/sha512';\nimport { hmac } from '@noble/hashes/hmac';\nimport nacl, { BoxKeyPair } from 'tweetnacl';\n\nimport { CallError } from './index.js';\n\nexport enum Kind {\n  Plain = 0,\n  X25519DeoxysII = 1,\n  Mock = Number.MAX_SAFE_INTEGER,\n}\n\nexport type Envelope = {\n  format?: Kind;\n  body:\n    | Uint8Array\n    | {\n        pk: Uint8Array;\n        nonce: Uint8Array;\n        data: Uint8Array;\n      };\n};\n\ntype AeadEnvelope = { nonce: Uint8Array; data: Uint8Array };\nexport type CallResult = {\n  ok?: string | Uint8Array | AeadEnvelope;\n  fail?: CallFailure;\n  unknown?: AeadEnvelope;\n};\nexport type CallFailure = { module: string; code: number; message?: string };\n\nexport abstract class Cipher {\n  public abstract kind: Kind;\n  public abstract publicKey: Uint8Array;\n  public abstract epoch: number | undefined;\n\n  public abstract encrypt(plaintext: Uint8Array): Promise<{\n    ciphertext: Uint8Array;\n    nonce: Uint8Array;\n  }>;\n  public abstract decrypt(\n    nonce: Uint8Array,\n    ciphertext: Uint8Array,\n  ): Promise<Uint8Array>;\n\n  /** Encrypts the plaintext and encodes it for sending. */\n  public async encryptEncode(plaintext?: BytesLike): Promise<string> {\n    const envelope = await this.encryptEnvelope(plaintext);\n    return envelope ? hexlify(cbor.encode(envelope)) : '';\n  }\n\n  /** Encrypts the plaintext and formats it into an envelope. */\n  public async encryptEnvelope(\n    plaintext?: BytesLike,\n  ): Promise<Envelope | undefined> {\n    if (plaintext === undefined) return;\n    if (!isBytesLike(plaintext)) {\n      throw new Error('Attempted to sign tx having non-byteslike data.');\n    }\n    if (plaintext.length === 0) return; // Txs without data are just balance transfers, and all data in those is public.\n    const { data, nonce } = await this.encryptCallData(getBytes(plaintext));\n    const pk = this.publicKey;\n    const epoch = this.epoch;\n    const body = pk.length && nonce.length ? { pk, nonce, data, epoch } : data;\n    if (this.kind === Kind.Plain) return { body };\n    return { format: this.kind, body };\n  }\n\n  protected async encryptCallData(\n    plaintext: Uint8Array,\n  ): Promise<AeadEnvelope> {\n    const body = cbor.encode({ body: plaintext });\n    const { ciphertext: data, nonce } = await this.encrypt(body);\n    return { data, nonce };\n  }\n\n  /**\n   *  Decrypts the data contained within call\n   *\n   *  This is useful for creating tools, and also decoding\n   *  previously-sent transactions that have used the same\n   *  encryption key.\n   */\n\n  public async decryptCallData(\n    nonce: Uint8Array,\n    ciphertext: Uint8Array,\n  ): Promise<Uint8Array> {\n    return cbor.decode(await this.decrypt(nonce, ciphertext)).body;\n  }\n\n  /**\n   * @hidden Encrypts a CallResult in the same way as would be returned by the runtime.\n   * This method is not part of the SemVer interface and may be subject to change.\n   */\n  public async encryptCallResult(\n    result: CallResult,\n    reportUnknown = false,\n  ): Promise<Uint8Array> {\n    if (result.fail) return cbor.encode(result);\n    const encodedResult = cbor.encode(result);\n    const { ciphertext, nonce } = await this.encrypt(encodedResult);\n    const prop = reportUnknown ? 'unknown' : 'ok';\n    return cbor.encode({ [prop]: { nonce, data: ciphertext } });\n  }\n\n  /** Decrypts the data contained within a hex-encoded serialized envelope. */\n  public async decryptEncoded(callResult: BytesLike): Promise<string> {\n    return hexlify(\n      await this.decryptCallResult(cbor.decode(getBytes(callResult))),\n    );\n  }\n\n  /** Decrypts the data contained within a result envelope. */\n  public async decryptCallResult(res: CallResult): Promise<Uint8Array> {\n    function formatFailure(fail: CallFailure): string {\n      if (fail.message) return fail.message;\n      return `Call failed in module '${fail.module}' with code '${fail.code}'`;\n    }\n    if (res.fail) throw new CallError(formatFailure(res.fail), res.fail);\n    if (res.ok && (typeof res.ok === 'string' || res.ok instanceof Uint8Array))\n      return getBytes(res.ok);\n    const { nonce, data } = (res.ok as AeadEnvelope) ?? res.unknown;\n    const inner = cbor.decode(await this.decrypt(nonce, data));\n    if (inner.ok) return getBytes(inner.ok);\n    if (inner.fail) throw new CallError(formatFailure(inner.fail), inner.fail);\n    throw new CallError(\n      `Unexpected inner call result: ${JSON.stringify(inner)}`,\n      inner,\n    );\n  }\n}\n\n/**\n * A {@link Cipher} that does not encrypt data.\n *\n * This cipher is useful for debugging and sending messages that\n * you would prefer everyone to be able to see (e.g., for auditing purposes).\n */\nexport class Plain extends Cipher {\n  public override readonly kind = Kind.Plain;\n  public override readonly publicKey = new Uint8Array();\n  public override readonly epoch = undefined;\n\n  public async encrypt(plaintext: Uint8Array): Promise<{\n    ciphertext: Uint8Array;\n    nonce: Uint8Array;\n  }> {\n    return { ciphertext: plaintext, nonce: new Uint8Array() };\n  }\n\n  public async decrypt(\n    _nonce: Uint8Array,\n    ciphertext: Uint8Array,\n  ): Promise<Uint8Array> {\n    return ciphertext;\n  }\n\n  async encryptCallData(\n    plaintext: Uint8Array,\n  ): Promise<{ data: Uint8Array; nonce: Uint8Array }> {\n    return { data: plaintext, nonce: new Uint8Array() };\n  }\n}\n\n/**\n * A {@link Cipher} that derives a shared secret using X25519 and then uses DeoxysII for encrypting using that secret.\n *\n * This is the default cipher.\n */\nexport class X25519DeoxysII extends Cipher {\n  public override readonly kind = Kind.X25519DeoxysII;\n  public override readonly publicKey: Uint8Array;\n  public override readonly epoch: number | undefined;\n\n  private cipher: deoxysii.AEAD;\n  private key: Uint8Array; // Stored for curious users.\n\n  /** Creates a new cipher using an ephemeral keypair stored in memory. */\n  static ephemeral(peerPublicKey: BytesLike, epoch?: number): X25519DeoxysII {\n    const keypair = nacl.box.keyPair();\n    return new X25519DeoxysII(keypair, getBytes(peerPublicKey), epoch);\n  }\n\n  static fromSecretKey(\n    secretKey: BytesLike,\n    peerPublicKey: BytesLike,\n    epoch?: number,\n  ): X25519DeoxysII {\n    const keypair = nacl.box.keyPair.fromSecretKey(getBytes(secretKey));\n    return new X25519DeoxysII(keypair, getBytes(peerPublicKey), epoch);\n  }\n\n  public constructor(\n    keypair: BoxKeyPair,\n    peerPublicKey: Uint8Array,\n    epoch?: number,\n  ) {\n    super();\n    this.publicKey = keypair.publicKey;\n    // Derive a shared secret using X25519 (followed by hashing to remove ECDH bias).\n\n    this.epoch = epoch;\n\n    const keyBytes = hmac\n      .create(\n        sha512_256,\n        new TextEncoder().encode('MRAE_Box_Deoxys-II-256-128'),\n      )\n      .update(nacl.scalarMult(keypair.secretKey, peerPublicKey))\n      .digest().buffer;\n\n    this.key = new Uint8Array(keyBytes);\n    this.cipher = new deoxysii.AEAD(new Uint8Array(this.key)); // deoxysii owns the input\n  }\n\n  public async encrypt(plaintext: Uint8Array): Promise<{\n    ciphertext: Uint8Array;\n    nonce: Uint8Array;\n  }> {\n    const nonce = nacl.randomBytes(deoxysii.NonceSize);\n    const ciphertext = this.cipher.encrypt(nonce, plaintext);\n    return { nonce, ciphertext };\n  }\n\n  public async decrypt(\n    nonce: Uint8Array,\n    ciphertext: Uint8Array,\n  ): Promise<Uint8Array> {\n    return this.cipher.decrypt(nonce, ciphertext);\n  }\n}\n\n/** A cipher that pretends to be an encrypting cipher. Used for tests. */\nexport class Mock extends Cipher {\n  public override readonly kind = Kind.Mock;\n  public override readonly publicKey = new Uint8Array([1, 2, 3]);\n  public override readonly epoch = undefined;\n\n  public static readonly NONCE = new Uint8Array([10, 20, 30, 40]);\n\n  public async encrypt(plaintext: Uint8Array): Promise<{\n    ciphertext: Uint8Array;\n    nonce: Uint8Array;\n  }> {\n    return { nonce: Mock.NONCE, ciphertext: plaintext };\n  }\n\n  public async decrypt(\n    nonce: Uint8Array,\n    ciphertext: Uint8Array,\n  ): Promise<Uint8Array> {\n    if (hexlify(nonce) !== hexlify(Mock.NONCE))\n      throw new Error('incorrect nonce');\n    return ciphertext;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}