{"ast":null,"code":"/* jshint bitwise: false */\n\n/**\r\n * @license (c) Franz X Antesberger 2013\r\n */\n(function (exporter) {\n  'use strict';\n\n  var POW_2_32 = 0x0100000000;\n  var POW_2_52 = 0x10000000000000;\n\n  //\n  //  Creating and Extracting\n  //\n\n  /**\r\n   *  Creates an uint32 from the given bytes in big endian order.\r\n   *  @param {Number} highByte the high byte\r\n   *  @param {Number} secondHighByte the 2nd high byte\r\n   *  @param {Number} thirdHighByte the 3rd high byte\r\n   *  @param {Number} lowByte the low byte\r\n   *  @returns highByte concat secondHighByte concat thirdHighByte concat lowByte\r\n   */\n  exporter.fromBytesBigEndian = function (highByte, secondHighByte, thirdHighByte, lowByte) {\n    return (highByte << 24 | secondHighByte << 16 | thirdHighByte << 8 | lowByte) >>> 0;\n  };\n\n  /**\r\n   *  Returns the byte.\r\n   *  e.g. when byteNo is 0, the high byte is returned, when byteNo = 3 the low byte is returned.\r\n   *  @param {Number} uint32value the source to be extracted\r\n   *  @param {Number} byteNo 0-3 the byte number, 0 is the high byte, 3 the low byte\r\n   *  @returns {Number} the 0-255 byte according byteNo\r\n   */\n  exporter.getByteBigEndian = function (uint32value, byteNo) {\n    return uint32value >>> 8 * (3 - byteNo) & 0xff;\n  };\n\n  /**\r\n   *  Returns the bytes as array.\r\n   *  @param {Number} uint32value the source to be extracted\r\n   *  @returns {Array} the array [highByte, 2ndHighByte, 3rdHighByte, lowByte]\r\n   */\n  exporter.getBytesBigEndian = function (uint32value) {\n    return [exporter.getByteBigEndian(uint32value, 0), exporter.getByteBigEndian(uint32value, 1), exporter.getByteBigEndian(uint32value, 2), exporter.getByteBigEndian(uint32value, 3)];\n  };\n\n  /**\r\n   *  Converts a given uin32 to a hex string including leading zeros.\r\n   *  @param {Number} uint32value the uint32 to be stringified\r\n   *  @param {Number} optionalMinLength the optional (default 8)\r\n   */\n  exporter.toHex = function (uint32value, optionalMinLength) {\n    optionalMinLength = optionalMinLength || 8;\n    var result = uint32value.toString(16);\n    if (result.length < optionalMinLength) {\n      result = new Array(optionalMinLength - result.length + 1).join('0') + result;\n    }\n    return result;\n  };\n\n  /**\r\n   *  Converts a number to an uint32.\r\n   *  @param {Number} number the number to be converted.\r\n   *  @return {Number} an uint32 value\r\n   */\n  exporter.toUint32 = function (number) {\n    // the shift operator forces js to perform the internal ToUint32 (see ecmascript spec 9.6)\n    return number >>> 0;\n  };\n\n  /**\r\n   *  Returns the part above the uint32 border.\r\n   *  Depending to the javascript engine, that are the 54-32 = 22 high bits\r\n   *  @param {Number} number the number to extract the high part\r\n   *  @return {Number} the high part of the number\r\n   */\n  exporter.highPart = function (number) {\n    return exporter.toUint32(number / POW_2_32);\n  };\n\n  //\n  //  Bitwise Logical Operators\n  //\n\n  /**\r\n   *  Returns a bitwise OR operation on two or more values.\r\n   *  @param {Number} uint32val0 first uint32 value\r\n   *  @param {Number} argv one or more uint32 values\r\n   *  @return {Number} the bitwise OR uint32 value\r\n   */\n  exporter.or = function (uint32val0, argv) {\n    var result = uint32val0;\n    for (var index = 1; index < arguments.length; index += 1) {\n      result = result | arguments[index];\n    }\n    return result >>> 0;\n  };\n\n  /**\r\n   *  Returns a bitwise AND operation on two or more values.\r\n   *  @param {Number} uint32val0 first uint32 value\r\n   *  @param {Number} argv one or more uint32 values\r\n   *  @return {Number} the bitwise AND uint32 value\r\n   */\n  exporter.and = function (uint32val0, argv) {\n    var result = uint32val0;\n    for (var index = 1; index < arguments.length; index += 1) {\n      result = result & arguments[index];\n    }\n    return result >>> 0;\n  };\n\n  /**\r\n   *  Returns a bitwise XOR operation on two or more values.\r\n   *  @param {Number} uint32val0 first uint32 value\r\n   *  @param {Number} argv one or more uint32 values\r\n   *  @return {Number} the bitwise XOR uint32 value\r\n   */\n  exporter.xor = function (uint32val0, argv) {\n    var result = uint32val0;\n    for (var index = 1; index < arguments.length; index += 1) {\n      result = result ^ arguments[index];\n    }\n    return result >>> 0;\n  };\n  exporter.not = function (uint32val) {\n    return ~uint32val >>> 0;\n  };\n\n  //\n  // Shifting and Rotating\n  //\n\n  /**\r\n   *  Returns the uint32 representation of a << operation.\r\n   *  @param {Number} uint32val the word to be shifted\r\n   *  @param {Number} numBits the number of bits to be shifted (0-31)\r\n   *  @returns {Number} the uint32 value of the shifted word\r\n   */\n  exporter.shiftLeft = function (uint32val, numBits) {\n    return uint32val << numBits >>> 0;\n  };\n\n  /**\r\n   *  Returns the uint32 representation of a >>> operation.\r\n   *  @param {Number} uint32val the word to be shifted\r\n   *  @param {Number} numBits the number of bits to be shifted (0-31)\r\n   *  @returns {Number} the uint32 value of the shifted word\r\n   */\n  exporter.shiftRight = function (uint32val, numBits) {\n    return uint32val >>> numBits;\n  };\n  exporter.rotateLeft = function (uint32val, numBits) {\n    return (uint32val << numBits >>> 0 | uint32val >>> 32 - numBits) >>> 0;\n  };\n  exporter.rotateRight = function (uint32val, numBits) {\n    return (uint32val >>> numBits | uint32val << 32 - numBits >>> 0) >>> 0;\n  };\n\n  //\n  // Logical Gates\n  //\n\n  /**\r\n   *  Bitwise choose bits from y or z, as a bitwise x ? y : z\r\n   */\n  exporter.choose = function (x, y, z) {\n    return (x & (y ^ z) ^ z) >>> 0;\n  };\n\n  /**\r\n   * Majority gate for three parameters. Takes bitwise the majority of x, y and z,\r\n   * @see https://en.wikipedia.org/wiki/Majority_function\r\n   */\n  exporter.majority = function (x, y, z) {\n    return (x & (y | z) | y & z) >>> 0;\n  };\n\n  //\n  //  Arithmetic\n  //\n\n  /**\r\n   *  Adds the given values modulus 2^32.\r\n   *  @returns the sum of the given values modulus 2^32\r\n   */\n  exporter.addMod32 = function (uint32val0 /*, optionalValues*/) {\n    var result = uint32val0;\n    for (var index = 1; index < arguments.length; index += 1) {\n      result += arguments[index];\n    }\n    return result >>> 0;\n  };\n\n  /**\r\n   *  Returns the log base 2 of the given value. That is the number of the highest set bit.\r\n   *  @param {Number} uint32val the value, the log2 is calculated of\r\n   *  @return {Number} the logarithm base 2, an integer between 0 and 31\r\n   */\n  exporter.log2 = function (uint32val) {\n    return Math.floor(Math.log(uint32val) / Math.LN2);\n  };\n\n  /*\r\n      // this implementation does the same, looks much funnier, but takes 2 times longer (according to jsperf) ...\r\n      var log2_u = new Uint32Array(2);\r\n      var log2_d = new Float64Array(log2_u.buffer);\r\n  \r\n      exporter.log2 = function (uint32val) {\r\n          // Ported from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogIEEE64Float to javascript\r\n          // (public domain)\r\n          if (uint32val === 0) {\r\n              return -Infinity;\r\n          }\r\n          // fill in the low part\r\n          log2_u[0] = uint32val;\r\n          // set the mantissa to 2^52\r\n          log2_u[1] = 0x43300000;\r\n          // subtract 2^52\r\n          log2_d[0] -= 0x10000000000000;\r\n          return (log2_u[1] >>> 20) - 0x3FF;\r\n      };\r\n  */\n\n  /**\r\n   *  Returns the the low and the high uint32 of the multiplication.\r\n   *  @param {Number} factor1 an uint32\r\n   *  @param {Number} factor2 an uint32\r\n   *  @param {Uint32Array[2]} resultUint32Array2 the Array, where the result will be written to\r\n   *  @returns undefined\r\n   */\n  exporter.mult = function (factor1, factor2, resultUint32Array2) {\n    var high16 = ((factor1 & 0xffff0000) >>> 0) * factor2;\n    var low16 = (factor1 & 0x0000ffff) * factor2;\n    // the addition is dangerous, because the result will be rounded, so the result depends on the lowest bits, which will be cut away!\n    var carry = exporter.toUint32(high16) + exporter.toUint32(low16) >= POW_2_32 ? 1 : 0;\n    resultUint32Array2[0] = exporter.highPart(high16) + exporter.highPart(low16) + carry >>> 0;\n    resultUint32Array2[1] = (high16 >>> 0) + (low16 >>> 0); // >>> 0;\n  };\n})(typeof module !== 'undefined' ? module.exports = {} : window.uint32 = {});","map":{"version":3,"names":["exporter","POW_2_32","POW_2_52","fromBytesBigEndian","highByte","secondHighByte","thirdHighByte","lowByte","getByteBigEndian","uint32value","byteNo","getBytesBigEndian","toHex","optionalMinLength","result","toString","length","Array","join","toUint32","number","highPart","or","uint32val0","argv","index","arguments","and","xor","not","uint32val","shiftLeft","numBits","shiftRight","rotateLeft","rotateRight","choose","x","y","z","majority","addMod32","log2","Math","floor","log","LN2","mult","factor1","factor2","resultUint32Array2","high16","low16","carry","module","exports","window","uint32"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/uint32/uint32.js"],"sourcesContent":["/* jshint bitwise: false */\r\n\r\n/**\r\n * @license (c) Franz X Antesberger 2013\r\n */\r\n(function (exporter) {\r\n    'use strict';\r\n\r\n    var POW_2_32 = 0x0100000000;\r\n    var POW_2_52 = 0x10000000000000;\r\n\r\n    //\r\n    //  Creating and Extracting\r\n    //\r\n\r\n    /**\r\n     *  Creates an uint32 from the given bytes in big endian order.\r\n     *  @param {Number} highByte the high byte\r\n     *  @param {Number} secondHighByte the 2nd high byte\r\n     *  @param {Number} thirdHighByte the 3rd high byte\r\n     *  @param {Number} lowByte the low byte\r\n     *  @returns highByte concat secondHighByte concat thirdHighByte concat lowByte\r\n     */\r\n    exporter.fromBytesBigEndian = function (highByte, secondHighByte, thirdHighByte, lowByte) {\r\n        return ((highByte << 24) | (secondHighByte << 16) | (thirdHighByte << 8) | lowByte) >>> 0;\r\n    };\r\n\r\n    /**\r\n     *  Returns the byte.\r\n     *  e.g. when byteNo is 0, the high byte is returned, when byteNo = 3 the low byte is returned.\r\n     *  @param {Number} uint32value the source to be extracted\r\n     *  @param {Number} byteNo 0-3 the byte number, 0 is the high byte, 3 the low byte\r\n     *  @returns {Number} the 0-255 byte according byteNo\r\n     */\r\n    exporter.getByteBigEndian = function (uint32value, byteNo) {\r\n        return (uint32value >>> (8 * (3 - byteNo))) & 0xff;\r\n    };\r\n\r\n    /**\r\n     *  Returns the bytes as array.\r\n     *  @param {Number} uint32value the source to be extracted\r\n     *  @returns {Array} the array [highByte, 2ndHighByte, 3rdHighByte, lowByte]\r\n     */\r\n    exporter.getBytesBigEndian = function (uint32value) {\r\n        return [\r\n            exporter.getByteBigEndian(uint32value, 0),\r\n            exporter.getByteBigEndian(uint32value, 1),\r\n            exporter.getByteBigEndian(uint32value, 2),\r\n            exporter.getByteBigEndian(uint32value, 3)\r\n        ];\r\n    };\r\n\r\n    /**\r\n     *  Converts a given uin32 to a hex string including leading zeros.\r\n     *  @param {Number} uint32value the uint32 to be stringified\r\n     *  @param {Number} optionalMinLength the optional (default 8)\r\n     */\r\n    exporter.toHex = function (uint32value, optionalMinLength) {\r\n        optionalMinLength = optionalMinLength || 8;\r\n        var result = uint32value.toString(16);\r\n        if (result.length < optionalMinLength) {\r\n            result = new Array(optionalMinLength - result.length + 1).join('0') + result;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     *  Converts a number to an uint32.\r\n     *  @param {Number} number the number to be converted.\r\n     *  @return {Number} an uint32 value\r\n     */\r\n    exporter.toUint32 = function (number) {\r\n        // the shift operator forces js to perform the internal ToUint32 (see ecmascript spec 9.6)\r\n        return number >>> 0;\r\n    };\r\n\r\n    /**\r\n     *  Returns the part above the uint32 border.\r\n     *  Depending to the javascript engine, that are the 54-32 = 22 high bits\r\n     *  @param {Number} number the number to extract the high part\r\n     *  @return {Number} the high part of the number\r\n     */\r\n    exporter.highPart = function (number) {\r\n        return exporter.toUint32(number / POW_2_32);\r\n    };\r\n\r\n    //\r\n    //  Bitwise Logical Operators\r\n    //\r\n\r\n    /**\r\n     *  Returns a bitwise OR operation on two or more values.\r\n     *  @param {Number} uint32val0 first uint32 value\r\n     *  @param {Number} argv one or more uint32 values\r\n     *  @return {Number} the bitwise OR uint32 value\r\n     */\r\n    exporter.or = function (uint32val0, argv) {\r\n        var result = uint32val0;\r\n        for (var index = 1; index < arguments.length; index += 1) {\r\n            result = (result | arguments[index]);\r\n        }\r\n        return result >>> 0;\r\n    };\r\n\r\n    /**\r\n     *  Returns a bitwise AND operation on two or more values.\r\n     *  @param {Number} uint32val0 first uint32 value\r\n     *  @param {Number} argv one or more uint32 values\r\n     *  @return {Number} the bitwise AND uint32 value\r\n     */\r\n    exporter.and = function (uint32val0, argv) {\r\n        var result = uint32val0;\r\n        for (var index = 1; index < arguments.length; index += 1) {\r\n            result = (result & arguments[index]);\r\n        }\r\n        return result >>> 0;\r\n    };\r\n\r\n    /**\r\n     *  Returns a bitwise XOR operation on two or more values.\r\n     *  @param {Number} uint32val0 first uint32 value\r\n     *  @param {Number} argv one or more uint32 values\r\n     *  @return {Number} the bitwise XOR uint32 value\r\n     */\r\n    exporter.xor = function (uint32val0, argv) {\r\n        var result = uint32val0;\r\n        for (var index = 1; index < arguments.length; index += 1) {\r\n            result = (result ^ arguments[index]);\r\n        }\r\n        return result >>> 0;\r\n    };\r\n\r\n    exporter.not = function (uint32val) {\r\n        return (~uint32val) >>> 0;\r\n    };\r\n\r\n    //\r\n    // Shifting and Rotating\r\n    //\r\n\r\n    /**\r\n     *  Returns the uint32 representation of a << operation.\r\n     *  @param {Number} uint32val the word to be shifted\r\n     *  @param {Number} numBits the number of bits to be shifted (0-31)\r\n     *  @returns {Number} the uint32 value of the shifted word\r\n     */\r\n    exporter.shiftLeft = function (uint32val, numBits) {\r\n        return (uint32val << numBits) >>> 0;\r\n    };\r\n\r\n    /**\r\n     *  Returns the uint32 representation of a >>> operation.\r\n     *  @param {Number} uint32val the word to be shifted\r\n     *  @param {Number} numBits the number of bits to be shifted (0-31)\r\n     *  @returns {Number} the uint32 value of the shifted word\r\n     */\r\n    exporter.shiftRight = function (uint32val, numBits) {\r\n        return uint32val >>> numBits;\r\n    };\r\n\r\n    exporter.rotateLeft = function (uint32val, numBits) {\r\n        return (((uint32val << numBits) >>> 0) | (uint32val >>> (32 - numBits))) >>> 0;\r\n    };\r\n\r\n    exporter.rotateRight = function (uint32val, numBits) {\r\n        return (((uint32val) >>> (numBits)) | ((uint32val) << (32 - numBits)) >>> 0) >>> 0;\r\n    };\r\n\r\n    //\r\n    // Logical Gates\r\n    //\r\n\r\n    /**\r\n     *  Bitwise choose bits from y or z, as a bitwise x ? y : z\r\n     */\r\n    exporter.choose = function (x, y, z) {\r\n        return ((x & (y ^ z)) ^ z) >>> 0;\r\n    };\r\n\r\n    /**\r\n     * Majority gate for three parameters. Takes bitwise the majority of x, y and z,\r\n     * @see https://en.wikipedia.org/wiki/Majority_function\r\n     */\r\n    exporter.majority = function (x, y, z) {\r\n        return ((x & (y | z)) | (y & z)) >>> 0;\r\n    };\r\n\r\n    //\r\n    //  Arithmetic\r\n    //\r\n\r\n    /**\r\n     *  Adds the given values modulus 2^32.\r\n     *  @returns the sum of the given values modulus 2^32\r\n     */\r\n    exporter.addMod32 = function (uint32val0/*, optionalValues*/) {\r\n        var result = uint32val0;\r\n        for (var index = 1; index < arguments.length; index += 1) {\r\n            result += arguments[index];\r\n        }\r\n        return result >>> 0;\r\n    };\r\n\r\n    /**\r\n     *  Returns the log base 2 of the given value. That is the number of the highest set bit.\r\n     *  @param {Number} uint32val the value, the log2 is calculated of\r\n     *  @return {Number} the logarithm base 2, an integer between 0 and 31\r\n     */\r\n    exporter.log2 = function (uint32val) {\r\n        return Math.floor(Math.log(uint32val) / Math.LN2);\r\n    };\r\n\r\n/*\r\n    // this implementation does the same, looks much funnier, but takes 2 times longer (according to jsperf) ...\r\n    var log2_u = new Uint32Array(2);\r\n    var log2_d = new Float64Array(log2_u.buffer);\r\n\r\n    exporter.log2 = function (uint32val) {\r\n        // Ported from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogIEEE64Float to javascript\r\n        // (public domain)\r\n        if (uint32val === 0) {\r\n            return -Infinity;\r\n        }\r\n        // fill in the low part\r\n        log2_u[0] = uint32val;\r\n        // set the mantissa to 2^52\r\n        log2_u[1] = 0x43300000;\r\n        // subtract 2^52\r\n        log2_d[0] -= 0x10000000000000;\r\n        return (log2_u[1] >>> 20) - 0x3FF;\r\n    };\r\n*/\r\n\r\n    /**\r\n     *  Returns the the low and the high uint32 of the multiplication.\r\n     *  @param {Number} factor1 an uint32\r\n     *  @param {Number} factor2 an uint32\r\n     *  @param {Uint32Array[2]} resultUint32Array2 the Array, where the result will be written to\r\n     *  @returns undefined\r\n     */\r\n    exporter.mult = function (factor1, factor2, resultUint32Array2) {\r\n        var high16 =  ((factor1 & 0xffff0000) >>> 0) * factor2;\r\n        var low16 = (factor1 & 0x0000ffff) * factor2;\r\n        // the addition is dangerous, because the result will be rounded, so the result depends on the lowest bits, which will be cut away!\r\n        var carry = ((exporter.toUint32(high16) + exporter.toUint32(low16)) >= POW_2_32) ? 1 : 0;\r\n        resultUint32Array2[0] = (exporter.highPart(high16) + exporter.highPart(low16) + carry) >>> 0;\r\n        resultUint32Array2[1] = ((high16 >>> 0) + (low16 >>> 0));// >>> 0;\r\n    };\r\n\r\n}) ((typeof module !== 'undefined') ? module.exports = {} : window.uint32 = {});\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}