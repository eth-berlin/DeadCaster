{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport * as cbor from 'cborg';\nimport { AbstractSigner, BrowserProvider, JsonRpcProvider, Transaction, getBytes, isBytesLike, AbstractProvider, hexlify } from 'ethers';\nimport { Kind as CipherKind } from './cipher.js';\nimport { CallError } from './index.js';\nimport { SignedCallDataPack } from './signed_calls.js';\nimport { KeyFetcher } from './calldatapublickey.js';\nconst SAPPHIRE_PROP = 'sapphire';\nfunction fillOptions(options) {\n  if (!options) {\n    options = {};\n  }\n  if (!options.fetcher) {\n    options.fetcher = new KeyFetcher();\n  }\n  return options;\n}\nexport function wrap(upstream, options) {\n  // Already wrapped, so don't wrap it again.\n  if (typeof upstream !== 'string' && Reflect.get(upstream, SAPPHIRE_PROP) !== undefined) {\n    return upstream;\n  }\n  if (typeof upstream === 'string') {\n    upstream = new JsonRpcProvider(upstream);\n  }\n  const filled_options = fillOptions(options);\n  if (isEthersSigner(upstream)) {\n    return wrapEthersSigner(upstream, filled_options);\n  }\n  if (isEthersProvider(upstream)) {\n    return wrapEthersProvider(upstream, filled_options);\n  }\n  // The only other thing we wrap is EIP-1193 compatible providers\n  if (isEIP1193Provider(upstream)) {\n    return wrapEIP1193Provider(upstream, filled_options);\n  }\n  throw new TypeError('Unable to wrap unsupported provider.');\n}\n// -----------------------------------------------------------------------------\n// Wrap an EIP-1193 compatible provider\n// Under the hood, we wrap it in an ethers BrowserProvider to be used internally\nfunction isEIP1193Provider(upstream) {\n  return 'request' in upstream;\n}\nfunction wrapEIP1193Provider(upstream, options) {\n  const filled_options = fillOptions(options);\n  const browserProvider = new BrowserProvider(upstream);\n  const request = hookEIP1193Request(browserProvider, filled_options);\n  const hooks = {\n    request: request\n  };\n  if ('send' in upstream) {\n    // Send is deprecated, but still used by ethers\n    hooks['send'] = (...args) => __awaiter(this, void 0, void 0, function* () {\n      return yield request({\n        method: args[0],\n        params: args[1]\n      });\n    });\n  }\n  if ('sendAsync' in upstream) {\n    // sendAsync is deprecated, it historically has an incoherent interface\n    hooks['sendAsync'] = () => {\n      throw new Error('sendAsync not supported by Sapphire wrapper!');\n    };\n  }\n  return makeProxy(upstream, filled_options, hooks);\n}\nfunction hookEIP1193Request(provider, options) {\n  return args => __awaiter(this, void 0, void 0, function* () {\n    const signer = yield provider.getSigner();\n    const cipher = yield options.fetcher.cipher(provider);\n    const {\n      method,\n      params\n    } = yield prepareRequest(args, signer, cipher);\n    const res = yield signer.provider.send(method, params !== null && params !== void 0 ? params : []);\n    if (method === 'eth_call') {\n      return yield cipher.decryptEncoded(res);\n    }\n    return res;\n  });\n}\n// -----------------------------------------------------------------------------\nfunction makeProxy(upstream, options, hooks) {\n  return new Proxy(upstream, {\n    get(upstream, prop) {\n      if (prop === SAPPHIRE_PROP) return options;\n      if (prop in hooks) return Reflect.get(hooks, prop);\n      const value = Reflect.get(upstream, prop);\n      return typeof value === 'function' ? value.bind(upstream) : value;\n    }\n  });\n}\n// -----------------------------------------------------------------------------\nexport function wrapEthersSigner(upstream, options) {\n  const filled_options = fillOptions(options);\n  let signer;\n  if (upstream.provider) {\n    try {\n      const x = wrapEthersProvider(upstream.provider, filled_options, upstream);\n      signer = upstream.connect(x);\n    } catch (e) {\n      if (e.code !== 'UNSUPPORTED_OPERATION') throw e;\n      signer = upstream;\n    }\n  } else {\n    signer = upstream;\n  }\n  const hooks = {\n    sendTransaction: hookEthersSend(signer.sendTransaction.bind(signer), filled_options, signer),\n    signTransaction: hookEthersSend(signer.signTransaction.bind(signer), filled_options, signer),\n    call: hookEthersCall(signer, 'call', filled_options),\n    estimateGas: hookEthersCall(signer, 'estimateGas', filled_options),\n    connect(provider) {\n      const wp = signer.connect(provider);\n      return wrapEthersSigner(wp, filled_options);\n    }\n  };\n  return makeProxy(signer, filled_options, hooks);\n}\nexport function wrapEthersProvider(provider, options, signer) {\n  const filled_options = fillOptions(options);\n  // Already wrapped, so don't wrap it again.\n  if (Reflect.get(provider, SAPPHIRE_PROP) !== undefined) {\n    return provider;\n  }\n  const hooks = {\n    // Calls can be unsigned, but must be enveloped.\n    call: hookEthersCall(provider, 'call', filled_options),\n    estimateGas: hookEthersCall(provider, 'estimateGas', filled_options)\n  };\n  // When a signer is also provided, we can re-pack transactions\n  // But only if they've been signed by the same address as the signer\n  if (signer) {\n    // Ethers v6 `sendTransaction` takes `TransactionRequest`\n    //  v6 equivalent to `sendTransaction` is `broadcastTransaction`\n    if ('broadcastTransaction' in provider) {\n      hooks['broadcastTransaction'] = raw => __awaiter(this, void 0, void 0, function* () {\n        const cipher = yield filled_options.fetcher.cipher(provider);\n        const repacked = yield repackRawTx(raw, cipher, signer);\n        return provider.broadcastTransaction(repacked);\n      });\n    } else {\n      // Ethers v5 doesn't have `broadcastTransaction`\n      // Ethers v5 `sendTransaction` takes hex encoded byte string\n      hooks['sendTransaction'] = raw => __awaiter(this, void 0, void 0, function* () {\n        const cipher = yield filled_options.fetcher.cipher(provider);\n        const repacked = yield repackRawTx(raw, cipher, signer);\n        return provider.sendTransaction(repacked);\n      });\n    }\n  }\n  return makeProxy(provider, filled_options, hooks);\n}\nfunction isEthers5Signer(upstream) {\n  return Reflect.get(upstream, '_isSigner') === true;\n}\nfunction isEthers6Signer(upstream) {\n  return upstream instanceof AbstractSigner || Reflect.get(upstream, 'signTypedData') !== undefined && Reflect.get(upstream, 'signTransaction') !== undefined;\n}\nfunction isEthersSigner(upstream) {\n  return isEthers5Signer(upstream) || isEthers6Signer(upstream);\n}\nfunction isEthers5Provider(upstream) {\n  return Reflect.get(upstream, '_isProvider') === true;\n}\nfunction isEthers6Provider(upstream) {\n  return upstream instanceof AbstractProvider || Reflect.get(upstream, 'waitForBlock') && Reflect.get(upstream, 'destroy') && Reflect.get(upstream, 'broadcastTransaction');\n}\nfunction isEthersProvider(upstream) {\n  return isEthers5Provider(upstream) || isEthers6Provider(upstream);\n}\nfunction hookEthersCall(runner, method, options) {\n  const sendUnsignedCall = (runner, call, is_already_enveloped, cipher) => __awaiter(this, void 0, void 0, function* () {\n    var _a;\n    let call_data = call.data;\n    if (!is_already_enveloped) {\n      call_data = yield cipher.encryptEncode((_a = call.data) !== null && _a !== void 0 ? _a : new Uint8Array());\n    }\n    const result = yield runner[method](Object.assign(Object.assign({}, call), {\n      data: hexlify(call_data)\n    }));\n    return result;\n  });\n  return call => __awaiter(this, void 0, void 0, function* () {\n    // Ethers v6 uses `populateCall` internally to fill in the `from` field etc.\n    // It's necessary to call this, if it exists, otherwise signed queries won't work\n    const populateCall = Reflect.get(runner, 'populateCall');\n    if (populateCall !== undefined) {\n      call = yield populateCall.bind(runner)(call);\n    }\n    let res;\n    const is_already_enveloped = isCalldataEnveloped(call.data, true);\n    const cipher = yield options.fetcher.cipher(runner);\n    if (!is_already_enveloped && isEthersSigner(runner)) {\n      const signer = runner;\n      if (!signer.provider) throw new Error('signer not connected to a provider');\n      const provider = signer.provider;\n      if (yield callNeedsSigning(call)) {\n        const dataPack = yield SignedCallDataPack.make(call, signer);\n        res = yield provider[method](Object.assign(Object.assign({}, call), {\n          data: yield dataPack.encryptEncode(cipher)\n        }));\n      } else {\n        res = yield sendUnsignedCall(provider, call, is_already_enveloped, cipher);\n      }\n    } else {\n      res = yield sendUnsignedCall(runner, call, is_already_enveloped, cipher);\n    }\n    // NOTE: if it's already enveloped, caller will decrypt it (not us)\n    if (!is_already_enveloped && typeof res === 'string') {\n      return yield cipher.decryptEncoded(res);\n    }\n    return res;\n  });\n}\nfunction hookEthersSend(send, options, signer) {\n  return (tx, ...rest) => __awaiter(this, void 0, void 0, function* () {\n    if (tx.data) {\n      const cipher = yield options.fetcher.cipher(signer);\n      tx.data = yield cipher.encryptEncode(tx.data);\n    }\n    return send(tx, ...rest);\n  });\n}\n// -----------------------------------------------------------------------------\nfunction callNeedsSigning(callP) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [from, to] = yield Promise.all([callP.from, callP.to]);\n    return !!to && !!from && typeof from === 'string' && !/^(0x)?0{40}$/.test(from);\n  });\n}\nfunction prepareRequest({\n  method,\n  params\n}, signer, cipher) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!Array.isArray(params)) return {\n      method,\n      params\n    };\n    if (method === 'eth_sendRawTransaction') {\n      return {\n        method,\n        params: [yield repackRawTx(params[0], cipher, signer)]\n      };\n    }\n    if ((method === 'eth_call' || method === 'eth_estimateGas') && (yield callNeedsSigning(params[0]))) {\n      const dataPack = yield SignedCallDataPack.make(params[0], signer);\n      const signedCall = Object.assign(Object.assign({}, params[0]), {\n        data: yield dataPack.encryptEncode(cipher)\n      });\n      return {\n        method,\n        params: [signedCall, ...params.slice(1)]\n      };\n    }\n    if (/^eth_((send|sign)Transaction|call|estimateGas)$/.test(method) && params[0].data // Ignore balance transfers without calldata\n    ) {\n      params[0].data = yield cipher.encryptEncode(params[0].data);\n      return {\n        method,\n        params\n      };\n    }\n    return {\n      method,\n      params\n    };\n  });\n}\nclass EnvelopeError extends Error {}\nconst REPACK_ERROR = 'Un-enveloped data was passed to sendRawTransaction, which is likely incorrect. Is the dapp using the Sapphire compat lib correctly?';\n/** Repacks and signs a sendRawTransaction if needed and possible. */\nfunction repackRawTx(raw, cipher, signer) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const tx = Transaction.from(raw);\n    // If raw transaction is enveloped & signed correctly, bypass re-packing\n    if (isCalldataEnveloped(tx.data, false)) {\n      return raw;\n    }\n    // When transaction is signed by another keypair and we don't have that signer\n    // bypass re-packing, this allows repacking to pass-thru pre-signed txs\n    if (tx.isSigned() && (!signer || (yield signer.getAddress()) !== tx.from)) {\n      return raw;\n    }\n    tx.data = yield cipher.encryptEncode(tx.data);\n    try {\n      return signer.signTransaction(tx);\n    } catch (e) {\n      // Many JSON-RPC providers, Ethers included, will not let you directly\n      // sign transactions, which is necessary to re-encrypt the calldata!\n      // Throw an error here to prevent calls which should've been encrypted\n      // from being submitted unencrypted.\n      throw new CallError(REPACK_ERROR, e);\n    }\n  });\n}\nfunction isSignedQuery(x) {\n  return 'data' in x && 'leash' in x && 'signature' in x;\n}\nfunction isCalldataEnveloped(calldata, allowSignedQuery) {\n  try {\n    const outer_envelope = cbor.decode(getBytes(calldata));\n    let envelope;\n    if (isSignedQuery(outer_envelope)) {\n      if (!allowSignedQuery) {\n        throw new EnvelopeError('Got unexpected signed query!');\n      }\n      envelope = outer_envelope.data;\n    } else {\n      envelope = outer_envelope;\n    }\n    if (!envelopeFormatOk(envelope)) {\n      throw new EnvelopeError('Bogus Sapphire enveloped data found in transaction!');\n    }\n    return true;\n  } catch (e) {\n    if (e instanceof EnvelopeError) throw e;\n  }\n  return false;\n}\nfunction envelopeFormatOk(envelope) {\n  const {\n      format,\n      body\n    } = envelope,\n    extra = __rest(envelope, [\"format\", \"body\"]);\n  if (Object.keys(extra).length > 0) return false;\n  if (!body) return false;\n  if (format !== null && format !== CipherKind.Plain) {\n    if (isBytesLike(body)) return false;\n    if (!isBytesLike(body.data)) return false;\n  }\n  return true;\n}","map":{"version":3,"names":["cbor","AbstractSigner","BrowserProvider","JsonRpcProvider","Transaction","getBytes","isBytesLike","AbstractProvider","hexlify","Kind","CipherKind","CallError","SignedCallDataPack","KeyFetcher","SAPPHIRE_PROP","fillOptions","options","fetcher","wrap","upstream","Reflect","get","undefined","filled_options","isEthersSigner","wrapEthersSigner","isEthersProvider","wrapEthersProvider","isEIP1193Provider","wrapEIP1193Provider","TypeError","browserProvider","request","hookEIP1193Request","hooks","args","__awaiter","method","params","Error","makeProxy","provider","signer","getSigner","cipher","prepareRequest","res","send","decryptEncoded","Proxy","prop","value","bind","x","connect","e","code","sendTransaction","hookEthersSend","signTransaction","call","hookEthersCall","estimateGas","wp","raw","repacked","repackRawTx","broadcastTransaction","isEthers5Signer","isEthers6Signer","isEthers5Provider","isEthers6Provider","runner","sendUnsignedCall","is_already_enveloped","call_data","data","encryptEncode","_a","Uint8Array","result","Object","assign","populateCall","isCalldataEnveloped","callNeedsSigning","dataPack","make","tx","rest","callP","from","to","Promise","all","test","Array","isArray","signedCall","slice","EnvelopeError","REPACK_ERROR","isSigned","getAddress","isSignedQuery","calldata","allowSignedQuery","outer_envelope","decode","envelope","envelopeFormatOk","format","body","extra","__rest","keys","length","Plain"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@oasisprotocol/sapphire-paratime/src/compat.ts"],"sourcesContent":["import * as cbor from 'cborg';\nimport {\n  Provider,\n  AbstractSigner,\n  BrowserProvider,\n  ContractRunner,\n  JsonRpcProvider,\n  JsonRpcSigner,\n  Signer,\n  Transaction,\n  TransactionRequest,\n  TransactionResponse,\n  getBytes,\n  isBytesLike,\n  AbstractProvider,\n  BytesLike,\n  hexlify,\n} from 'ethers';\n\nimport { Kind as CipherKind, Envelope, Cipher } from './cipher.js';\n\nimport { CallError } from './index.js';\n\nimport { EthCall, Leash, SignedCallDataPack } from './signed_calls.js';\n\nimport {\n  Deferrable,\n  Ethers5Signer,\n  Ethers5Provider,\n  EIP1193Provider,\n  Web3ReqArgs,\n  UpstreamProvider,\n} from './interfaces.js';\n\nimport { AbstractKeyFetcher, KeyFetcher } from './calldatapublickey.js';\n\ninterface SapphireWrapOptions {\n  fetcher: AbstractKeyFetcher;\n}\n\nconst SAPPHIRE_PROP = 'sapphire';\nexport type SapphireAnnex = {\n  [SAPPHIRE_PROP]: SapphireWrapOptions;\n};\n\nfunction fillOptions(\n  options: SapphireWrapOptions | undefined,\n): SapphireWrapOptions {\n  if (!options) {\n    options = {} as SapphireWrapOptions;\n  }\n  if (!options.fetcher) {\n    options.fetcher = new KeyFetcher();\n  }\n  return options;\n}\n\n/**\n * Wraps an upstream ethers/web3/EIP-1193 provider to speak the Sapphire format.\n *\n * @param upstream The upstream web3 provider. Try something like one of the following:\n * ```\n * ethers.providers.Web3Provider(window.ethereum)\n * ethers.Wallet(privateKey)\n * ethers.getDefaultProvider(NETWORKS.testnet.defaultGateway)\n * window.ethereum\n * a Web3 gateway URL\n * ```\n */\nexport function wrap<U extends EIP1193Provider>(\n  upstream: U,\n  options?: SapphireWrapOptions,\n): U & SapphireAnnex; // `window.ethereum`\n\nexport function wrap<U extends Ethers5Provider>(\n  upstream: U,\n  options?: SapphireWrapOptions,\n): U & SapphireAnnex; // Ethers providers\n\nexport function wrap<U extends Ethers5Signer>(\n  upstream: U,\n  options?: SapphireWrapOptions,\n): U & SapphireAnnex; // Ethers signers\n\nexport function wrap<U extends UpstreamProvider>(\n  upstream: U,\n  options?: SapphireWrapOptions,\n): U & SapphireAnnex {\n  // Already wrapped, so don't wrap it again.\n  if (\n    typeof upstream !== 'string' &&\n    Reflect.get(upstream, SAPPHIRE_PROP) !== undefined\n  ) {\n    return upstream as U & SapphireAnnex;\n  }\n\n  if (typeof upstream === 'string') {\n    upstream = new JsonRpcProvider(upstream) as any;\n  }\n\n  const filled_options = fillOptions(options);\n\n  if (isEthersSigner(upstream)) {\n    return wrapEthersSigner(upstream as Ethers5Signer, filled_options) as any;\n  }\n\n  if (isEthersProvider(upstream)) {\n    return wrapEthersProvider(upstream, filled_options);\n  }\n\n  // The only other thing we wrap is EIP-1193 compatible providers\n  if (isEIP1193Provider(upstream)) {\n    return wrapEIP1193Provider(upstream, filled_options);\n  }\n\n  throw new TypeError('Unable to wrap unsupported provider.');\n}\n\n// -----------------------------------------------------------------------------\n// Wrap an EIP-1193 compatible provider\n// Under the hood, we wrap it in an ethers BrowserProvider to be used internally\n\nfunction isEIP1193Provider(upstream: object): upstream is EIP1193Provider {\n  return 'request' in upstream;\n}\n\nfunction wrapEIP1193Provider<P extends EIP1193Provider>(\n  upstream: P,\n  options?: SapphireWrapOptions,\n): P & SapphireAnnex {\n  const filled_options = fillOptions(options);\n  const browserProvider = new BrowserProvider(upstream);\n  const request = hookEIP1193Request(browserProvider, filled_options);\n  const hooks: Record<string, any> = {\n    request: request,\n  };\n  if ('send' in upstream) {\n    // Send is deprecated, but still used by ethers\n    hooks['send'] = async (...args: any[]) => {\n      return await request({ method: args[0], params: args[1] });\n    };\n  }\n  if ('sendAsync' in upstream) {\n    // sendAsync is deprecated, it historically has an incoherent interface\n    hooks['sendAsync'] = () => {\n      throw new Error('sendAsync not supported by Sapphire wrapper!');\n    };\n  }\n  return makeProxy(upstream, filled_options, hooks);\n}\n\nfunction hookEIP1193Request(\n  provider: BrowserProvider,\n  options: SapphireWrapOptions,\n): EIP1193Provider['request'] {\n  return async (args: Web3ReqArgs) => {\n    const signer = await provider.getSigner();\n    const cipher = await options.fetcher.cipher(provider);\n    const { method, params } = await prepareRequest(args, signer, cipher);\n    const res = await signer.provider.send(method, params ?? []);\n    if (method === 'eth_call') {\n      return await cipher.decryptEncoded(res);\n    }\n    return res;\n  };\n}\n\n// -----------------------------------------------------------------------------\n\nfunction makeProxy<U extends UpstreamProvider>(\n  upstream: U,\n  options: SapphireWrapOptions,\n  hooks: Record<string, any>,\n): U & SapphireAnnex {\n  return new Proxy(upstream, {\n    get(upstream, prop) {\n      if (prop === SAPPHIRE_PROP) return options;\n      if (prop in hooks) return Reflect.get(hooks, prop);\n      const value = Reflect.get(upstream, prop);\n      return typeof value === 'function' ? value.bind(upstream) : value;\n    },\n  }) as U & SapphireAnnex;\n}\n\n// -----------------------------------------------------------------------------\n\nexport function wrapEthersSigner<P extends Ethers5Signer>(\n  upstream: P,\n  options?: SapphireWrapOptions,\n): P & SapphireAnnex {\n  const filled_options = fillOptions(options);\n\n  let signer: Ethers5Signer;\n  if (upstream.provider) {\n    try {\n      const x = wrapEthersProvider(upstream.provider, filled_options, upstream);\n      signer = upstream.connect(x as any);\n    } catch (e: any) {\n      if (e.code !== 'UNSUPPORTED_OPERATION') throw e;\n      signer = upstream;\n    }\n  } else {\n    signer = upstream;\n  }\n  const hooks = {\n    sendTransaction: hookEthersSend(\n      signer.sendTransaction.bind(signer),\n      filled_options,\n      signer,\n    ),\n    signTransaction: hookEthersSend(\n      signer.signTransaction.bind(signer),\n      filled_options,\n      signer,\n    ),\n    call: hookEthersCall(signer, 'call', filled_options),\n    estimateGas: hookEthersCall(signer, 'estimateGas', filled_options),\n    connect(provider: Ethers5Provider) {\n      const wp = signer.connect(provider);\n      return wrapEthersSigner(wp, filled_options);\n    },\n  };\n  return makeProxy(signer as any, filled_options, hooks);\n}\n\ninterface Ethers5ProviderWithSend {\n  sendTransaction(\n    signedTransaction: string | Promise<string>,\n  ): Promise<TransactionResponse>;\n}\n\nexport function wrapEthersProvider<P extends Provider | Ethers5Provider>(\n  provider: P,\n  options?: SapphireWrapOptions,\n  signer?: Ethers5Signer | Signer,\n): P & SapphireAnnex {\n  const filled_options = fillOptions(options);\n\n  // Already wrapped, so don't wrap it again.\n  if (Reflect.get(provider, SAPPHIRE_PROP) !== undefined) {\n    return provider as P & SapphireAnnex;\n  }\n\n  const hooks: Record<string, any> = {\n    // Calls can be unsigned, but must be enveloped.\n    call: hookEthersCall(provider, 'call', filled_options),\n    estimateGas: hookEthersCall(provider, 'estimateGas', filled_options),\n  };\n\n  // When a signer is also provided, we can re-pack transactions\n  // But only if they've been signed by the same address as the signer\n  if (signer) {\n    // Ethers v6 `sendTransaction` takes `TransactionRequest`\n    //  v6 equivalent to `sendTransaction` is `broadcastTransaction`\n    if ('broadcastTransaction' in provider) {\n      hooks['broadcastTransaction'] = <Provider['broadcastTransaction']>(async (\n        raw: string,\n      ) => {\n        const cipher = await filled_options.fetcher.cipher(provider);\n        const repacked = await repackRawTx(raw, cipher, signer);\n        return (provider as Provider).broadcastTransaction(repacked);\n      });\n    } else {\n      // Ethers v5 doesn't have `broadcastTransaction`\n      // Ethers v5 `sendTransaction` takes hex encoded byte string\n      hooks['sendTransaction'] = <Ethers5ProviderWithSend['sendTransaction']>(\n        (async (raw: string) => {\n          const cipher = await filled_options.fetcher.cipher(provider);\n          const repacked = await repackRawTx(raw, cipher, signer);\n          return (\n            provider as unknown as Ethers5ProviderWithSend\n          ).sendTransaction(repacked);\n        })\n      );\n    }\n  }\n\n  return makeProxy(provider, filled_options, hooks);\n}\n\nfunction isEthers5Signer(upstream: object): upstream is Ethers5Signer {\n  return Reflect.get(upstream, '_isSigner') === true;\n}\n\nfunction isEthers6Signer(upstream: object): upstream is Signer {\n  return (\n    upstream instanceof AbstractSigner ||\n    (Reflect.get(upstream, 'signTypedData') !== undefined &&\n      Reflect.get(upstream, 'signTransaction') !== undefined)\n  );\n}\n\nfunction isEthersSigner(upstream: object): upstream is Signer | Ethers5Signer {\n  return isEthers5Signer(upstream) || isEthers6Signer(upstream);\n}\n\nfunction isEthers5Provider(upstream: object): upstream is Ethers5Signer {\n  return Reflect.get(upstream, '_isProvider') === true;\n}\n\nfunction isEthers6Provider(upstream: object): upstream is Provider {\n  return (\n    upstream instanceof AbstractProvider ||\n    (Reflect.get(upstream, 'waitForBlock') &&\n      Reflect.get(upstream, 'destroy') &&\n      Reflect.get(upstream, 'broadcastTransaction'))\n  );\n}\n\nfunction isEthersProvider(\n  upstream: object,\n): upstream is Provider | Ethers5Provider {\n  return isEthers5Provider(upstream) || isEthers6Provider(upstream);\n}\n\nfunction hookEthersCall(\n  runner: Ethers5Provider | Ethers5Signer | ContractRunner,\n  method: 'call' | 'estimateGas',\n  options: SapphireWrapOptions,\n): EthersCall | undefined {\n  const sendUnsignedCall = async (\n    runner: Ethers5Provider | Ethers5Signer | ContractRunner,\n    call: EthCall | TransactionRequest,\n    is_already_enveloped: boolean,\n    cipher: Cipher,\n  ) => {\n    let call_data = call.data;\n    if (!is_already_enveloped) {\n      call_data = await cipher.encryptEncode(call.data ?? new Uint8Array());\n    }\n    const result = await runner[method]!({\n      ...call,\n      data: hexlify(call_data!),\n    });\n    return result;\n  };\n  return async (call) => {\n    // Ethers v6 uses `populateCall` internally to fill in the `from` field etc.\n    // It's necessary to call this, if it exists, otherwise signed queries won't work\n    const populateCall = Reflect.get(runner, 'populateCall');\n    if (populateCall !== undefined) {\n      call = await populateCall.bind(runner)(call);\n    }\n\n    let res: string;\n    const is_already_enveloped = isCalldataEnveloped(call.data!, true);\n    const cipher = await options.fetcher.cipher(runner as any);\n    if (!is_already_enveloped && isEthersSigner(runner)) {\n      const signer = runner;\n      if (!signer.provider)\n        throw new Error('signer not connected to a provider');\n      const provider = signer.provider;\n      if (await callNeedsSigning(call)) {\n        const dataPack = await SignedCallDataPack.make(call, signer);\n        res = await provider[method]({\n          ...call,\n          data: await dataPack.encryptEncode(cipher),\n        });\n      } else {\n        res = await sendUnsignedCall(\n          provider,\n          call,\n          is_already_enveloped,\n          cipher,\n        );\n      }\n    } else {\n      res = await sendUnsignedCall(runner, call, is_already_enveloped, cipher);\n    }\n    // NOTE: if it's already enveloped, caller will decrypt it (not us)\n    if (!is_already_enveloped && typeof res === 'string') {\n      return await cipher.decryptEncoded(res);\n    }\n    return res;\n  };\n}\n\ntype EthersCall = (tx: EthCall | TransactionRequest) => Promise<unknown>;\n\nfunction hookEthersSend<C>(\n  send: C,\n  options: SapphireWrapOptions,\n  signer: Ethers5Signer,\n): C {\n  return (async (tx: EthCall | TransactionRequest, ...rest: any[]) => {\n    if (tx.data) {\n      const cipher = await options.fetcher.cipher(signer);\n      tx.data = await cipher.encryptEncode(tx.data);\n    }\n    return (send as any)(tx, ...rest);\n  }) as C;\n}\n\n// -----------------------------------------------------------------------------\n\nasync function callNeedsSigning(\n  callP: Deferrable<EthCall> | TransactionRequest,\n): Promise<boolean> {\n  const [from, to] = await Promise.all([callP.from, callP.to]);\n  return (\n    !!to && !!from && typeof from === 'string' && !/^(0x)?0{40}$/.test(from)\n  );\n}\n\nasync function prepareRequest(\n  { method, params }: Web3ReqArgs,\n  signer: JsonRpcSigner,\n  cipher: Cipher,\n): Promise<{ method: string; params?: Array<any> }> {\n  if (!Array.isArray(params)) return { method, params };\n\n  if (method === 'eth_sendRawTransaction') {\n    return {\n      method,\n      params: [await repackRawTx(params[0], cipher, signer)],\n    };\n  }\n\n  if (\n    (method === 'eth_call' || method === 'eth_estimateGas') &&\n    (await callNeedsSigning(params[0]))\n  ) {\n    const dataPack = await SignedCallDataPack.make(params[0], signer);\n    const signedCall = {\n      ...params[0],\n      data: await dataPack.encryptEncode(cipher),\n    };\n    return {\n      method,\n      params: [signedCall, ...params.slice(1)],\n    };\n  }\n\n  if (\n    /^eth_((send|sign)Transaction|call|estimateGas)$/.test(method) &&\n    params[0].data // Ignore balance transfers without calldata\n  ) {\n    params[0].data = await cipher.encryptEncode(params[0].data);\n    return { method, params };\n  }\n\n  return { method, params };\n}\n\nclass EnvelopeError extends Error {}\n\nconst REPACK_ERROR =\n  'Un-enveloped data was passed to sendRawTransaction, which is likely incorrect. Is the dapp using the Sapphire compat lib correctly?';\n\n/** Repacks and signs a sendRawTransaction if needed and possible. */\nasync function repackRawTx(\n  raw: string,\n  cipher: Cipher,\n  signer?: Ethers5Signer | Signer,\n): Promise<string> {\n  const tx = Transaction.from(raw);\n\n  // If raw transaction is enveloped & signed correctly, bypass re-packing\n  if (isCalldataEnveloped(tx.data, false)) {\n    return raw;\n  }\n\n  // When transaction is signed by another keypair and we don't have that signer\n  // bypass re-packing, this allows repacking to pass-thru pre-signed txs\n  if (tx.isSigned() && (!signer || (await signer!.getAddress()) !== tx.from!)) {\n    return raw;\n  }\n\n  tx.data = await cipher.encryptEncode(tx.data);\n\n  try {\n    return signer!.signTransaction(tx);\n  } catch (e) {\n    // Many JSON-RPC providers, Ethers included, will not let you directly\n    // sign transactions, which is necessary to re-encrypt the calldata!\n    // Throw an error here to prevent calls which should've been encrypted\n    // from being submitted unencrypted.\n    throw new CallError(REPACK_ERROR, e);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Determine if the CBOR encoded calldata is a signed query or an evelope\n\ninterface SignedQuery {\n  data: Envelope;\n  leash: Leash;\n  signature: Uint8Array;\n}\ntype SignedQueryOrEnvelope = Envelope | SignedQuery;\n\nfunction isSignedQuery(x: SignedQueryOrEnvelope): x is SignedQuery {\n  return 'data' in x && 'leash' in x && 'signature' in x;\n}\n\nfunction isCalldataEnveloped(calldata: BytesLike, allowSignedQuery: boolean) {\n  try {\n    const outer_envelope = cbor.decode(\n      getBytes(calldata),\n    ) as SignedQueryOrEnvelope;\n    let envelope: Envelope;\n    if (isSignedQuery(outer_envelope)) {\n      if (!allowSignedQuery) {\n        throw new EnvelopeError('Got unexpected signed query!');\n      }\n      envelope = outer_envelope.data;\n    } else {\n      envelope = outer_envelope;\n    }\n    if (!envelopeFormatOk(envelope)) {\n      throw new EnvelopeError(\n        'Bogus Sapphire enveloped data found in transaction!',\n      );\n    }\n    return true;\n  } catch (e: any) {\n    if (e instanceof EnvelopeError) throw e;\n  }\n  return false;\n}\n\nfunction envelopeFormatOk(envelope: Envelope): boolean {\n  const { format, body, ...extra } = envelope;\n\n  if (Object.keys(extra).length > 0) return false;\n\n  if (!body) return false;\n\n  if (format !== null && format !== CipherKind.Plain) {\n    if (isBytesLike(body)) return false;\n\n    if (!isBytesLike(body.data)) return false;\n  }\n\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}