{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport { assert, isHexString } from \"../utils/index.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider, event) {\n  if (event === \"block\") {\n    return new PollingBlockSubscriber(provider);\n  }\n  if (isHexString(event, 32)) {\n    return new PollingTransactionSubscriber(provider, event);\n  }\n  assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getPollingSubscriber\",\n    info: {\n      event\n    }\n  });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _poller = /*#__PURE__*/new WeakMap();\nvar _interval = /*#__PURE__*/new WeakMap();\nvar _blockNumber = /*#__PURE__*/new WeakMap();\nvar _PollingBlockSubscriber_brand = /*#__PURE__*/new WeakSet();\nexport class PollingBlockSubscriber {\n  /**\n   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    _classPrivateMethodInitSpec(this, _PollingBlockSubscriber_brand);\n    _classPrivateFieldInitSpec(this, _provider, void 0);\n    _classPrivateFieldInitSpec(this, _poller, void 0);\n    _classPrivateFieldInitSpec(this, _interval, void 0);\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    _classPrivateFieldInitSpec(this, _blockNumber, void 0);\n    _classPrivateFieldSet(_provider, this, provider);\n    _classPrivateFieldSet(_poller, this, null);\n    _classPrivateFieldSet(_interval, this, 4000);\n    _classPrivateFieldSet(_blockNumber, this, -2);\n  }\n  /**\n   *  The polling interval.\n   */\n  get pollingInterval() {\n    return _classPrivateFieldGet(_interval, this);\n  }\n  set pollingInterval(value) {\n    _classPrivateFieldSet(_interval, this, value);\n  }\n  start() {\n    if (_classPrivateFieldGet(_poller, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_poller, this, _classPrivateFieldGet(_provider, this)._setTimeout(_assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).bind(this), _classPrivateFieldGet(_interval, this)));\n    _assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).call(this);\n  }\n  stop() {\n    if (!_classPrivateFieldGet(_poller, this)) {\n      return;\n    }\n    _classPrivateFieldGet(_provider, this)._clearTimeout(_classPrivateFieldGet(_poller, this));\n    _classPrivateFieldSet(_poller, this, null);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      _classPrivateFieldSet(_blockNumber, this, -2);\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nasync function _poll() {\n  try {\n    const blockNumber = await _classPrivateFieldGet(_provider, this).getBlockNumber();\n    // Bootstrap poll to setup our initial block number\n    if (_classPrivateFieldGet(_blockNumber, this) === -2) {\n      _classPrivateFieldSet(_blockNumber, this, blockNumber);\n      return;\n    }\n    // @TODO: Put a cap on the maximum number of events per loop?\n    if (blockNumber !== _classPrivateFieldGet(_blockNumber, this)) {\n      for (let b = _classPrivateFieldGet(_blockNumber, this) + 1; b <= blockNumber; b++) {\n        // We have been stopped\n        if (_classPrivateFieldGet(_poller, this) == null) {\n          return;\n        }\n        await _classPrivateFieldGet(_provider, this).emit(\"block\", b);\n      }\n      _classPrivateFieldSet(_blockNumber, this, blockNumber);\n    }\n  } catch (error) {\n    // @TODO: Minor bump, add an \"error\" event to let subscribers\n    //        know things went awry.\n    //console.log(error);\n  }\n  // We have been stopped\n  if (_classPrivateFieldGet(_poller, this) == null) {\n    return;\n  }\n  _classPrivateFieldSet(_poller, this, _classPrivateFieldGet(_provider, this)._setTimeout(_assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).bind(this), _classPrivateFieldGet(_interval, this)));\n}\nvar _provider2 = /*#__PURE__*/new WeakMap();\nvar _poll2 = /*#__PURE__*/new WeakMap();\nvar _running = /*#__PURE__*/new WeakMap();\nexport class OnBlockSubscriber {\n  /**\n   *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    _classPrivateFieldInitSpec(this, _provider2, void 0);\n    _classPrivateFieldInitSpec(this, _poll2, void 0);\n    _classPrivateFieldInitSpec(this, _running, void 0);\n    _classPrivateFieldSet(_provider2, this, provider);\n    _classPrivateFieldSet(_running, this, false);\n    _classPrivateFieldSet(_poll2, this, blockNumber => {\n      this._poll(blockNumber, _classPrivateFieldGet(_provider2, this));\n    });\n  }\n  /**\n   *  Called on every new block.\n   */\n  async _poll(blockNumber, provider) {\n    throw new Error(\"sub-classes must override this\");\n  }\n  start() {\n    if (_classPrivateFieldGet(_running, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running, this, true);\n    _classPrivateFieldGet(_poll2, this).call(this, -2);\n    _classPrivateFieldGet(_provider2, this).on(\"block\", _classPrivateFieldGet(_poll2, this));\n  }\n  stop() {\n    if (!_classPrivateFieldGet(_running, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running, this, false);\n    _classPrivateFieldGet(_provider2, this).off(\"block\", _classPrivateFieldGet(_poll2, this));\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n  }\n  resume() {\n    this.start();\n  }\n}\nvar _tag = /*#__PURE__*/new WeakMap();\nvar _lastBlock = /*#__PURE__*/new WeakMap();\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n  constructor(provider, tag) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _tag, void 0);\n    _classPrivateFieldInitSpec(this, _lastBlock, void 0);\n    _classPrivateFieldSet(_tag, this, tag);\n    _classPrivateFieldSet(_lastBlock, this, -2);\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      _classPrivateFieldSet(_lastBlock, this, -2);\n    }\n    super.pause(dropWhilePaused);\n  }\n  async _poll(blockNumber, provider) {\n    const block = await provider.getBlock(_classPrivateFieldGet(_tag, this));\n    if (block == null) {\n      return;\n    }\n    if (_classPrivateFieldGet(_lastBlock, this) === -2) {\n      _classPrivateFieldSet(_lastBlock, this, block.number);\n    } else if (block.number > _classPrivateFieldGet(_lastBlock, this)) {\n      provider.emit(_classPrivateFieldGet(_tag, this), block.number);\n      _classPrivateFieldSet(_lastBlock, this, block.number);\n    }\n  }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _filter = /*#__PURE__*/new WeakMap();\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n  constructor(provider, filter) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _filter, void 0);\n    _classPrivateFieldSet(_filter, this, copy(filter));\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"@TODO\");\n    console.log(_classPrivateFieldGet(_filter, this));\n  }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _hash = /*#__PURE__*/new WeakMap();\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%hash%%.\n   */\n  constructor(provider, hash) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _hash, void 0);\n    _classPrivateFieldSet(_hash, this, hash);\n  }\n  async _poll(blockNumber, provider) {\n    const tx = await provider.getTransactionReceipt(_classPrivateFieldGet(_hash, this));\n    if (tx) {\n      provider.emit(_classPrivateFieldGet(_hash, this), tx);\n    }\n  }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider3 = /*#__PURE__*/new WeakMap();\nvar _filter2 = /*#__PURE__*/new WeakMap();\nvar _poller2 = /*#__PURE__*/new WeakMap();\nvar _running2 = /*#__PURE__*/new WeakMap();\nvar _blockNumber2 = /*#__PURE__*/new WeakMap();\nvar _PollingEventSubscriber_brand = /*#__PURE__*/new WeakSet();\nexport class PollingEventSubscriber {\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%filter%%.\n   */\n  constructor(provider, _filter3) {\n    _classPrivateMethodInitSpec(this, _PollingEventSubscriber_brand);\n    _classPrivateFieldInitSpec(this, _provider3, void 0);\n    _classPrivateFieldInitSpec(this, _filter2, void 0);\n    _classPrivateFieldInitSpec(this, _poller2, void 0);\n    _classPrivateFieldInitSpec(this, _running2, void 0);\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    _classPrivateFieldInitSpec(this, _blockNumber2, void 0);\n    _classPrivateFieldSet(_provider3, this, provider);\n    _classPrivateFieldSet(_filter2, this, copy(_filter3));\n    _classPrivateFieldSet(_poller2, this, _assertClassBrand(_PollingEventSubscriber_brand, this, _poll3).bind(this));\n    _classPrivateFieldSet(_running2, this, false);\n    _classPrivateFieldSet(_blockNumber2, this, -2);\n  }\n  start() {\n    if (_classPrivateFieldGet(_running2, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running2, this, true);\n    if (_classPrivateFieldGet(_blockNumber2, this) === -2) {\n      _classPrivateFieldGet(_provider3, this).getBlockNumber().then(blockNumber => {\n        _classPrivateFieldSet(_blockNumber2, this, blockNumber);\n      });\n    }\n    _classPrivateFieldGet(_provider3, this).on(\"block\", _classPrivateFieldGet(_poller2, this));\n  }\n  stop() {\n    if (!_classPrivateFieldGet(_running2, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running2, this, false);\n    _classPrivateFieldGet(_provider3, this).off(\"block\", _classPrivateFieldGet(_poller2, this));\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      _classPrivateFieldSet(_blockNumber2, this, -2);\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\nasync function _poll3(blockNumber) {\n  // The initial block hasn't been determined yet\n  if (_classPrivateFieldGet(_blockNumber2, this) === -2) {\n    return;\n  }\n  const filter = copy(_classPrivateFieldGet(_filter2, this));\n  filter.fromBlock = _classPrivateFieldGet(_blockNumber2, this) + 1;\n  filter.toBlock = blockNumber;\n  const logs = await _classPrivateFieldGet(_provider3, this).getLogs(filter);\n  // No logs could just mean the node has not indexed them yet,\n  // so we keep a sliding window of 60 blocks to keep scanning\n  if (logs.length === 0) {\n    if (_classPrivateFieldGet(_blockNumber2, this) < blockNumber - 60) {\n      _classPrivateFieldSet(_blockNumber2, this, blockNumber - 60);\n    }\n    return;\n  }\n  for (const log of logs) {\n    _classPrivateFieldGet(_provider3, this).emit(_classPrivateFieldGet(_filter2, this), log);\n    // Only advance the block number when logs were found to\n    // account for networks (like BNB and Polygon) which may\n    // sacrifice event consistency for block event speed\n    _classPrivateFieldSet(_blockNumber2, this, log.blockNumber);\n  }\n}","map":{"version":3,"names":["assert","isHexString","copy","obj","JSON","parse","stringify","getPollingSubscriber","provider","event","PollingBlockSubscriber","PollingTransactionSubscriber","operation","info","_provider","WeakMap","_poller","_interval","_blockNumber","_PollingBlockSubscriber_brand","WeakSet","constructor","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateFieldSet","pollingInterval","_classPrivateFieldGet","value","start","_setTimeout","_assertClassBrand","_poll","bind","call","stop","_clearTimeout","pause","dropWhilePaused","resume","blockNumber","getBlockNumber","b","emit","error","_provider2","_poll2","_running","OnBlockSubscriber","Error","on","off","_tag","_lastBlock","PollingBlockTagSubscriber","tag","block","getBlock","number","_filter","PollingOrphanSubscriber","filter","console","log","_hash","hash","tx","getTransactionReceipt","_provider3","_filter2","_poller2","_running2","_blockNumber2","_PollingEventSubscriber_brand","PollingEventSubscriber","_poll3","then","fromBlock","toBlock","logs","getLogs","length"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/ethers/src.ts/providers/subscriber-polling.ts"],"sourcesContent":["import { assert, isHexString } from \"../utils/index.js\";\n\nimport type { AbstractProvider, Subscriber } from \"./abstract-provider.js\";\nimport type { EventFilter, OrphanFilter, ProviderEvent } from \"./provider.js\";\n\nfunction copy(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider: AbstractProvider, event: ProviderEvent): Subscriber {\n    if (event === \"block\") { return new PollingBlockSubscriber(provider); }\n    if (isHexString(event, 32)) { return new PollingTransactionSubscriber(provider, event); }\n\n    assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\n\n// @TODO: refactor this\n\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poller: null | number;\n\n    #interval: number;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n\n        this.#blockNumber = -2;\n    }\n\n    /**\n     *  The polling interval.\n     */\n    get pollingInterval(): number { return this.#interval; }\n    set pollingInterval(value: number) { this.#interval = value; }\n\n    async #poll(): Promise<void> {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n\n            // @TODO: Put a cap on the maximum number of events per loop?\n\n            if (blockNumber !== this.#blockNumber) {\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                    // We have been stopped\n                    if (this.#poller == null) { return; }\n\n                    await this.#provider.emit(\"block\", b);\n                }\n\n                this.#blockNumber = blockNumber;\n            }\n\n        } catch (error) {\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\n            //        know things went awry.\n            //console.log(error);\n        }\n\n        // We have been stopped\n        if (this.#poller == null) { return; }\n\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n\n    start(): void {\n        if (this.#poller) { return; }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n\n    stop(): void {\n        if (!this.#poller) { return; }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n\n\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poll: (b: number) => void;\n    #running: boolean;\n\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber: number) => {\n            this._poll(blockNumber, this.#provider);\n        }\n    }\n\n    /**\n     *  Called on every new block.\n     */\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"sub-classes must override this\");\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poll);\n    }\n\n    pause(dropWhilePaused?: boolean): void { this.stop(); }\n    resume(): void { this.start(); }\n}\n\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n    readonly #tag: string;\n    #lastBlock: number;\n\n    constructor(provider: AbstractProvider, tag: string) {\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        if (dropWhilePaused) { this.#lastBlock = -2; }\n        super.pause(dropWhilePaused);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) { return; }\n\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        } else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\n\n\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter: OrphanFilter;\n\n    constructor(provider: AbstractProvider, filter: OrphanFilter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash: string;\n\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider: AbstractProvider, hash: string) {\n        super(provider);\n        this.#hash = hash;\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) { provider.emit(this.#hash, tx); }\n    }\n}\n\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #filter: EventFilter;\n    #poller: (b: number) => void;\n\n    #running: boolean;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */\n    constructor(provider: AbstractProvider, filter: EventFilter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n\n    async #poll(blockNumber: number): Promise<void> {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) { return; }\n\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n\n        const logs = await this.#provider.getLogs(filter);\n\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}