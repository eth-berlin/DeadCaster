{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _defineProperty from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { namehash } from \"../hash/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport { concat, dataLength, dataSlice, hexlify, isHexString, getBigInt, getBytes, getNumber, isCallException, isError, makeError, assert, assertArgument, FetchRequest, toBeArray, toQuantity, defineProperties, EventPayload, resolveProperties, toUtf8String } from \"../utils/index.js\";\nimport { EnsResolver } from \"./ens-resolver.js\";\nimport { formatBlock, formatLog, formatTransactionReceipt, formatTransactionResponse } from \"./format.js\";\nimport { Network } from \"./network.js\";\nimport { copyRequest, Block, FeeData, Log, TransactionReceipt, TransactionResponse } from \"./provider.js\";\nimport { PollingBlockSubscriber, PollingBlockTagSubscriber, PollingEventSubscriber, PollingOrphanSubscriber, PollingTransactionSubscriber } from \"./subscriber-polling.js\";\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n  return value && typeof value.then === \"function\";\n}\nfunction getTag(prefix, value) {\n  return prefix + \":\" + JSON.stringify(value, (k, v) => {\n    if (v == null) {\n      return \"null\";\n    }\n    if (typeof v === \"bigint\") {\n      return \"bigint:\".concat(v.toString());\n    }\n    if (typeof v === \"string\") {\n      return v.toLowerCase();\n    }\n    // Sort object keys\n    if (typeof v === \"object\" && !Array.isArray(v)) {\n      const keys = Object.keys(v);\n      keys.sort();\n      return keys.reduce((accum, key) => {\n        accum[key] = v[key];\n        return accum;\n      }, {});\n    }\n    return v;\n  });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */\nexport class UnmanagedSubscriber {\n  /**\n   *  Create a new UnmanagedSubscriber with %%name%%.\n   */\n  constructor(name) {\n    /**\n     *  The name fof the event.\n     */\n    _defineProperty(this, \"name\", void 0);\n    defineProperties(this, {\n      name\n    });\n  }\n  start() {}\n  stop() {}\n  pause(dropWhilePaused) {}\n  resume() {}\n}\nfunction copy(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n  items = Array.from(new Set(items).values());\n  items.sort();\n  return items;\n}\nasync function getSubscription(_event, provider) {\n  if (_event == null) {\n    throw new Error(\"invalid event\");\n  }\n  // Normalize topic array info an EventFilter\n  if (Array.isArray(_event)) {\n    _event = {\n      topics: _event\n    };\n  }\n  if (typeof _event === \"string\") {\n    switch (_event) {\n      case \"block\":\n      case \"debug\":\n      case \"error\":\n      case \"finalized\":\n      case \"network\":\n      case \"pending\":\n      case \"safe\":\n        {\n          return {\n            type: _event,\n            tag: _event\n          };\n        }\n    }\n  }\n  if (isHexString(_event, 32)) {\n    const hash = _event.toLowerCase();\n    return {\n      type: \"transaction\",\n      tag: getTag(\"tx\", {\n        hash\n      }),\n      hash\n    };\n  }\n  if (_event.orphan) {\n    const event = _event;\n    // @TODO: Should lowercase and whatnot things here instead of copy...\n    return {\n      type: \"orphan\",\n      tag: getTag(\"orphan\", event),\n      filter: copy(event)\n    };\n  }\n  if (_event.address || _event.topics) {\n    const event = _event;\n    const filter = {\n      topics: (event.topics || []).map(t => {\n        if (t == null) {\n          return null;\n        }\n        if (Array.isArray(t)) {\n          return concisify(t.map(t => t.toLowerCase()));\n        }\n        return t.toLowerCase();\n      })\n    };\n    if (event.address) {\n      const addresses = [];\n      const promises = [];\n      const addAddress = addr => {\n        if (isHexString(addr)) {\n          addresses.push(addr);\n        } else {\n          promises.push((async () => {\n            addresses.push(await resolveAddress(addr, provider));\n          })());\n        }\n      };\n      if (Array.isArray(event.address)) {\n        event.address.forEach(addAddress);\n      } else {\n        addAddress(event.address);\n      }\n      if (promises.length) {\n        await Promise.all(promises);\n      }\n      filter.address = concisify(addresses.map(a => a.toLowerCase()));\n    }\n    return {\n      filter,\n      tag: getTag(\"event\", filter),\n      type: \"event\"\n    };\n  }\n  assertArgument(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nconst defaultOptions = {\n  cacheTimeout: 250,\n  pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */\nvar _subs = /*#__PURE__*/new WeakMap();\nvar _plugins = /*#__PURE__*/new WeakMap();\nvar _pausedState = /*#__PURE__*/new WeakMap();\nvar _destroyed = /*#__PURE__*/new WeakMap();\nvar _networkPromise = /*#__PURE__*/new WeakMap();\nvar _anyNetwork = /*#__PURE__*/new WeakMap();\nvar _performCache = /*#__PURE__*/new WeakMap();\nvar _lastBlockNumber = /*#__PURE__*/new WeakMap();\nvar _nextTimer = /*#__PURE__*/new WeakMap();\nvar _timers = /*#__PURE__*/new WeakMap();\nvar _disableCcipRead = /*#__PURE__*/new WeakMap();\nvar _options = /*#__PURE__*/new WeakMap();\nvar _AbstractProvider_brand = /*#__PURE__*/new WeakSet();\nexport class AbstractProvider {\n  /**\n   *  Create a new **AbstractProvider** connected to %%network%%, or\n   *  use the various network detection capabilities to discover the\n   *  [[Network]] if necessary.\n   */\n  constructor(_network, options) {\n    // Shares multiple identical requests made during the same 250ms\n    _classPrivateMethodInitSpec(this, _AbstractProvider_brand);\n    _classPrivateFieldInitSpec(this, _subs, void 0);\n    _classPrivateFieldInitSpec(this, _plugins, void 0);\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    _classPrivateFieldInitSpec(this, _pausedState, void 0);\n    _classPrivateFieldInitSpec(this, _destroyed, void 0);\n    _classPrivateFieldInitSpec(this, _networkPromise, void 0);\n    _classPrivateFieldInitSpec(this, _anyNetwork, void 0);\n    _classPrivateFieldInitSpec(this, _performCache, void 0);\n    // The most recent block number if running an event or -1 if no \"block\" event\n    _classPrivateFieldInitSpec(this, _lastBlockNumber, void 0);\n    _classPrivateFieldInitSpec(this, _nextTimer, void 0);\n    _classPrivateFieldInitSpec(this, _timers, void 0);\n    _classPrivateFieldInitSpec(this, _disableCcipRead, void 0);\n    _classPrivateFieldInitSpec(this, _options, void 0);\n    _classPrivateFieldSet(_options, this, Object.assign({}, defaultOptions, options || {}));\n    if (_network === \"any\") {\n      _classPrivateFieldSet(_anyNetwork, this, true);\n      _classPrivateFieldSet(_networkPromise, this, null);\n    } else if (_network) {\n      const network = Network.from(_network);\n      _classPrivateFieldSet(_anyNetwork, this, false);\n      _classPrivateFieldSet(_networkPromise, this, Promise.resolve(network));\n      setTimeout(() => {\n        this.emit(\"network\", network, null);\n      }, 0);\n    } else {\n      _classPrivateFieldSet(_anyNetwork, this, false);\n      _classPrivateFieldSet(_networkPromise, this, null);\n    }\n    _classPrivateFieldSet(_lastBlockNumber, this, -1);\n    _classPrivateFieldSet(_performCache, this, new Map());\n    _classPrivateFieldSet(_subs, this, new Map());\n    _classPrivateFieldSet(_plugins, this, new Map());\n    _classPrivateFieldSet(_pausedState, this, null);\n    _classPrivateFieldSet(_destroyed, this, false);\n    _classPrivateFieldSet(_nextTimer, this, 1);\n    _classPrivateFieldSet(_timers, this, new Map());\n    _classPrivateFieldSet(_disableCcipRead, this, false);\n  }\n  get pollingInterval() {\n    return _classPrivateFieldGet(_options, this).pollingInterval;\n  }\n  /**\n   *  Returns ``this``, to allow an **AbstractProvider** to implement\n   *  the [[ContractRunner]] interface.\n   */\n  get provider() {\n    return this;\n  }\n  /**\n   *  Returns all the registered plug-ins.\n   */\n  get plugins() {\n    return Array.from(_classPrivateFieldGet(_plugins, this).values());\n  }\n  /**\n   *  Attach a new plug-in.\n   */\n  attachPlugin(plugin) {\n    if (_classPrivateFieldGet(_plugins, this).get(plugin.name)) {\n      throw new Error(\"cannot replace existing plugin: \".concat(plugin.name, \" \"));\n    }\n    _classPrivateFieldGet(_plugins, this).set(plugin.name, plugin.connect(this));\n    return this;\n  }\n  /**\n   *  Get a plugin by name.\n   */\n  getPlugin(name) {\n    return _classPrivateFieldGet(_plugins, this).get(name) || null;\n  }\n  /**\n   *  Prevent any CCIP-read operation, regardless of whether requested\n   *  in a [[call]] using ``enableCcipRead``.\n   */\n  get disableCcipRead() {\n    return _classPrivateFieldGet(_disableCcipRead, this);\n  }\n  set disableCcipRead(value) {\n    _classPrivateFieldSet(_disableCcipRead, this, !!value);\n  }\n  /**\n   *  Resolves to the data for executing the CCIP-read operations.\n   */\n  async ccipReadFetch(tx, calldata, urls) {\n    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n      return null;\n    }\n    const sender = tx.to.toLowerCase();\n    const data = calldata.toLowerCase();\n    const errorMessages = [];\n    for (let i = 0; i < urls.length; i++) {\n      const url = urls[i];\n      // URL expansion\n      const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n      // If no {data} is present, use POST; otherwise GET\n      //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n      //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n      //    value.status = response.statusCode;\n      //    return value;\n      //});\n      const request = new FetchRequest(href);\n      if (url.indexOf(\"{data}\") === -1) {\n        request.body = {\n          data,\n          sender\n        };\n      }\n      this.emit(\"debug\", {\n        action: \"sendCcipReadFetchRequest\",\n        request,\n        index: i,\n        urls\n      });\n      let errorMessage = \"unknown error\";\n      const resp = await request.send();\n      try {\n        const result = resp.bodyJson;\n        if (result.data) {\n          this.emit(\"debug\", {\n            action: \"receiveCcipReadFetchResult\",\n            request,\n            result\n          });\n          return result.data;\n        }\n        if (result.message) {\n          errorMessage = result.message;\n        }\n        this.emit(\"debug\", {\n          action: \"receiveCcipReadFetchError\",\n          request,\n          result\n        });\n      } catch (error) {}\n      // 4xx indicates the result is not present; stop\n      assert(resp.statusCode < 400 || resp.statusCode >= 500, \"response not found during CCIP fetch: \".concat(errorMessage), \"OFFCHAIN_FAULT\", {\n        reason: \"404_MISSING_RESOURCE\",\n        transaction: tx,\n        info: {\n          url,\n          errorMessage\n        }\n      });\n      // 5xx indicates server issue; try the next url\n      errorMessages.push(errorMessage);\n    }\n    assert(false, \"error encountered during CCIP fetch: \".concat(errorMessages.map(m => JSON.stringify(m)).join(\", \")), \"OFFCHAIN_FAULT\", {\n      reason: \"500_SERVER_ERROR\",\n      transaction: tx,\n      info: {\n        urls,\n        errorMessages\n      }\n    });\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a block before\n   *  returning it, to add additional properties or an alternate\n   *  sub-class of [[Block]].\n   */\n  _wrapBlock(value, network) {\n    return new Block(formatBlock(value), this);\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a log before\n   *  returning it, to add additional properties or an alternate\n   *  sub-class of [[Log]].\n   */\n  _wrapLog(value, network) {\n    return new Log(formatLog(value), this);\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a transaction\n   *  receipt before returning it, to add additional properties or an\n   *  alternate sub-class of [[TransactionReceipt]].\n   */\n  _wrapTransactionReceipt(value, network) {\n    return new TransactionReceipt(formatTransactionReceipt(value), this);\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a transaction\n   *  response before returning it, to add additional properties or an\n   *  alternate sub-class of [[TransactionResponse]].\n   */\n  _wrapTransactionResponse(tx, network) {\n    return new TransactionResponse(formatTransactionResponse(tx), this);\n  }\n  /**\n   *  Resolves to the Network, forcing a network detection using whatever\n   *  technique the sub-class requires.\n   *\n   *  Sub-classes **must** override this.\n   */\n  _detectNetwork() {\n    assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"_detectNetwork\"\n    });\n  }\n  /**\n   *  Sub-classes should use this to perform all built-in operations. All\n   *  methods sanitizes and normalizes the values passed into this.\n   *\n   *  Sub-classes **must** override this.\n   */\n  async _perform(req) {\n    assert(false, \"unsupported method: \".concat(req.method), \"UNSUPPORTED_OPERATION\", {\n      operation: req.method,\n      info: req\n    });\n  }\n  // State\n  async getBlockNumber() {\n    const blockNumber = getNumber(await _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {\n      method: \"getBlockNumber\"\n    }), \"%response\");\n    if (_classPrivateFieldGet(_lastBlockNumber, this) >= 0) {\n      _classPrivateFieldSet(_lastBlockNumber, this, blockNumber);\n    }\n    return blockNumber;\n  }\n  /**\n   *  Returns or resolves to the address for %%address%%, resolving ENS\n   *  names and [[Addressable]] objects and returning if already an\n   *  address.\n   */\n  _getAddress(address) {\n    return resolveAddress(address, this);\n  }\n  /**\n   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n   *  negative values and returning if already a valid block tag.\n   */\n  _getBlockTag(blockTag) {\n    if (blockTag == null) {\n      return \"latest\";\n    }\n    switch (blockTag) {\n      case \"earliest\":\n        return \"0x0\";\n      case \"finalized\":\n      case \"latest\":\n      case \"pending\":\n      case \"safe\":\n        return blockTag;\n    }\n    if (isHexString(blockTag)) {\n      if (isHexString(blockTag, 32)) {\n        return blockTag;\n      }\n      return toQuantity(blockTag);\n    }\n    if (typeof blockTag === \"bigint\") {\n      blockTag = getNumber(blockTag, \"blockTag\");\n    }\n    if (typeof blockTag === \"number\") {\n      if (blockTag >= 0) {\n        return toQuantity(blockTag);\n      }\n      if (_classPrivateFieldGet(_lastBlockNumber, this) >= 0) {\n        return toQuantity(_classPrivateFieldGet(_lastBlockNumber, this) + blockTag);\n      }\n      return this.getBlockNumber().then(b => toQuantity(b + blockTag));\n    }\n    assertArgument(false, \"invalid blockTag\", \"blockTag\", blockTag);\n  }\n  /**\n   *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n   *  names or [[Addressable]] object and returning if already a valid\n   *  filter.\n   */\n  _getFilter(filter) {\n    // Create a canonical representation of the topics\n    const topics = (filter.topics || []).map(t => {\n      if (t == null) {\n        return null;\n      }\n      if (Array.isArray(t)) {\n        return concisify(t.map(t => t.toLowerCase()));\n      }\n      return t.toLowerCase();\n    });\n    const blockHash = \"blockHash\" in filter ? filter.blockHash : undefined;\n    const resolve = (_address, fromBlock, toBlock) => {\n      let address = undefined;\n      switch (_address.length) {\n        case 0:\n          break;\n        case 1:\n          address = _address[0];\n          break;\n        default:\n          _address.sort();\n          address = _address;\n      }\n      if (blockHash) {\n        if (fromBlock != null || toBlock != null) {\n          throw new Error(\"invalid filter\");\n        }\n      }\n      const filter = {};\n      if (address) {\n        filter.address = address;\n      }\n      if (topics.length) {\n        filter.topics = topics;\n      }\n      if (fromBlock) {\n        filter.fromBlock = fromBlock;\n      }\n      if (toBlock) {\n        filter.toBlock = toBlock;\n      }\n      if (blockHash) {\n        filter.blockHash = blockHash;\n      }\n      return filter;\n    };\n    // Addresses could be async (ENS names or Addressables)\n    let address = [];\n    if (filter.address) {\n      if (Array.isArray(filter.address)) {\n        for (const addr of filter.address) {\n          address.push(this._getAddress(addr));\n        }\n      } else {\n        address.push(this._getAddress(filter.address));\n      }\n    }\n    let fromBlock = undefined;\n    if (\"fromBlock\" in filter) {\n      fromBlock = this._getBlockTag(filter.fromBlock);\n    }\n    let toBlock = undefined;\n    if (\"toBlock\" in filter) {\n      toBlock = this._getBlockTag(filter.toBlock);\n    }\n    if (address.filter(a => typeof a !== \"string\").length || fromBlock != null && typeof fromBlock !== \"string\" || toBlock != null && typeof toBlock !== \"string\") {\n      return Promise.all([Promise.all(address), fromBlock, toBlock]).then(result => {\n        return resolve(result[0], result[1], result[2]);\n      });\n    }\n    return resolve(address, fromBlock, toBlock);\n  }\n  /**\n   *  Returns or resolves to a transaction for %%request%%, resolving\n   *  any ENS names or [[Addressable]] and returning if already a valid\n   *  transaction.\n   */\n  _getTransactionRequest(_request) {\n    const request = copyRequest(_request);\n    const promises = [];\n    [\"to\", \"from\"].forEach(key => {\n      if (request[key] == null) {\n        return;\n      }\n      const addr = resolveAddress(request[key], this);\n      if (isPromise(addr)) {\n        promises.push(async function () {\n          request[key] = await addr;\n        }());\n      } else {\n        request[key] = addr;\n      }\n    });\n    if (request.blockTag != null) {\n      const blockTag = this._getBlockTag(request.blockTag);\n      if (isPromise(blockTag)) {\n        promises.push(async function () {\n          request.blockTag = await blockTag;\n        }());\n      } else {\n        request.blockTag = blockTag;\n      }\n    }\n    if (promises.length) {\n      return async function () {\n        await Promise.all(promises);\n        return request;\n      }();\n    }\n    return request;\n  }\n  async getNetwork() {\n    // No explicit network was set and this is our first time\n    if (_classPrivateFieldGet(_networkPromise, this) == null) {\n      // Detect the current network (shared with all calls)\n      const detectNetwork = (async () => {\n        try {\n          const network = await this._detectNetwork();\n          this.emit(\"network\", network, null);\n          return network;\n        } catch (error) {\n          if (_classPrivateFieldGet(_networkPromise, this) === detectNetwork) {\n            _classPrivateFieldSet(_networkPromise, this, null);\n          }\n          throw error;\n        }\n      })();\n      _classPrivateFieldSet(_networkPromise, this, detectNetwork);\n      return (await detectNetwork).clone();\n    }\n    const networkPromise = _classPrivateFieldGet(_networkPromise, this);\n    const [expected, actual] = await Promise.all([networkPromise, this._detectNetwork() // The actual connected network\n    ]);\n    if (expected.chainId !== actual.chainId) {\n      if (_classPrivateFieldGet(_anyNetwork, this)) {\n        // The \"any\" network can change, so notify listeners\n        this.emit(\"network\", actual, expected);\n        // Update the network if something else hasn't already changed it\n        if (_classPrivateFieldGet(_networkPromise, this) === networkPromise) {\n          _classPrivateFieldSet(_networkPromise, this, Promise.resolve(actual));\n        }\n      } else {\n        // Otherwise, we do not allow changes to the underlying network\n        assert(false, \"network changed: \".concat(expected.chainId, \" => \").concat(actual.chainId, \" \"), \"NETWORK_ERROR\", {\n          event: \"changed\"\n        });\n      }\n    }\n    return expected.clone();\n  }\n  async getFeeData() {\n    const network = await this.getNetwork();\n    const getFeeDataFunc = async () => {\n      const {\n        _block,\n        gasPrice,\n        priorityFee\n      } = await resolveProperties({\n        _block: _assertClassBrand(_AbstractProvider_brand, this, _getBlock).call(this, \"latest\", false),\n        gasPrice: (async () => {\n          try {\n            const value = await _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {\n              method: \"getGasPrice\"\n            });\n            return getBigInt(value, \"%response\");\n          } catch (error) {}\n          return null;\n        })(),\n        priorityFee: (async () => {\n          try {\n            const value = await _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {\n              method: \"getPriorityFee\"\n            });\n            return getBigInt(value, \"%response\");\n          } catch (error) {}\n          return null;\n        })()\n      });\n      let maxFeePerGas = null;\n      let maxPriorityFeePerGas = null;\n      // These are the recommended EIP-1559 heuristics for fee data\n      const block = this._wrapBlock(_block, network);\n      if (block && block.baseFeePerGas) {\n        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt(\"1000000000\");\n        maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;\n      }\n      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n    };\n    // Check for a FeeDataNetWorkPlugin\n    const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n    if (plugin) {\n      const req = new FetchRequest(plugin.url);\n      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n    }\n    return await getFeeDataFunc();\n  }\n  async estimateGas(_tx) {\n    let tx = this._getTransactionRequest(_tx);\n    if (isPromise(tx)) {\n      tx = await tx;\n    }\n    return getBigInt(await _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {\n      method: \"estimateGas\",\n      transaction: tx\n    }), \"%response\");\n  }\n  async call(_tx) {\n    const {\n      tx,\n      blockTag\n    } = await resolveProperties({\n      tx: this._getTransactionRequest(_tx),\n      blockTag: this._getBlockTag(_tx.blockTag)\n    });\n    return await _assertClassBrand(_AbstractProvider_brand, this, _checkNetwork).call(this, _assertClassBrand(_AbstractProvider_brand, this, _call).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n  }\n  // Account\n\n  async getBalance(address, blockTag) {\n    return getBigInt(await _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {\n      method: \"getBalance\"\n    }, address, blockTag), \"%response\");\n  }\n  async getTransactionCount(address, blockTag) {\n    return getNumber(await _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {\n      method: \"getTransactionCount\"\n    }, address, blockTag), \"%response\");\n  }\n  async getCode(address, blockTag) {\n    return hexlify(await _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {\n      method: \"getCode\"\n    }, address, blockTag));\n  }\n  async getStorage(address, _position, blockTag) {\n    const position = getBigInt(_position, \"position\");\n    return hexlify(await _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {\n      method: \"getStorage\",\n      position\n    }, address, blockTag));\n  }\n  // Write\n  async broadcastTransaction(signedTx) {\n    const {\n      blockNumber,\n      hash,\n      network\n    } = await resolveProperties({\n      blockNumber: this.getBlockNumber(),\n      hash: this._perform({\n        method: \"broadcastTransaction\",\n        signedTransaction: signedTx\n      }),\n      network: this.getNetwork()\n    });\n    const tx = Transaction.from(signedTx);\n    if (tx.hash !== hash) {\n      throw new Error(\"@TODO: the returned hash did not match\");\n    }\n    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n  }\n  // Queries\n  async getBlock(block, prefetchTxs) {\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: _assertClassBrand(_AbstractProvider_brand, this, _getBlock).call(this, block, !!prefetchTxs)\n    });\n    if (params == null) {\n      return null;\n    }\n    return this._wrapBlock(params, network);\n  }\n  async getTransaction(hash) {\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {\n        method: \"getTransaction\",\n        hash\n      })\n    });\n    if (params == null) {\n      return null;\n    }\n    return this._wrapTransactionResponse(params, network);\n  }\n  async getTransactionReceipt(hash) {\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {\n        method: \"getTransactionReceipt\",\n        hash\n      })\n    });\n    if (params == null) {\n      return null;\n    }\n    // Some backends did not backfill the effectiveGasPrice into old transactions\n    // in the receipt, so we look it up manually and inject it.\n    if (params.gasPrice == null && params.effectiveGasPrice == null) {\n      const tx = await _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {\n        method: \"getTransaction\",\n        hash\n      });\n      if (tx == null) {\n        throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n      }\n      params.effectiveGasPrice = tx.gasPrice;\n    }\n    return this._wrapTransactionReceipt(params, network);\n  }\n  async getTransactionResult(hash) {\n    const {\n      result\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      result: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {\n        method: \"getTransactionResult\",\n        hash\n      })\n    });\n    if (result == null) {\n      return null;\n    }\n    return hexlify(result);\n  }\n  // Bloom-filter Queries\n  async getLogs(_filter) {\n    let filter = this._getFilter(_filter);\n    if (isPromise(filter)) {\n      filter = await filter;\n    }\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {\n        method: \"getLogs\",\n        filter\n      })\n    });\n    return params.map(p => this._wrapLog(p, network));\n  }\n  // ENS\n  _getProvider(chainId) {\n    assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"_getProvider()\"\n    });\n  }\n  async getResolver(name) {\n    return await EnsResolver.fromName(this, name);\n  }\n  async getAvatar(name) {\n    const resolver = await this.getResolver(name);\n    if (resolver) {\n      return await resolver.getAvatar();\n    }\n    return null;\n  }\n  async resolveName(name) {\n    const resolver = await this.getResolver(name);\n    if (resolver) {\n      return await resolver.getAddress();\n    }\n    return null;\n  }\n  async lookupAddress(address) {\n    address = getAddress(address);\n    const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n    try {\n      const ensAddr = await EnsResolver.getEnsAddress(this);\n      const ensContract = new Contract(ensAddr, [\"function resolver(bytes32) view returns (address)\"], this);\n      const resolver = await ensContract.resolver(node);\n      if (resolver == null || resolver === ZeroAddress) {\n        return null;\n      }\n      const resolverContract = new Contract(resolver, [\"function name(bytes32) view returns (string)\"], this);\n      const name = await resolverContract.name(node);\n      // Failed forward resolution\n      const check = await this.resolveName(name);\n      if (check !== address) {\n        return null;\n      }\n      return name;\n    } catch (error) {\n      // No data was returned from the resolver\n      if (isError(error, \"BAD_DATA\") && error.value === \"0x\") {\n        return null;\n      }\n      // Something reerted\n      if (isError(error, \"CALL_EXCEPTION\")) {\n        return null;\n      }\n      throw error;\n    }\n    return null;\n  }\n  async waitForTransaction(hash, _confirms, timeout) {\n    const confirms = _confirms != null ? _confirms : 1;\n    if (confirms === 0) {\n      return this.getTransactionReceipt(hash);\n    }\n    return new Promise(async (resolve, reject) => {\n      let timer = null;\n      const listener = async blockNumber => {\n        try {\n          const receipt = await this.getTransactionReceipt(hash);\n          if (receipt != null) {\n            if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n              resolve(receipt);\n              //this.off(\"block\", listener);\n              if (timer) {\n                clearTimeout(timer);\n                timer = null;\n              }\n              return;\n            }\n          }\n        } catch (error) {\n          console.log(\"EEE\", error);\n        }\n        this.once(\"block\", listener);\n      };\n      if (timeout != null) {\n        timer = setTimeout(() => {\n          if (timer == null) {\n            return;\n          }\n          timer = null;\n          this.off(\"block\", listener);\n          reject(makeError(\"timeout\", \"TIMEOUT\", {\n            reason: \"timeout\"\n          }));\n        }, timeout);\n      }\n      listener(await this.getBlockNumber());\n    });\n  }\n  async waitForBlock(blockTag) {\n    assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n      operation: \"waitForBlock\"\n    });\n  }\n  /**\n   *  Clear a timer created using the [[_setTimeout]] method.\n   */\n  _clearTimeout(timerId) {\n    const timer = _classPrivateFieldGet(_timers, this).get(timerId);\n    if (!timer) {\n      return;\n    }\n    if (timer.timer) {\n      clearTimeout(timer.timer);\n    }\n    _classPrivateFieldGet(_timers, this).delete(timerId);\n  }\n  /**\n   *  Create a timer that will execute %%func%% after at least %%timeout%%\n   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n   *  in the next event loop.\n   *\n   *  [Pausing](AbstractProvider-paused) the provider will pause any\n   *  associated timers.\n   */\n  _setTimeout(_func, timeout) {\n    var _this$nextTimer, _this$nextTimer2;\n    if (timeout == null) {\n      timeout = 0;\n    }\n    const timerId = (_classPrivateFieldSet(_nextTimer, this, (_this$nextTimer = _classPrivateFieldGet(_nextTimer, this), _this$nextTimer2 = _this$nextTimer++, _this$nextTimer)), _this$nextTimer2);\n    const func = () => {\n      _classPrivateFieldGet(_timers, this).delete(timerId);\n      _func();\n    };\n    if (this.paused) {\n      _classPrivateFieldGet(_timers, this).set(timerId, {\n        timer: null,\n        func,\n        time: timeout\n      });\n    } else {\n      const timer = setTimeout(func, timeout);\n      _classPrivateFieldGet(_timers, this).set(timerId, {\n        timer,\n        func,\n        time: getTime()\n      });\n    }\n    return timerId;\n  }\n  /**\n   *  Perform %%func%% on each subscriber.\n   */\n  _forEachSubscriber(func) {\n    for (const sub of _classPrivateFieldGet(_subs, this).values()) {\n      func(sub.subscriber);\n    }\n  }\n  /**\n   *  Sub-classes may override this to customize subscription\n   *  implementations.\n   */\n  _getSubscriber(sub) {\n    switch (sub.type) {\n      case \"debug\":\n      case \"error\":\n      case \"network\":\n        return new UnmanagedSubscriber(sub.type);\n      case \"block\":\n        {\n          const subscriber = new PollingBlockSubscriber(this);\n          subscriber.pollingInterval = this.pollingInterval;\n          return subscriber;\n        }\n      case \"safe\":\n      case \"finalized\":\n        return new PollingBlockTagSubscriber(this, sub.type);\n      case \"event\":\n        return new PollingEventSubscriber(this, sub.filter);\n      case \"transaction\":\n        return new PollingTransactionSubscriber(this, sub.hash);\n      case \"orphan\":\n        return new PollingOrphanSubscriber(this, sub.filter);\n    }\n    throw new Error(\"unsupported event: \".concat(sub.type));\n  }\n  /**\n   *  If a [[Subscriber]] fails and needs to replace itself, this\n   *  method may be used.\n   *\n   *  For example, this is used for providers when using the\n   *  ``eth_getFilterChanges`` method, which can return null if state\n   *  filters are not supported by the backend, allowing the Subscriber\n   *  to swap in a [[PollingEventSubscriber]].\n   */\n  _recoverSubscriber(oldSub, newSub) {\n    for (const sub of _classPrivateFieldGet(_subs, this).values()) {\n      if (sub.subscriber === oldSub) {\n        if (sub.started) {\n          sub.subscriber.stop();\n        }\n        sub.subscriber = newSub;\n        if (sub.started) {\n          newSub.start();\n        }\n        if (_classPrivateFieldGet(_pausedState, this) != null) {\n          newSub.pause(_classPrivateFieldGet(_pausedState, this));\n        }\n        break;\n      }\n    }\n  }\n  async on(event, listener) {\n    const sub = await _assertClassBrand(_AbstractProvider_brand, this, _getSub).call(this, event);\n    sub.listeners.push({\n      listener,\n      once: false\n    });\n    if (!sub.started) {\n      sub.subscriber.start();\n      sub.started = true;\n      if (_classPrivateFieldGet(_pausedState, this) != null) {\n        sub.subscriber.pause(_classPrivateFieldGet(_pausedState, this));\n      }\n    }\n    return this;\n  }\n  async once(event, listener) {\n    const sub = await _assertClassBrand(_AbstractProvider_brand, this, _getSub).call(this, event);\n    sub.listeners.push({\n      listener,\n      once: true\n    });\n    if (!sub.started) {\n      sub.subscriber.start();\n      sub.started = true;\n      if (_classPrivateFieldGet(_pausedState, this) != null) {\n        sub.subscriber.pause(_classPrivateFieldGet(_pausedState, this));\n      }\n    }\n    return this;\n  }\n  async emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    const sub = await _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event, args);\n    // If there is not subscription or if a recent emit removed\n    // the last of them (which also deleted the sub) do nothing\n    if (!sub || sub.listeners.length === 0) {\n      return false;\n    }\n    ;\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(_ref => {\n      let {\n        listener,\n        once\n      } = _ref;\n      const payload = new EventPayload(this, once ? null : listener, event);\n      try {\n        listener.call(this, ...args, payload);\n      } catch (error) {}\n      return !once;\n    });\n    if (sub.listeners.length === 0) {\n      if (sub.started) {\n        sub.subscriber.stop();\n      }\n      _classPrivateFieldGet(_subs, this).delete(sub.tag);\n    }\n    return count > 0;\n  }\n  async listenerCount(event) {\n    if (event) {\n      const sub = await _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event);\n      if (!sub) {\n        return 0;\n      }\n      return sub.listeners.length;\n    }\n    let total = 0;\n    for (const {\n      listeners\n    } of _classPrivateFieldGet(_subs, this).values()) {\n      total += listeners.length;\n    }\n    return total;\n  }\n  async listeners(event) {\n    if (event) {\n      const sub = await _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event);\n      if (!sub) {\n        return [];\n      }\n      return sub.listeners.map(_ref2 => {\n        let {\n          listener\n        } = _ref2;\n        return listener;\n      });\n    }\n    let result = [];\n    for (const {\n      listeners\n    } of _classPrivateFieldGet(_subs, this).values()) {\n      result = result.concat(listeners.map(_ref3 => {\n        let {\n          listener\n        } = _ref3;\n        return listener;\n      }));\n    }\n    return result;\n  }\n  async off(event, listener) {\n    const sub = await _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event);\n    if (!sub) {\n      return this;\n    }\n    if (listener) {\n      const index = sub.listeners.map(_ref4 => {\n        let {\n          listener\n        } = _ref4;\n        return listener;\n      }).indexOf(listener);\n      if (index >= 0) {\n        sub.listeners.splice(index, 1);\n      }\n    }\n    if (!listener || sub.listeners.length === 0) {\n      if (sub.started) {\n        sub.subscriber.stop();\n      }\n      _classPrivateFieldGet(_subs, this).delete(sub.tag);\n    }\n    return this;\n  }\n  async removeAllListeners(event) {\n    if (event) {\n      const {\n        tag,\n        started,\n        subscriber\n      } = await _assertClassBrand(_AbstractProvider_brand, this, _getSub).call(this, event);\n      if (started) {\n        subscriber.stop();\n      }\n      _classPrivateFieldGet(_subs, this).delete(tag);\n    } else {\n      for (const [tag, {\n        started,\n        subscriber\n      }] of _classPrivateFieldGet(_subs, this)) {\n        if (started) {\n          subscriber.stop();\n        }\n        _classPrivateFieldGet(_subs, this).delete(tag);\n      }\n    }\n    return this;\n  }\n  // Alias for \"on\"\n  async addListener(event, listener) {\n    return await this.on(event, listener);\n  }\n  // Alias for \"off\"\n  async removeListener(event, listener) {\n    return this.off(event, listener);\n  }\n  /**\n   *  If this provider has been destroyed using the [[destroy]] method.\n   *\n   *  Once destroyed, all resources are reclaimed, internal event loops\n   *  and timers are cleaned up and no further requests may be sent to\n   *  the provider.\n   */\n  get destroyed() {\n    return _classPrivateFieldGet(_destroyed, this);\n  }\n  /**\n   *  Sub-classes may use this to shutdown any sockets or release their\n   *  resources and reject any pending requests.\n   *\n   *  Sub-classes **must** call ``super.destroy()``.\n   */\n  destroy() {\n    // Stop all listeners\n    this.removeAllListeners();\n    // Shut down all tiemrs\n    for (const timerId of _classPrivateFieldGet(_timers, this).keys()) {\n      this._clearTimeout(timerId);\n    }\n    _classPrivateFieldSet(_destroyed, this, true);\n  }\n  /**\n   *  Whether the provider is currently paused.\n   *\n   *  A paused provider will not emit any events, and generally should\n   *  not make any requests to the network, but that is up to sub-classes\n   *  to manage.\n   *\n   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n   *  which will buffer any events that occur while paused until the\n   *  provider is unpaused.\n   */\n  get paused() {\n    return _classPrivateFieldGet(_pausedState, this) != null;\n  }\n  set paused(pause) {\n    if (!!pause === this.paused) {\n      return;\n    }\n    if (this.paused) {\n      this.resume();\n    } else {\n      this.pause(false);\n    }\n  }\n  /**\n   *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n   *  while paused are dropped, otherwise all events will be emitted once\n   *  the provider is unpaused.\n   */\n  pause(dropWhilePaused) {\n    _classPrivateFieldSet(_lastBlockNumber, this, -1);\n    if (_classPrivateFieldGet(_pausedState, this) != null) {\n      if (_classPrivateFieldGet(_pausedState, this) == !!dropWhilePaused) {\n        return;\n      }\n      assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"pause\"\n      });\n    }\n    this._forEachSubscriber(s => s.pause(dropWhilePaused));\n    _classPrivateFieldSet(_pausedState, this, !!dropWhilePaused);\n    for (const timer of _classPrivateFieldGet(_timers, this).values()) {\n      // Clear the timer\n      if (timer.timer) {\n        clearTimeout(timer.timer);\n      }\n      // Remaining time needed for when we become unpaused\n      timer.time = getTime() - timer.time;\n    }\n  }\n  /**\n   *  Resume the provider.\n   */\n  resume() {\n    if (_classPrivateFieldGet(_pausedState, this) == null) {\n      return;\n    }\n    this._forEachSubscriber(s => s.resume());\n    _classPrivateFieldSet(_pausedState, this, null);\n    for (const timer of _classPrivateFieldGet(_timers, this).values()) {\n      // Remaining time when we were paused\n      let timeout = timer.time;\n      if (timeout < 0) {\n        timeout = 0;\n      }\n      // Start time (in cause paused, so we con compute remaininf time)\n      timer.time = getTime();\n      // Start the timer\n      setTimeout(timer.func, timeout);\n    }\n  }\n}\nasync function _perform(req) {\n  const timeout = _classPrivateFieldGet(_options, this).cacheTimeout;\n  // Caching disabled\n  if (timeout < 0) {\n    return await this._perform(req);\n  }\n  // Create a tag\n  const tag = getTag(req.method, req);\n  let perform = _classPrivateFieldGet(_performCache, this).get(tag);\n  if (!perform) {\n    perform = this._perform(req);\n    _classPrivateFieldGet(_performCache, this).set(tag, perform);\n    setTimeout(() => {\n      if (_classPrivateFieldGet(_performCache, this).get(tag) === perform) {\n        _classPrivateFieldGet(_performCache, this).delete(tag);\n      }\n    }, timeout);\n  }\n  return await perform;\n}\nasync function _call(tx, blockTag, attempt) {\n  assert(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n    reason: \"TOO_MANY_REDIRECTS\",\n    transaction: Object.assign({}, tx, {\n      blockTag,\n      enableCcipRead: true\n    })\n  });\n  // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n  const transaction = copyRequest(tx);\n  try {\n    return hexlify(await this._perform({\n      method: \"call\",\n      transaction,\n      blockTag\n    }));\n  } catch (error) {\n    // CCIP Read OffchainLookup\n    if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && dataSlice(error.data, 0, 4) === \"0x556f1830\") {\n      const data = error.data;\n      const txSender = await resolveAddress(transaction.to, this);\n      // Parse the CCIP Read Arguments\n      let ccipArgs;\n      try {\n        ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));\n      } catch (error) {\n        assert(false, error.message, \"OFFCHAIN_FAULT\", {\n          reason: \"BAD_DATA\",\n          transaction,\n          info: {\n            data\n          }\n        });\n      }\n      // Check the sender of the OffchainLookup matches the transaction\n      assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n        action: \"call\",\n        data,\n        reason: \"OffchainLookup\",\n        transaction: transaction,\n        invocation: null,\n        revert: {\n          signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n          name: \"OffchainLookup\",\n          args: ccipArgs.errorArgs\n        }\n      });\n      const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n      assert(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n        reason: \"FETCH_FAILED\",\n        transaction,\n        info: {\n          data: error.data,\n          errorArgs: ccipArgs.errorArgs\n        }\n      });\n      const tx = {\n        to: txSender,\n        data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])\n      };\n      this.emit(\"debug\", {\n        action: \"sendCcipReadCall\",\n        transaction: tx\n      });\n      try {\n        const result = await _assertClassBrand(_AbstractProvider_brand, this, _call).call(this, tx, blockTag, attempt + 1);\n        this.emit(\"debug\", {\n          action: \"receiveCcipReadCallResult\",\n          transaction: Object.assign({}, tx),\n          result\n        });\n        return result;\n      } catch (error) {\n        this.emit(\"debug\", {\n          action: \"receiveCcipReadCallError\",\n          transaction: Object.assign({}, tx),\n          error\n        });\n        throw error;\n      }\n    }\n    throw error;\n  }\n}\nasync function _checkNetwork(promise) {\n  const {\n    value\n  } = await resolveProperties({\n    network: this.getNetwork(),\n    value: promise\n  });\n  return value;\n}\nasync function _getAccountValue(request, _address, _blockTag) {\n  let address = this._getAddress(_address);\n  let blockTag = this._getBlockTag(_blockTag);\n  if (typeof address !== \"string\" || typeof blockTag !== \"string\") {\n    [address, blockTag] = await Promise.all([address, blockTag]);\n  }\n  return await _assertClassBrand(_AbstractProvider_brand, this, _checkNetwork).call(this, _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, Object.assign(request, {\n    address,\n    blockTag\n  })));\n}\nasync function _getBlock(block, includeTransactions) {\n  // @TODO: Add CustomBlockPlugin check\n  if (isHexString(block, 32)) {\n    return await _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {\n      method: \"getBlock\",\n      blockHash: block,\n      includeTransactions\n    });\n  }\n  let blockTag = this._getBlockTag(block);\n  if (typeof blockTag !== \"string\") {\n    blockTag = await blockTag;\n  }\n  return await _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {\n    method: \"getBlock\",\n    blockTag,\n    includeTransactions\n  });\n}\nasync function _hasSub(event, emitArgs) {\n  let sub = await getSubscription(event, this);\n  // This is a log that is removing an existing log; we actually want\n  // to emit an orphan event for the removed log\n  if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n    sub = await getSubscription({\n      orphan: \"drop-log\",\n      log: emitArgs[0]\n    }, this);\n  }\n  return _classPrivateFieldGet(_subs, this).get(sub.tag) || null;\n}\nasync function _getSub(event) {\n  const subscription = await getSubscription(event, this);\n  // Prevent tampering with our tag in any subclass' _getSubscriber\n  const tag = subscription.tag;\n  let sub = _classPrivateFieldGet(_subs, this).get(tag);\n  if (!sub) {\n    const subscriber = this._getSubscriber(subscription);\n    const addressableMap = new WeakMap();\n    const nameMap = new Map();\n    sub = {\n      subscriber,\n      tag,\n      addressableMap,\n      nameMap,\n      started: false,\n      listeners: []\n    };\n    _classPrivateFieldGet(_subs, this).set(tag, sub);\n  }\n  return sub;\n}\nfunction _parseString(result, start) {\n  try {\n    const bytes = _parseBytes(result, start);\n    if (bytes) {\n      return toUtf8String(bytes);\n    }\n  } catch (error) {}\n  return null;\n}\nfunction _parseBytes(result, start) {\n  if (result === \"0x\") {\n    return null;\n  }\n  try {\n    const offset = getNumber(dataSlice(result, start, start + 32));\n    const length = getNumber(dataSlice(result, offset, offset + 32));\n    return dataSlice(result, offset + 32, offset + 32 + length);\n  } catch (error) {}\n  return null;\n}\nfunction numPad(value) {\n  const result = toBeArray(value);\n  if (result.length > 32) {\n    throw new Error(\"internal; should not happen\");\n  }\n  const padded = new Uint8Array(32);\n  padded.set(result, 32 - result.length);\n  return padded;\n}\nfunction bytesPad(value) {\n  if (value.length % 32 === 0) {\n    return value;\n  }\n  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n  result.set(value);\n  return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n  const result = [];\n  let byteCount = 0;\n  // Add place-holders for pointers as we add items\n  for (let i = 0; i < datas.length; i++) {\n    result.push(empty);\n    byteCount += 32;\n  }\n  for (let i = 0; i < datas.length; i++) {\n    const data = getBytes(datas[i]);\n    // Update the bytes offset\n    result[i] = numPad(byteCount);\n    // The length and padded value of data\n    result.push(numPad(data.length));\n    result.push(bytesPad(data));\n    byteCount += 32 + Math.ceil(data.length / 32) * 32;\n  }\n  return concat(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n  const result = {\n    sender: \"\",\n    urls: [],\n    calldata: \"\",\n    selector: \"\",\n    extraData: \"\",\n    errorArgs: []\n  };\n  assert(dataLength(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n    reason: \"insufficient OffchainLookup data\"\n  });\n  const sender = dataSlice(data, 0, 32);\n  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n    reason: \"corrupt OffchainLookup sender\"\n  });\n  result.sender = dataSlice(sender, 12);\n  // Read the URLs from the response\n  try {\n    const urls = [];\n    const urlsOffset = getNumber(dataSlice(data, 32, 64));\n    const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));\n    const urlsData = dataSlice(data, urlsOffset + 32);\n    for (let u = 0; u < urlsLength; u++) {\n      const url = _parseString(urlsData, u * 32);\n      if (url == null) {\n        throw new Error(\"abort\");\n      }\n      urls.push(url);\n    }\n    result.urls = urls;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup urls\"\n    });\n  }\n  // Get the CCIP calldata to forward\n  try {\n    const calldata = _parseBytes(data, 64);\n    if (calldata == null) {\n      throw new Error(\"abort\");\n    }\n    result.calldata = calldata;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup calldata\"\n    });\n  }\n  // Get the callbackSelector (bytes4)\n  assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n    reason: \"corrupt OffchainLookup callbaackSelector\"\n  });\n  result.selector = dataSlice(data, 96, 100);\n  // Get the extra data to send back to the contract as context\n  try {\n    const extraData = _parseBytes(data, 128);\n    if (extraData == null) {\n      throw new Error(\"abort\");\n    }\n    result.extraData = extraData;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup extraData\"\n    });\n  }\n  result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map(k => result[k]);\n  return result;\n}","map":{"version":3,"names":["getAddress","resolveAddress","ZeroAddress","Contract","namehash","Transaction","concat","dataLength","dataSlice","hexlify","isHexString","getBigInt","getBytes","getNumber","isCallException","isError","makeError","assert","assertArgument","FetchRequest","toBeArray","toQuantity","defineProperties","EventPayload","resolveProperties","toUtf8String","EnsResolver","formatBlock","formatLog","formatTransactionReceipt","formatTransactionResponse","Network","copyRequest","Block","FeeData","Log","TransactionReceipt","TransactionResponse","PollingBlockSubscriber","PollingBlockTagSubscriber","PollingEventSubscriber","PollingOrphanSubscriber","PollingTransactionSubscriber","BN_2","BigInt","MAX_CCIP_REDIRECTS","isPromise","value","then","getTag","prefix","JSON","stringify","k","v","toString","toLowerCase","Array","isArray","keys","Object","sort","reduce","accum","key","UnmanagedSubscriber","constructor","name","_defineProperty","start","stop","pause","dropWhilePaused","resume","copy","parse","concisify","items","from","Set","values","getSubscription","_event","provider","Error","topics","type","tag","hash","orphan","event","filter","address","map","t","addresses","promises","addAddress","addr","push","forEach","length","Promise","all","a","getTime","Date","defaultOptions","cacheTimeout","pollingInterval","_subs","WeakMap","_plugins","_pausedState","_destroyed","_networkPromise","_anyNetwork","_performCache","_lastBlockNumber","_nextTimer","_timers","_disableCcipRead","_options","_AbstractProvider_brand","WeakSet","AbstractProvider","_network","options","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateFieldSet","assign","network","resolve","setTimeout","emit","Map","_classPrivateFieldGet","plugins","attachPlugin","plugin","get","set","connect","getPlugin","disableCcipRead","ccipReadFetch","tx","calldata","urls","to","sender","data","errorMessages","i","url","href","replace","request","indexOf","body","action","index","errorMessage","resp","send","result","bodyJson","message","error","statusCode","reason","transaction","info","m","join","_wrapBlock","_wrapLog","_wrapTransactionReceipt","_wrapTransactionResponse","_detectNetwork","operation","_perform","req","method","getBlockNumber","blockNumber","_assertClassBrand","call","_getAddress","_getBlockTag","blockTag","b","_getFilter","blockHash","undefined","_address","fromBlock","toBlock","_getTransactionRequest","_request","getNetwork","detectNetwork","clone","networkPromise","expected","actual","chainId","getFeeData","getFeeDataFunc","_block","gasPrice","priorityFee","_getBlock","maxFeePerGas","maxPriorityFeePerGas","block","baseFeePerGas","feeData","processFunc","estimateGas","_tx","_checkNetwork","_call","enableCcipRead","getBalance","_getAccountValue","getTransactionCount","getCode","getStorage","_position","position","broadcastTransaction","signedTx","signedTransaction","replaceableTransaction","getBlock","prefetchTxs","params","getTransaction","getTransactionReceipt","effectiveGasPrice","getTransactionResult","getLogs","_filter","p","_getProvider","getResolver","fromName","getAvatar","resolver","resolveName","lookupAddress","node","substring","ensAddr","getEnsAddress","ensContract","resolverContract","check","waitForTransaction","_confirms","timeout","confirms","reject","timer","listener","receipt","clearTimeout","console","log","once","off","waitForBlock","_clearTimeout","timerId","delete","_setTimeout","_func","_this$nextTimer","_this$nextTimer2","func","paused","time","_forEachSubscriber","sub","subscriber","_getSubscriber","_recoverSubscriber","oldSub","newSub","started","on","_getSub","listeners","_len","arguments","args","_key","_hasSub","count","_ref","payload","listenerCount","total","_ref2","_ref3","_ref4","splice","removeAllListeners","addListener","removeListener","destroyed","destroy","s","perform","attempt","txSender","ccipArgs","parseOffchainLookup","invocation","revert","signature","errorArgs","ccipResult","selector","encodeBytes","extraData","promise","_blockTag","includeTransactions","emitArgs","removed","subscription","addressableMap","nameMap","_parseString","bytes","_parseBytes","offset","numPad","padded","Uint8Array","bytesPad","Math","ceil","empty","datas","byteCount","zeros","urlsOffset","urlsLength","urlsData","u","split"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/ethers/src.ts/providers/abstract-provider.ts"],"sourcesContent":["/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\n\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { namehash } from \"../hash/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport {\n    concat, dataLength, dataSlice, hexlify, isHexString,\n    getBigInt, getBytes, getNumber,\n    isCallException, isError, makeError, assert, assertArgument,\n    FetchRequest,\n    toBeArray, toQuantity,\n    defineProperties, EventPayload, resolveProperties,\n    toUtf8String\n} from \"../utils/index.js\";\n\nimport { EnsResolver } from \"./ens-resolver.js\";\nimport {\n    formatBlock, formatLog, formatTransactionReceipt, formatTransactionResponse\n} from \"./format.js\";\nimport { Network } from \"./network.js\";\nimport { copyRequest, Block, FeeData, Log, TransactionReceipt, TransactionResponse } from \"./provider.js\";\nimport {\n    PollingBlockSubscriber, PollingBlockTagSubscriber, PollingEventSubscriber,\n    PollingOrphanSubscriber, PollingTransactionSubscriber\n} from \"./subscriber-polling.js\";\n\nimport type { Addressable, AddressLike } from \"../address/index.js\";\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\nimport type { Listener } from \"../utils/index.js\";\n\nimport type { Networkish } from \"./network.js\";\nimport type { FetchUrlFeeDataNetworkPlugin } from \"./plugins-network.js\";\n//import type { MaxPriorityFeePlugin } from \"./plugins-network.js\";\nimport type {\n    BlockParams, LogParams, TransactionReceiptParams,\n    TransactionResponseParams\n} from \"./formatting.js\";\n\nimport type {\n    BlockTag, EventFilter, Filter, FilterByBlockHash, OrphanFilter,\n    PreparedTransactionRequest, Provider, ProviderEvent,\n    TransactionRequest\n} from \"./provider.js\";\n\ntype Timer = ReturnType<typeof setTimeout>;\n\n\n// Constants\nconst BN_2 = BigInt(2);\n\nconst MAX_CCIP_REDIRECTS = 10;\n\nfunction isPromise<T = any>(value: any): value is Promise<T> {\n    return (value && typeof(value.then) === \"function\");\n}\n\nfunction getTag(prefix: string, value: any): string {\n    return prefix + \":\" + JSON.stringify(value, (k, v) => {\n        if (v == null) { return \"null\"; }\n        if (typeof(v) === \"bigint\") { return `bigint:${ v.toString() }`}\n        if (typeof(v) === \"string\") { return v.toLowerCase(); }\n\n        // Sort object keys\n        if (typeof(v) === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key) => {\n                accum[key] = v[key];\n                return accum;\n            }, <any>{ });\n        }\n\n        return v;\n    });\n}\n\n/**\n *  The types of additional event values that can be emitted for the\n *  ``\"debug\"`` event.\n */\nexport type DebugEventAbstractProvider = {\n    action: \"sendCcipReadFetchRequest\",\n    request: FetchRequest\n    index: number\n    urls: Array<string>\n} | {\n    action: \"receiveCcipReadFetchResult\",\n    request: FetchRequest,\n    result: any\n} | {\n    action: \"receiveCcipReadFetchError\",\n    request: FetchRequest,\n    result: any\n} | {\n    action: \"sendCcipReadCall\",\n    transaction: { to: string, data: string }\n} | {\n    action: \"receiveCcipReadCallResult\",\n    transaction: { to: string, data: string }\n    result: string\n} | {\n    action: \"receiveCcipReadCallError\",\n    transaction: { to: string, data: string }\n    error: Error\n};\n\n\n/**\n *  The value passed to the [[AbstractProvider-_getSubscriber]] method.\n *\n *  Only developers sub-classing [[AbstractProvider[[ will care about this,\n *  if they are modifying a low-level feature of how subscriptions operate.\n */\nexport type Subscription = {\n    type: \"block\" | \"close\" | \"debug\" | \"error\" | \"finalized\" | \"network\" | \"pending\" | \"safe\",\n    tag: string\n} | {\n    type: \"transaction\",\n    tag: string,\n    hash: string\n} | {\n    type: \"event\",\n    tag: string,\n    filter: EventFilter\n} | {\n    type: \"orphan\",\n    tag: string,\n    filter: OrphanFilter\n};\n\n/**\n *  A **Subscriber** manages a subscription.\n *\n *  Only developers sub-classing [[AbstractProvider[[ will care about this,\n *  if they are modifying a low-level feature of how subscriptions operate.\n */\nexport interface Subscriber {\n    /**\n     *  Called initially when a subscriber is added the first time.\n     */\n    start(): void;\n\n    /**\n     *  Called when there are no more subscribers to the event.\n     */\n    stop(): void;\n\n    /**\n     *  Called when the subscription should pause.\n     *\n     *  If %%dropWhilePaused%%, events that occur while paused should not\n     *  be emitted [[resume]].\n     */\n    pause(dropWhilePaused?: boolean): void;\n\n    /**\n     *  Resume a paused subscriber.\n     */\n    resume(): void;\n\n    /**\n     *  The frequency (in ms) to poll for events, if polling is used by\n     *  the subscriber.\n     *\n     *  For non-polling subscribers, this must return ``undefined``.\n     */\n    pollingInterval?: number;\n}\n\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */\nexport class UnmanagedSubscriber implements Subscriber {\n    /**\n     *  The name fof the event.\n     */\n    name!: string;\n\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */\n    constructor(name: string) { defineProperties<UnmanagedSubscriber>(this, { name }); }\n\n    start(): void { }\n    stop(): void { }\n\n    pause(dropWhilePaused?: boolean): void { }\n    resume(): void { }\n}\n\ntype Sub = {\n    tag: string;\n    nameMap: Map<string, string>\n    addressableMap: WeakMap<Addressable, string>;\n    listeners: Array<{ listener: Listener, once: boolean }>;\n    // @TODO: get rid of this, as it is (and has to be)\n    // tracked in subscriber\n    started: boolean;\n    subscriber: Subscriber;\n};\n\nfunction copy<T = any>(value: T): T {\n    return JSON.parse(JSON.stringify(value));\n}\n\nfunction concisify(items: Array<string>): Array<string> {\n    items = Array.from((new Set(items)).values())\n    items.sort();\n    return items;\n}\n\n\nasync function getSubscription(_event: ProviderEvent, provider: AbstractProvider): Promise<Subscription> {\n    if (_event == null) { throw new Error(\"invalid event\"); }\n\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) { _event = { topics: _event }; }\n\n    if (typeof(_event) === \"string\") {\n        switch (_event) {\n            case \"block\":\n            case \"debug\":\n            case \"error\":\n            case \"finalized\":\n            case \"network\":\n            case \"pending\":\n            case \"safe\": {\n                return { type: _event, tag: _event };\n            }\n        }\n    }\n\n    if (isHexString(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return { type: \"transaction\", tag: getTag(\"tx\", { hash }), hash };\n    }\n\n    if ((<any>_event).orphan) {\n        const event = <OrphanFilter>_event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return { type: \"orphan\", tag: getTag(\"orphan\", event), filter: copy(event) };\n    }\n\n    if (((<any>_event).address || (<any>_event).topics)) {\n        const event = <EventFilter>_event;\n\n        const filter: any = {\n            topics: ((event.topics || []).map((t) => {\n                if (t == null) { return null; }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t) => t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            }))\n        };\n\n        if (event.address) {\n            const addresses: Array<string> = [ ];\n            const promises: Array<Promise<void>> = [ ];\n\n            const addAddress = (addr: AddressLike) => {\n                if (isHexString(addr)) {\n                    addresses.push(addr);\n                } else {\n                    promises.push((async () => {\n                        addresses.push(await resolveAddress(addr, provider));\n                    })());\n                }\n            }\n\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            } else {\n                addAddress(event.address);\n            }\n            if (promises.length) { await Promise.all(promises); }\n            filter.address = concisify(addresses.map((a) => a.toLowerCase()));\n        }\n\n        return { filter, tag: getTag(\"event\", filter), type: \"event\" };\n    }\n\n    assertArgument(false, \"unknown ProviderEvent\", \"event\", _event);\n}\n\nfunction getTime(): number { return (new Date()).getTime(); }\n\n/**\n *  An **AbstractPlugin** is used to provide additional internal services\n *  to an [[AbstractProvider]] without adding backwards-incompatible changes\n *  to method signatures or other internal and complex logic.\n */\nexport interface AbstractProviderPlugin {\n    /**\n     *  The reverse domain notation of the plugin.\n     */\n    readonly name: string;\n\n    /**\n     *  Creates a new instance of the plugin, connected to %%provider%%.\n     */\n    connect(provider: AbstractProvider): AbstractProviderPlugin;\n}\n\n/**\n *  A normalized filter used for [[PerformActionRequest]] objects.\n */\nexport type PerformActionFilter = {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    fromBlock?: BlockTag;\n    toBlock?: BlockTag;\n} | {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    blockHash?: string;\n};\n\n/**\n *  A normalized transactions used for [[PerformActionRequest]] objects.\n */\nexport interface PerformActionTransaction extends PreparedTransactionRequest {\n    /**\n     *  The ``to`` address of the transaction.\n     */\n    to?: string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: string;\n}\n\n/**\n *  The [[AbstractProvider]] methods will normalize all values and pass this\n *  type to [[AbstractProvider-_perform]].\n */\nexport type PerformActionRequest = {\n    method: \"broadcastTransaction\",\n    signedTransaction: string\n} | {\n    method: \"call\",\n    transaction: PerformActionTransaction, blockTag: BlockTag\n} | {\n    method: \"chainId\"\n} | {\n    method: \"estimateGas\",\n    transaction: PerformActionTransaction\n} | {\n    method: \"getBalance\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getBlock\",\n    blockTag: BlockTag, includeTransactions: boolean\n} | {\n    method: \"getBlock\",\n    blockHash: string, includeTransactions: boolean\n} | {\n    method: \"getBlockNumber\"\n} | {\n    method: \"getCode\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getGasPrice\"\n} | {\n    method: \"getLogs\",\n    filter: PerformActionFilter\n} | {\n    method: \"getPriorityFee\"\n} | {\n    method: \"getStorage\",\n    address: string, position: bigint, blockTag: BlockTag\n} | {\n    method: \"getTransaction\",\n    hash: string\n} | {\n    method: \"getTransactionCount\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getTransactionReceipt\",\n    hash: string\n} | {\n    method: \"getTransactionResult\",\n    hash: string\n};\n\ntype _PerformAccountRequest = {\n    method: \"getBalance\" | \"getTransactionCount\" | \"getCode\"\n} | {\n    method: \"getStorage\", position: bigint\n}\n\n/**\n *  Options for configuring some internal aspects of an [[AbstractProvider]].\n *\n *  **``cacheTimeout``** - how long to cache a low-level ``_perform``\n *  for, based on input parameters. This reduces the number of calls\n *  to getChainId and getBlockNumber, but may break test chains which\n *  can perform operations (internally) synchronously. Use ``-1`` to\n *  disable, ``0`` will only buffer within the same event loop and\n *  any other value is in ms. (default: ``250``)\n */\nexport type AbstractProviderOptions = {\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};\n\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n\ntype CcipArgs = {\n    sender: string;\n    urls: Array<string>;\n    calldata: string;\n    selector: string;\n    extraData: string;\n    errorArgs: Array<any>\n};\n\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */\nexport class AbstractProvider implements Provider {\n\n    #subs: Map<string, Sub>;\n    #plugins: Map<string, AbstractProviderPlugin>;\n\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState: null | boolean;\n\n    #destroyed: boolean;\n\n    #networkPromise: null | Promise<Network>;\n    readonly #anyNetwork: boolean;\n\n    #performCache: Map<string, Promise<any>>;\n\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber: number;\n\n    #nextTimer: number;\n    #timers: Map<number, { timer: null | Timer, func: () => void, time: number }>;\n\n    #disableCcipRead: boolean;\n\n    #options: Required<AbstractProviderOptions>;\n\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */\n    constructor(_network?: \"any\" | Networkish, options?: AbstractProviderOptions) {\n        this.#options = Object.assign({ }, defaultOptions, options || { });\n\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        } else if (_network) {\n            const network = Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(() => { this.emit(\"network\", network, null); }, 0);\n        } else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n\n        this.#lastBlockNumber = -1;\n\n        this.#performCache = new Map();\n\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n\n        this.#destroyed = false;\n\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n\n        this.#disableCcipRead = false;\n    }\n\n    get pollingInterval(): number { return this.#options.pollingInterval; }\n\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */\n    get provider(): this { return this; }\n\n    /**\n     *  Returns all the registered plug-ins.\n     */\n    get plugins(): Array<AbstractProviderPlugin> {\n        return Array.from(this.#plugins.values());\n    }\n\n    /**\n     *  Attach a new plug-in.\n     */\n    attachPlugin(plugin: AbstractProviderPlugin): this {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${ plugin.name } `);\n        }\n        this.#plugins.set(plugin.name,  plugin.connect(this));\n        return this;\n    }\n\n    /**\n     *  Get a plugin by name.\n     */\n    getPlugin<T extends AbstractProviderPlugin = AbstractProviderPlugin>(name: string): null | T {\n        return <T>(this.#plugins.get(name)) || null;\n    }\n\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */\n    get disableCcipRead(): boolean { return this.#disableCcipRead; }\n    set disableCcipRead(value: boolean) { this.#disableCcipRead = !!value; }\n\n    // Shares multiple identical requests made during the same 250ms\n    async #perform<T = any>(req: PerformActionRequest): Promise<T> {\n        const timeout = this.#options.cacheTimeout;\n\n        // Caching disabled\n        if (timeout < 0) { return await this._perform(req); }\n\n        // Create a tag\n        const tag = getTag(req.method, req);\n\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n\n            this.#performCache.set(tag, perform);\n\n            setTimeout(() => {\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n\n        return await perform;\n    }\n\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */\n    async ccipReadFetch(tx: PerformActionTransaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n        const errorMessages: Array<string> = [ ];\n\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = { data, sender };\n            }\n\n            this.emit(\"debug\", { action: \"sendCcipReadFetchRequest\", request, index: i, urls });\n\n            let errorMessage = \"unknown error\";\n\n            const resp = await request.send();\n            try {\n                 const result = resp.bodyJson;\n                 if (result.data) {\n                     this.emit(\"debug\", { action: \"receiveCcipReadFetchResult\", request, result });\n                     return result.data;\n                 }\n                 if (result.message) { errorMessage = result.message; }\n                 this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result });\n            } catch (error) { }\n\n            // 4xx indicates the result is not present; stop\n            assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${ errorMessage }`,\n                \"OFFCHAIN_FAULT\", { reason: \"404_MISSING_RESOURCE\", transaction: tx, info: { url, errorMessage } });\n\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n\n        assert(false, `error encountered during CCIP fetch: ${ errorMessages.map((m) => JSON.stringify(m)).join(\", \") }`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx, info: { urls, errorMessages }\n        });\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */\n    _wrapBlock(value: BlockParams, network: Network): Block {\n        return new Block(formatBlock(value), this);\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */\n    _wrapLog(value: LogParams, network: Network): Log {\n        return new Log(formatLog(value), this);\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */\n    _wrapTransactionReceipt(value: TransactionReceiptParams, network: Network): TransactionReceipt {\n        return new TransactionReceipt(formatTransactionReceipt(value), this);\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */\n    _wrapTransactionResponse(tx: TransactionResponseParams, network: Network): TransactionResponse {\n        return new TransactionResponse(formatTransactionResponse(tx), this);\n    }\n\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */\n    _detectNetwork(): Promise<Network> {\n        assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */\n    async _perform<T = any>(req: PerformActionRequest): Promise<T> {\n        assert(false, `unsupported method: ${ req.method }`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n\n    // State\n\n    async getBlockNumber(): Promise<number> {\n        const blockNumber = getNumber(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) { this.#lastBlockNumber = blockNumber; }\n        return blockNumber;\n    }\n\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */\n    _getAddress(address: AddressLike): string | Promise<string> {\n        return resolveAddress(address, this);\n    }\n\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */\n    _getBlockTag(blockTag?: BlockTag): string | Promise<string> {\n        if (blockTag == null) { return \"latest\"; }\n\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n                return blockTag;\n        }\n\n\n        if (isHexString(blockTag)) {\n            if (isHexString(blockTag, 32)) { return blockTag; }\n            return toQuantity(blockTag);\n        }\n\n        if (typeof(blockTag) === \"bigint\") {\n            blockTag = getNumber(blockTag, \"blockTag\");\n        }\n\n        if (typeof(blockTag) === \"number\") {\n            if (blockTag >= 0) { return toQuantity(blockTag); }\n            if (this.#lastBlockNumber >= 0) { return toQuantity(this.#lastBlockNumber + blockTag); }\n            return this.getBlockNumber().then((b) => toQuantity(b + <number>blockTag));\n        }\n\n        assertArgument(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */\n    _getFilter(filter: Filter | FilterByBlockHash): PerformActionFilter | Promise<PerformActionFilter> {\n\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || [ ]).map((t) => {\n            if (t == null) { return null; }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t) => t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n\n        const blockHash = (\"blockHash\" in filter) ? filter.blockHash: undefined;\n\n        const resolve = (_address: Array<string>, fromBlock?: string, toBlock?: string) => {\n            let address: undefined | string | Array<string> = undefined;\n            switch (_address.length) {\n                case 0: break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n\n            const filter = <any>{ };\n            if (address) { filter.address = address; }\n            if (topics.length) { filter.topics = topics; }\n            if (fromBlock) { filter.fromBlock = fromBlock; }\n            if (toBlock) { filter.toBlock = toBlock; }\n            if (blockHash) { filter.blockHash = blockHash; }\n\n            return filter;\n        };\n\n        // Addresses could be async (ENS names or Addressables)\n        let address: Array<string | Promise<string>> = [ ];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address) { address.push(this._getAddress(addr)); }\n            } else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n\n        let fromBlock: undefined | string | Promise<string> = undefined;\n        if (\"fromBlock\" in filter) { fromBlock = this._getBlockTag(filter.fromBlock); }\n\n        let toBlock: undefined | string | Promise<string> = undefined;\n        if (\"toBlock\" in filter) { toBlock = this._getBlockTag(filter.toBlock); }\n\n        if (address.filter((a) => (typeof(a) !== \"string\")).length ||\n            (fromBlock != null && typeof(fromBlock) !== \"string\") ||\n            (toBlock != null && typeof(toBlock) !== \"string\")) {\n\n            return Promise.all([ Promise.all(address), fromBlock, toBlock ]).then((result) => {\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n\n        return resolve(<Array<string>>address, fromBlock, toBlock);\n    }\n\n    /**\n     *  Returns or resolves to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */\n    _getTransactionRequest(_request: TransactionRequest): PerformActionTransaction | Promise<PerformActionTransaction> {\n        const request = <PerformActionTransaction>copyRequest(_request);\n\n        const promises: Array<Promise<void>> = [ ];\n        [ \"to\", \"from\" ].forEach((key) => {\n            if ((<any>request)[key] == null) { return; }\n\n            const addr = resolveAddress((<any>request)[key], this);\n            if (isPromise(addr)) {\n                promises.push((async function() { (<any>request)[key] = await addr; })());\n            } else {\n                (<any>request)[key] = addr;\n            }\n        });\n\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push((async function() { request.blockTag = await blockTag; })());\n            } else {\n                request.blockTag = blockTag;\n            }\n        }\n\n        if (promises.length) {\n            return (async function() {\n                await Promise.all(promises);\n                return request;\n            })();\n        }\n\n        return request;\n    }\n\n    async getNetwork(): Promise<Network> {\n\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async () => {\n                try {\n                    const network = await this._detectNetwork();\n                    this.emit(\"network\", network, null);\n                    return network;\n                } catch (error) {\n                    if (this.#networkPromise === detectNetwork!) {\n                        this.#networkPromise = null;\n                    }\n                    throw error;\n                }\n            })();\n\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n\n        const networkPromise = this.#networkPromise;\n\n        const [ expected, actual ] = await Promise.all([\n            networkPromise,          // Possibly an explicit Network\n            this._detectNetwork()    // The actual connected network\n        ]);\n\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            } else {\n                // Otherwise, we do not allow changes to the underlying network\n                assert(false, `network changed: ${ expected.chainId } => ${ actual.chainId } `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n\n        return expected.clone();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        const network = await this.getNetwork();\n\n        const getFeeDataFunc = async () => {\n            const { _block, gasPrice, priorityFee } = await resolveProperties({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getGasPrice\" });\n                        return getBigInt(value, \"%response\");\n                    } catch (error) { }\n                    return null\n                })()),\n                priorityFee: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getPriorityFee\" });\n                        return getBigInt(value, \"%response\");\n                    } catch (error) { }\n                    return null;\n                })())\n            });\n\n            let maxFeePerGas: null | bigint = null;\n            let maxPriorityFeePerGas: null | bigint = null;\n\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = (priorityFee != null) ? priorityFee: BigInt(\"1000000000\");\n                maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;\n            }\n\n            return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = <FetchUrlFeeDataNetworkPlugin>network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n\n        return await getFeeDataFunc();\n    }\n\n\n    async estimateGas(_tx: TransactionRequest): Promise<bigint> {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) { tx = await tx; }\n        return getBigInt(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }\n\n    async #call(tx: PerformActionTransaction, blockTag: string, attempt: number): Promise<string> {\n        assert (attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n             reason: \"TOO_MANY_REDIRECTS\",\n             transaction: Object.assign({ }, tx, { blockTag, enableCcipRead: true })\n         });\n\n         // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n         const transaction = <PerformActionTransaction>copyRequest(tx);\n\n         try {\n             return hexlify(await this._perform({ method: \"call\", transaction, blockTag }));\n\n         } catch (error: any) {\n             // CCIP Read OffchainLookup\n             if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && dataSlice(error.data, 0, 4) === \"0x556f1830\") {\n                 const data = error.data;\n\n                 const txSender = await resolveAddress(transaction.to, this);\n\n                 // Parse the CCIP Read Arguments\n                 let ccipArgs: CcipArgs;\n                 try {\n                     ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));\n                 } catch (error: any) {\n                     assert(false, error.message, \"OFFCHAIN_FAULT\", {\n                         reason: \"BAD_DATA\", transaction, info: { data } });\n                 }\n\n                 // Check the sender of the OffchainLookup matches the transaction\n                 assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(),\n                     \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                         action: \"call\",\n                         data,\n                         reason: \"OffchainLookup\",\n                         transaction: <any>transaction, // @TODO: populate data?\n                         invocation: null,\n                         revert: {\n                             signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                             name: \"OffchainLookup\",\n                             args: ccipArgs.errorArgs\n                         }\n                     });\n\n                 const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                 assert(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                     reason: \"FETCH_FAILED\", transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs } });\n\n                 const tx = {\n                     to: txSender,\n                     data: concat([ ccipArgs.selector, encodeBytes([ ccipResult, ccipArgs.extraData ]) ])\n                 };\n\n                 this.emit(\"debug\", { action: \"sendCcipReadCall\", transaction: tx });\n                 try {\n                     const result = await this.#call(tx, blockTag, attempt + 1);\n                     this.emit(\"debug\", { action: \"receiveCcipReadCallResult\", transaction: Object.assign({ }, tx), result });\n                     return result;\n                 } catch (error) {\n                     this.emit(\"debug\", { action: \"receiveCcipReadCallError\", transaction: Object.assign({ }, tx), error });\n                     throw error;\n                 }\n             }\n\n             throw error;\n         }\n    }\n\n    async #checkNetwork<T>(promise: Promise<T>): Promise<T> {\n        const { value } = await resolveProperties({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n\n    async call(_tx: TransactionRequest): Promise<string> {\n        const { tx, blockTag } = await resolveProperties({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0: -1));\n    }\n\n    // Account\n    async #getAccountValue(request: _PerformAccountRequest, _address: AddressLike, _blockTag?: BlockTag): Promise<any> {\n        let address: string | Promise<string> = this._getAddress(_address);\n        let blockTag: string | Promise<string> = this._getBlockTag(_blockTag);\n\n        if (typeof(address) !== \"string\" || typeof(blockTag) !== \"string\") {\n            [ address, blockTag ] = await Promise.all([ address, blockTag ]);\n        }\n\n        return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));\n    }\n\n    async getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint> {\n        return getBigInt(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }\n\n    async getTransactionCount(address: AddressLike, blockTag?: BlockTag): Promise<number> {\n        return getNumber(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }\n\n    async getCode(address: AddressLike, blockTag?: BlockTag): Promise<string> {\n        return hexlify(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }\n\n    async getStorage(address: AddressLike, _position: BigNumberish, blockTag?: BlockTag): Promise<string> {\n        const position = getBigInt(_position, \"position\");\n        return hexlify(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }\n\n    // Write\n    async broadcastTransaction(signedTx: string): Promise<TransactionResponse> {\n        const { blockNumber, hash, network } = await resolveProperties({\n             blockNumber: this.getBlockNumber(),\n             hash: this._perform({\n                 method: \"broadcastTransaction\",\n                 signedTransaction: signedTx\n             }),\n             network: this.getNetwork()\n        });\n\n        const tx = Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n\n        return this._wrapTransactionResponse(<any>tx, network).replaceableTransaction(blockNumber);\n    }\n\n    async #getBlock(block: BlockTag | string, includeTransactions: boolean): Promise<any> {\n        // @TODO: Add CustomBlockPlugin check\n\n        if (isHexString(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            });\n        }\n\n        let blockTag = this._getBlockTag(block);\n        if (typeof(blockTag) !== \"string\") { blockTag = await blockTag; }\n\n        return await this.#perform({\n            method: \"getBlock\", blockTag, includeTransactions\n        });\n    }\n\n    // Queries\n    async getBlock(block: BlockTag | string, prefetchTxs?: boolean): Promise<null | Block> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) { return null; }\n\n        return this._wrapBlock(params, network);\n    }\n\n    async getTransaction(hash: string): Promise<null | TransactionResponse> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) { return null; }\n\n        return this._wrapTransactionResponse(params, network);\n    }\n\n    async getTransactionReceipt(hash: string): Promise<null | TransactionReceipt> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) { return null; }\n\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({ method: \"getTransaction\", hash });\n            if (tx == null) { throw new Error(\"report this; could not find tx or effectiveGasPrice\"); }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n\n        return this._wrapTransactionReceipt(params, network);\n    }\n\n    async getTransactionResult(hash: string): Promise<null | string> {\n        const { result } = await resolveProperties({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) { return null; }\n        return hexlify(result);\n    }\n\n    // Bloom-filter Queries\n    async getLogs(_filter: Filter | FilterByBlockHash): Promise<Array<Log>> {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) { filter = await filter; }\n\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform<Array<LogParams>>({ method: \"getLogs\", filter })\n        });\n\n        return params.map((p) => this._wrapLog(p, network));\n    }\n\n    // ENS\n    _getProvider(chainId: number): AbstractProvider {\n        assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n\n    async getResolver(name: string): Promise<null | EnsResolver> {\n        return await EnsResolver.fromName(this, name);\n    }\n\n    async getAvatar(name: string): Promise<null | string> {\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAvatar(); }\n        return null;\n    }\n\n    async resolveName(name: string): Promise<null | string>{\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAddress(); }\n        return null;\n    }\n\n    async lookupAddress(address: string): Promise<null | string> {\n        address = getAddress(address);\n        const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n\n        try {\n\n            const ensAddr = await EnsResolver.getEnsAddress(this);\n            const ensContract = new Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === ZeroAddress) { return null; }\n\n            const resolverContract = new Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) { return null; }\n\n            return name;\n\n        } catch (error) {\n            // No data was returned from the resolver\n            if (isError(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n\n            // Something reerted\n            if (isError(error, \"CALL_EXCEPTION\")) { return null; }\n\n            throw error;\n        }\n\n        return null;\n    }\n\n    async waitForTransaction(hash: string, _confirms?: null | number, timeout?: null | number): Promise<null | TransactionReceipt> {\n        const confirms = (_confirms != null) ? _confirms: 1;\n        if (confirms === 0) { return this.getTransactionReceipt(hash); }\n\n        return new Promise(async (resolve, reject) => {\n            let timer: null | Timer = null;\n\n            const listener = (async (blockNumber: number) => {\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                } catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            });\n\n            if (timeout != null) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject(makeError(\"timeout\", \"TIMEOUT\", { reason: \"timeout\" }));\n                }, timeout);\n            }\n\n            listener(await this.getBlockNumber());\n        });\n    }\n\n    async waitForBlock(blockTag?: BlockTag): Promise<Block> {\n        assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */\n    _clearTimeout(timerId: number): void {\n        const timer = this.#timers.get(timerId);\n        if (!timer) { return; }\n        if (timer.timer) { clearTimeout(timer.timer); }\n        this.#timers.delete(timerId);\n    }\n\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */\n    _setTimeout(_func: () => void, timeout?: number): number {\n        if (timeout == null) { timeout = 0; }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n\n        if (this.paused) {\n            this.#timers.set(timerId, { timer: null, func, time: timeout });\n        } else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, { timer, func, time: getTime() });\n        }\n\n        return timerId;\n    }\n\n    /**\n     *  Perform %%func%% on each subscriber.\n     */\n    _forEachSubscriber(func: (s: Subscriber) => void): void {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }\n\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */\n    _getSubscriber(sub: Subscription): Subscriber {\n        switch (sub.type) {\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\": {\n                const subscriber = new PollingBlockSubscriber(this);\n                subscriber.pollingInterval = this.pollingInterval;\n                return subscriber;\n            }\n            case \"safe\": case \"finalized\":\n                return new PollingBlockTagSubscriber(this, sub.type);\n            case \"event\":\n                return new PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new PollingOrphanSubscriber(this, sub.filter);\n        }\n\n        throw new Error(`unsupported event: ${ sub.type }`);\n    }\n\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */\n    _recoverSubscriber(oldSub: Subscriber, newSub: Subscriber): void {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) { sub.subscriber.stop(); }\n                sub.subscriber = newSub;\n                if (sub.started) { newSub.start(); }\n                if (this.#pausedState != null) { newSub.pause(this.#pausedState); }\n                break;\n            }\n        }\n    }\n\n    async #hasSub(event: ProviderEvent, emitArgs?: Array<any>): Promise<null | Sub> {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({ orphan: \"drop-log\", log: emitArgs[0] }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n\n    async #getSub(event: ProviderEvent): Promise<Sub> {\n        const subscription = await getSubscription(event, this);\n\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [ ] };\n            this.#subs.set(tag, sub);\n        }\n\n        return sub;\n    }\n\n    async on(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) { sub.subscriber.pause(this.#pausedState); }\n        }\n        return this;\n    }\n\n    async once(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) { sub.subscriber.pause(this.#pausedState); }\n        }\n        return this;\n    }\n\n    async emit(event: ProviderEvent, ...args: Array<any>): Promise<boolean> {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) { return false; };\n\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once }) => {\n            const payload = new EventPayload(this, (once ? null: listener), event);\n            try {\n                listener.call(this, ...args, payload);\n            } catch(error) { }\n            return !once;\n        });\n\n        if (sub.listeners.length === 0) {\n            if (sub.started) { sub.subscriber.stop(); }\n            this.#subs.delete(sub.tag);\n        }\n\n        return (count > 0);\n    }\n\n    async listenerCount(event?: ProviderEvent): Promise<number> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        let total = 0;\n        for (const { listeners } of this.#subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n\n    async listeners(event?: ProviderEvent): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return  [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result: Array<Listener> = [ ];\n        for (const { listeners } of this.#subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n\n    async off(event: ProviderEvent, listener?: Listener): Promise<this> {\n        const sub = await this.#hasSub(event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { sub.listeners.splice(index, 1); }\n        }\n\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) { sub.subscriber.stop(); }\n            this.#subs.delete(sub.tag);\n        }\n\n        return this;\n    }\n\n    async removeAllListeners(event?: ProviderEvent): Promise<this> {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) { subscriber.stop(); }\n            this.#subs.delete(tag);\n        } else {\n            for (const [ tag, { started, subscriber } ] of this.#subs) {\n                if (started) { subscriber.stop(); }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n\n    // Alias for \"on\"\n    async addListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return await this.on(event, listener);\n    }\n\n    // Alias for \"off\"\n    async removeListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return this.off(event, listener);\n    }\n\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */\n    get destroyed(): boolean {\n        return this.#destroyed;\n    }\n\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */\n    destroy(): void {\n        // Stop all listeners\n        this.removeAllListeners();\n\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n\n        this.#destroyed = true;\n    }\n\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */\n    get paused(): boolean { return (this.#pausedState != null); }\n    set paused(pause: boolean) {\n        if (!!pause === this.paused) { return; }\n\n        if (this.paused) {\n            this.resume();\n        } else {\n            this.pause(false);\n        }\n    }\n\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */\n    pause(dropWhilePaused?: boolean): void {\n        this.#lastBlockNumber = -1;\n\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) { return; }\n            assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n\n        this._forEachSubscriber((s) => s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n\n        for (const timer of this.#timers.values()) {\n            // Clear the timer\n            if (timer.timer) { clearTimeout(timer.timer); }\n\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n\n    /**\n     *  Resume the provider.\n     */\n    resume(): void {\n        if (this.#pausedState == null) { return; }\n\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) { timeout = 0; }\n\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\n\n\nfunction _parseString(result: string, start: number): null | string {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) { return toUtf8String(bytes); }\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string, start: number): null | string {\n    if (result === \"0x\") { return null; }\n    try {\n        const offset = getNumber(dataSlice(result, start, start + 32));\n        const length = getNumber(dataSlice(result, offset, offset + 32));\n\n        return dataSlice(result, offset + 32, offset + 32 + length);\n    } catch (error) { }\n    return null;\n}\n\nfunction numPad(value: number): Uint8Array {\n    const result = toBeArray(value);\n    if (result.length > 32) { throw new Error(\"internal; should not happen\"); }\n\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\n\nfunction bytesPad(value: Uint8Array): Uint8Array {\n    if ((value.length % 32) === 0) { return value; }\n\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n\nconst empty: Uint8Array = new Uint8Array([ ]);\n\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas: Array<BytesLike>): string {\n    const result: Array<Uint8Array> = [ ];\n\n    let byteCount = 0;\n\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(empty);\n        byteCount += 32;\n    }\n\n    for (let i = 0; i < datas.length; i++) {\n        const data = getBytes(datas[i]);\n\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n\n    return concat(result);\n}\n\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\"\nfunction parseOffchainLookup(data: string): CcipArgs {\n    const result: CcipArgs = {\n        sender: \"\", urls: [ ], calldata: \"\", selector: \"\", extraData: \"\", errorArgs: [ ]\n    };\n\n    assert(dataLength(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n\n    const sender = dataSlice(data, 0, 32);\n    assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = dataSlice(sender, 12);\n\n    // Read the URLs from the response\n    try {\n        const urls: Array<string> = [];\n        const urlsOffset = getNumber(dataSlice(data, 32, 64));\n        const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));\n        const urlsData = dataSlice(data, urlsOffset + 32);\n        for (let u = 0; u < urlsLength; u++) {\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) { throw new Error(\"abort\"); }\n            urls.push(url);\n        }\n        result.urls = urls;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) { throw new Error(\"abort\"); }\n        result.calldata = calldata;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n\n    // Get the callbackSelector (bytes4)\n    assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = dataSlice(data, 96, 100);\n\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) { throw new Error(\"abort\"); }\n        result.extraData = extraData;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k) => (<any>result)[k])\n\n    return result;\n}\n"],"mappings":";;;;;;AAAA;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,UAAU,EAAEC,cAAc,QAAQ,qBAAqB;AAChE,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,QAAQ,QAAQ,sBAAsB;AAC/C,SAASC,QAAQ,QAAQ,kBAAkB;AAC3C,SAASC,WAAW,QAAQ,yBAAyB;AACrD,SACIC,MAAM,EAAEC,UAAU,EAAEC,SAAS,EAAEC,OAAO,EAAEC,WAAW,EACnDC,SAAS,EAAEC,QAAQ,EAAEC,SAAS,EAC9BC,eAAe,EAAEC,OAAO,EAAEC,SAAS,EAAEC,MAAM,EAAEC,cAAc,EAC3DC,YAAY,EACZC,SAAS,EAAEC,UAAU,EACrBC,gBAAgB,EAAEC,YAAY,EAAEC,iBAAiB,EACjDC,YAAY,QACT,mBAAmB;AAE1B,SAASC,WAAW,QAAQ,mBAAmB;AAC/C,SACIC,WAAW,EAAEC,SAAS,EAAEC,wBAAwB,EAAEC,yBAAyB,QACxE,aAAa;AACpB,SAASC,OAAO,QAAQ,cAAc;AACtC,SAASC,WAAW,EAAEC,KAAK,EAAEC,OAAO,EAAEC,GAAG,EAAEC,kBAAkB,EAAEC,mBAAmB,QAAQ,eAAe;AACzG,SACIC,sBAAsB,EAAEC,yBAAyB,EAAEC,sBAAsB,EACzEC,uBAAuB,EAAEC,4BAA4B,QAClD,yBAAyB;AAuBhC;AACA,MAAMC,IAAI,GAAGC,MAAM,CAAC,CAAC,CAAC;AAEtB,MAAMC,kBAAkB,GAAG,EAAE;AAE7B,SAASC,SAASA,CAAUC,KAAU;EAClC,OAAQA,KAAK,IAAI,OAAOA,KAAK,CAACC,IAAK,KAAK,UAAU;AACtD;AAEA,SAASC,MAAMA,CAACC,MAAc,EAAEH,KAAU;EACtC,OAAOG,MAAM,GAAG,GAAG,GAAGC,IAAI,CAACC,SAAS,CAACL,KAAK,EAAE,CAACM,CAAC,EAAEC,CAAC,KAAI;IACjD,IAAIA,CAAC,IAAI,IAAI,EAAE;MAAE,OAAO,MAAM;;IAC9B,IAAI,OAAOA,CAAE,KAAK,QAAQ,EAAE;MAAE,iBAAAhD,MAAA,CAAkBgD,CAAC,CAACC,QAAQ,EAAG;;IAC7D,IAAI,OAAOD,CAAE,KAAK,QAAQ,EAAE;MAAE,OAAOA,CAAC,CAACE,WAAW,EAAE;;IAEpD;IACA,IAAI,OAAOF,CAAE,KAAK,QAAQ,IAAI,CAACG,KAAK,CAACC,OAAO,CAACJ,CAAC,CAAC,EAAE;MAC7C,MAAMK,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACL,CAAC,CAAC;MAC3BK,IAAI,CAACE,IAAI,EAAE;MACX,OAAOF,IAAI,CAACG,MAAM,CAAC,CAACC,KAAK,EAAEC,GAAG,KAAI;QAC9BD,KAAK,CAACC,GAAG,CAAC,GAAGV,CAAC,CAACU,GAAG,CAAC;QACnB,OAAOD,KAAK;MAChB,CAAC,EAAO,EAAG,CAAC;;IAGhB,OAAOT,CAAC;EACZ,CAAC,CAAC;AACN;AA+FA;;;;;AAKA,OAAM,MAAOW,mBAAmB;EAM5B;;;EAGAC,YAAYC,IAAY;IARxB;;;IAAAC,eAAA;IAQ4B9C,gBAAgB,CAAsB,IAAI,EAAE;MAAE6C;IAAI,CAAE,CAAC;EAAE;EAEnFE,KAAKA,CAAA,GAAW;EAChBC,IAAIA,CAAA,GAAW;EAEfC,KAAKA,CAACC,eAAyB,GAAU;EACzCC,MAAMA,CAAA,GAAW;;AAcrB,SAASC,IAAIA,CAAU3B,KAAQ;EAC3B,OAAOI,IAAI,CAACwB,KAAK,CAACxB,IAAI,CAACC,SAAS,CAACL,KAAK,CAAC,CAAC;AAC5C;AAEA,SAAS6B,SAASA,CAACC,KAAoB;EACnCA,KAAK,GAAGpB,KAAK,CAACqB,IAAI,CAAE,IAAIC,GAAG,CAACF,KAAK,CAAC,CAAEG,MAAM,EAAE,CAAC;EAC7CH,KAAK,CAAChB,IAAI,EAAE;EACZ,OAAOgB,KAAK;AAChB;AAGA,eAAeI,eAAeA,CAACC,MAAqB,EAAEC,QAA0B;EAC5E,IAAID,MAAM,IAAI,IAAI,EAAE;IAAE,MAAM,IAAIE,KAAK,CAAC,eAAe,CAAC;;EAEtD;EACA,IAAI3B,KAAK,CAACC,OAAO,CAACwB,MAAM,CAAC,EAAE;IAAEA,MAAM,GAAG;MAAEG,MAAM,EAAEH;IAAM,CAAE;;EAExD,IAAI,OAAOA,MAAO,KAAK,QAAQ,EAAE;IAC7B,QAAQA,MAAM;MACV,KAAK,OAAO;MACZ,KAAK,OAAO;MACZ,KAAK,OAAO;MACZ,KAAK,WAAW;MAChB,KAAK,SAAS;MACd,KAAK,SAAS;MACd,KAAK,MAAM;QAAE;UACT,OAAO;YAAEI,IAAI,EAAEJ,MAAM;YAAEK,GAAG,EAAEL;UAAM,CAAE;;;;EAKhD,IAAIxE,WAAW,CAACwE,MAAM,EAAE,EAAE,CAAC,EAAE;IACzB,MAAMM,IAAI,GAAGN,MAAM,CAAC1B,WAAW,EAAE;IACjC,OAAO;MAAE8B,IAAI,EAAE,aAAa;MAAEC,GAAG,EAAEtC,MAAM,CAAC,IAAI,EAAE;QAAEuC;MAAI,CAAE,CAAC;MAAEA;IAAI,CAAE;;EAGrE,IAAUN,MAAO,CAACO,MAAM,EAAE;IACtB,MAAMC,KAAK,GAAiBR,MAAM;IAClC;IACA,OAAO;MAAEI,IAAI,EAAE,QAAQ;MAAEC,GAAG,EAAEtC,MAAM,CAAC,QAAQ,EAAEyC,KAAK,CAAC;MAAEC,MAAM,EAAEjB,IAAI,CAACgB,KAAK;IAAC,CAAE;;EAGhF,IAAWR,MAAO,CAACU,OAAO,IAAUV,MAAO,CAACG,MAAM,EAAG;IACjD,MAAMK,KAAK,GAAgBR,MAAM;IAEjC,MAAMS,MAAM,GAAQ;MAChBN,MAAM,EAAG,CAACK,KAAK,CAACL,MAAM,IAAI,EAAE,EAAEQ,GAAG,CAAEC,CAAC,IAAI;QACpC,IAAIA,CAAC,IAAI,IAAI,EAAE;UAAE,OAAO,IAAI;;QAC5B,IAAIrC,KAAK,CAACC,OAAO,CAACoC,CAAC,CAAC,EAAE;UAClB,OAAOlB,SAAS,CAACkB,CAAC,CAACD,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACtC,WAAW,EAAE,CAAC,CAAC;;QAEnD,OAAOsC,CAAC,CAACtC,WAAW,EAAE;MAC1B,CAAC;KACJ;IAED,IAAIkC,KAAK,CAACE,OAAO,EAAE;MACf,MAAMG,SAAS,GAAkB,EAAG;MACpC,MAAMC,QAAQ,GAAyB,EAAG;MAE1C,MAAMC,UAAU,GAAIC,IAAiB,IAAI;QACrC,IAAIxF,WAAW,CAACwF,IAAI,CAAC,EAAE;UACnBH,SAAS,CAACI,IAAI,CAACD,IAAI,CAAC;SACvB,MAAM;UACHF,QAAQ,CAACG,IAAI,CAAC,CAAC,YAAW;YACtBJ,SAAS,CAACI,IAAI,CAAC,MAAMlG,cAAc,CAACiG,IAAI,EAAEf,QAAQ,CAAC,CAAC;UACxD,CAAC,EAAC,CAAE,CAAC;;MAEb,CAAC;MAED,IAAI1B,KAAK,CAACC,OAAO,CAACgC,KAAK,CAACE,OAAO,CAAC,EAAE;QAC9BF,KAAK,CAACE,OAAO,CAACQ,OAAO,CAACH,UAAU,CAAC;OACpC,MAAM;QACHA,UAAU,CAACP,KAAK,CAACE,OAAO,CAAC;;MAE7B,IAAII,QAAQ,CAACK,MAAM,EAAE;QAAE,MAAMC,OAAO,CAACC,GAAG,CAACP,QAAQ,CAAC;;MAClDL,MAAM,CAACC,OAAO,GAAGhB,SAAS,CAACmB,SAAS,CAACF,GAAG,CAAEW,CAAC,IAAKA,CAAC,CAAChD,WAAW,EAAE,CAAC,CAAC;;IAGrE,OAAO;MAAEmC,MAAM;MAAEJ,GAAG,EAAEtC,MAAM,CAAC,OAAO,EAAE0C,MAAM,CAAC;MAAEL,IAAI,EAAE;IAAO,CAAE;;EAGlEpE,cAAc,CAAC,KAAK,EAAE,uBAAuB,EAAE,OAAO,EAAEgE,MAAM,CAAC;AACnE;AAEA,SAASuB,OAAOA,CAAA;EAAa,OAAQ,IAAIC,IAAI,EAAE,CAAED,OAAO,EAAE;AAAE;AA0H5D,MAAME,cAAc,GAAG;EACnBC,YAAY,EAAE,GAAG;EACjBC,eAAe,EAAE;CACpB;AAWD;;;;;;AAAA,IAAAC,KAAA,oBAAAC,OAAA;AAAA,IAAAC,QAAA,oBAAAD,OAAA;AAAA,IAAAE,YAAA,oBAAAF,OAAA;AAAA,IAAAG,UAAA,oBAAAH,OAAA;AAAA,IAAAI,eAAA,oBAAAJ,OAAA;AAAA,IAAAK,WAAA,oBAAAL,OAAA;AAAA,IAAAM,aAAA,oBAAAN,OAAA;AAAA,IAAAO,gBAAA,oBAAAP,OAAA;AAAA,IAAAQ,UAAA,oBAAAR,OAAA;AAAA,IAAAS,OAAA,oBAAAT,OAAA;AAAA,IAAAU,gBAAA,oBAAAV,OAAA;AAAA,IAAAW,QAAA,oBAAAX,OAAA;AAAA,IAAAY,uBAAA,oBAAAC,OAAA;AAMA,OAAM,MAAOC,gBAAgB;EAyBzB;;;;;EAKA3D,YAAY4D,QAA6B,EAAEC,OAAiC;IAwE5E;IAAAC,2BAAA,OAAAL,uBAAA;IApGAM,0BAAA,OAAAnB,KAAK;IACLmB,0BAAA,OAAAjB,QAAQ;IAER;IACAiB,0BAAA,OAAAhB,YAAY;IAEZgB,0BAAA,OAAAf,UAAU;IAEVe,0BAAA,OAAAd,eAAe;IACNc,0BAAA,OAAAb,WAAW;IAEpBa,0BAAA,OAAAZ,aAAa;IAEb;IACAY,0BAAA,OAAAX,gBAAgB;IAEhBW,0BAAA,OAAAV,UAAU;IACVU,0BAAA,OAAAT,OAAO;IAEPS,0BAAA,OAAAR,gBAAgB;IAEhBQ,0BAAA,OAAAP,QAAQ;IAQJQ,qBAAA,CAAKR,QAAQ,EAAb,IAAI,EAAY9D,MAAM,CAACuE,MAAM,CAAC,EAAG,EAAExB,cAAc,EAAEoB,OAAO,IAAI,EAAG,CAA5D,CAAQ;IAEb,IAAID,QAAQ,KAAK,KAAK,EAAE;MACpBI,qBAAA,CAAKd,WAAW,EAAhB,IAAI,EAAe,IAAd,CAAW;MAChBc,qBAAA,CAAKf,eAAe,EAApB,IAAI,EAAmB,IAAlB,CAAe;KACvB,MAAM,IAAIW,QAAQ,EAAE;MACjB,MAAMM,OAAO,GAAGrG,OAAO,CAAC+C,IAAI,CAACgD,QAAQ,CAAC;MACtCI,qBAAA,CAAKd,WAAW,EAAhB,IAAI,EAAe,KAAd,CAAW;MAChBc,qBAAA,CAAKf,eAAe,EAApB,IAAI,EAAmBb,OAAO,CAAC+B,OAAO,CAACD,OAAO,CAAzC,CAAe;MACpBE,UAAU,CAAC,MAAK;QAAG,IAAI,CAACC,IAAI,CAAC,SAAS,EAAEH,OAAO,EAAE,IAAI,CAAC;MAAE,CAAC,EAAE,CAAC,CAAC;KAChE,MAAM;MACHF,qBAAA,CAAKd,WAAW,EAAhB,IAAI,EAAe,KAAd,CAAW;MAChBc,qBAAA,CAAKf,eAAe,EAApB,IAAI,EAAmB,IAAlB,CAAe;;IAGxBe,qBAAA,CAAKZ,gBAAgB,EAArB,IAAI,EAAoB,CAAC,CAApB,CAAgB;IAErBY,qBAAA,CAAKb,aAAa,EAAlB,IAAI,EAAiB,IAAImB,GAAG,EAAvB,CAAa;IAElBN,qBAAA,CAAKpB,KAAK,EAAV,IAAI,EAAS,IAAI0B,GAAG,EAAf,CAAK;IACVN,qBAAA,CAAKlB,QAAQ,EAAb,IAAI,EAAY,IAAIwB,GAAG,EAAlB,CAAQ;IACbN,qBAAA,CAAKjB,YAAY,EAAjB,IAAI,EAAgB,IAAf,CAAY;IAEjBiB,qBAAA,CAAKhB,UAAU,EAAf,IAAI,EAAc,KAAb,CAAU;IAEfgB,qBAAA,CAAKX,UAAU,EAAf,IAAI,EAAc,CAAb,CAAU;IACfW,qBAAA,CAAKV,OAAO,EAAZ,IAAI,EAAW,IAAIgB,GAAG,EAAjB,CAAO;IAEZN,qBAAA,CAAKT,gBAAgB,EAArB,IAAI,EAAoB,KAAnB,CAAgB;EACzB;EAEA,IAAIZ,eAAeA,CAAA;IAAa,OAAO4B,qBAAA,CAAKf,QAAQ,EAAb,IAAK,CAAQ,CAACb,eAAe;EAAE;EAEtE;;;;EAIA,IAAI1B,QAAQA,CAAA;IAAW,OAAO,IAAI;EAAE;EAEpC;;;EAGA,IAAIuD,OAAOA,CAAA;IACP,OAAOjF,KAAK,CAACqB,IAAI,CAAC2D,qBAAA,CAAKzB,QAAQ,EAAb,IAAK,CAAQ,CAAChC,MAAM,EAAE,CAAC;EAC7C;EAEA;;;EAGA2D,YAAYA,CAACC,MAA8B;IACvC,IAAIH,qBAAA,CAAKzB,QAAQ,EAAb,IAAK,CAAQ,CAAC6B,GAAG,CAACD,MAAM,CAACzE,IAAI,CAAC,EAAE;MAChC,MAAM,IAAIiB,KAAK,oCAAA9E,MAAA,CAAqCsI,MAAM,CAACzE,IAAK,MAAG,CAAC;;IAExEsE,qBAAA,CAAKzB,QAAQ,EAAb,IAAK,CAAQ,CAAC8B,GAAG,CAACF,MAAM,CAACzE,IAAI,EAAGyE,MAAM,CAACG,OAAO,CAAC,IAAI,CAAC,CAAC;IACrD,OAAO,IAAI;EACf;EAEA;;;EAGAC,SAASA,CAA4D7E,IAAY;IAC7E,OAAWsE,qBAAA,CAAKzB,QAAQ,EAAb,IAAK,CAAQ,CAAC6B,GAAG,CAAC1E,IAAI,CAAC,IAAK,IAAI;EAC/C;EAEA;;;;EAIA,IAAI8E,eAAeA,CAAA;IAAc,OAAOR,qBAAA,CAAKhB,gBAAgB,EAArB,IAAK,CAAgB;EAAE;EAC/D,IAAIwB,eAAeA,CAAClG,KAAc;IAAImF,qBAAA,CAAKT,gBAAgB,EAArB,IAAI,EAAoB,CAAC,CAAC1E,KAArB,CAAgB;EAAY;EA4BvE;;;EAGA,MAAMmG,aAAaA,CAACC,EAA4B,EAAEC,QAAgB,EAAEC,IAAmB;IACnF,IAAI,IAAI,CAACJ,eAAe,IAAII,IAAI,CAAChD,MAAM,KAAK,CAAC,IAAI8C,EAAE,CAACG,EAAE,IAAI,IAAI,EAAE;MAAE,OAAO,IAAI;;IAE7E,MAAMC,MAAM,GAAGJ,EAAE,CAACG,EAAE,CAAC9F,WAAW,EAAE;IAClC,MAAMgG,IAAI,GAAGJ,QAAQ,CAAC5F,WAAW,EAAE;IAEnC,MAAMiG,aAAa,GAAkB,EAAG;IAExC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,IAAI,CAAChD,MAAM,EAAEqD,CAAC,EAAE,EAAE;MAClC,MAAMC,GAAG,GAAGN,IAAI,CAACK,CAAC,CAAC;MAEnB;MACA,MAAME,IAAI,GAAGD,GAAG,CAACE,OAAO,CAAC,UAAU,EAAEN,MAAM,CAAC,CAACM,OAAO,CAAC,QAAQ,EAAEL,IAAI,CAAC;MAEpE;MACA;MAEA;MACA;MACA;MACA;MACA,MAAMM,OAAO,GAAG,IAAI3I,YAAY,CAACyI,IAAI,CAAC;MACtC,IAAID,GAAG,CAACI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;QAC9BD,OAAO,CAACE,IAAI,GAAG;UAAER,IAAI;UAAED;QAAM,CAAE;;MAGnC,IAAI,CAAChB,IAAI,CAAC,OAAO,EAAE;QAAE0B,MAAM,EAAE,0BAA0B;QAAEH,OAAO;QAAEI,KAAK,EAAER,CAAC;QAAEL;MAAI,CAAE,CAAC;MAEnF,IAAIc,YAAY,GAAG,eAAe;MAElC,MAAMC,IAAI,GAAG,MAAMN,OAAO,CAACO,IAAI,EAAE;MACjC,IAAI;QACC,MAAMC,MAAM,GAAGF,IAAI,CAACG,QAAQ;QAC5B,IAAID,MAAM,CAACd,IAAI,EAAE;UACb,IAAI,CAACjB,IAAI,CAAC,OAAO,EAAE;YAAE0B,MAAM,EAAE,4BAA4B;YAAEH,OAAO;YAAEQ;UAAM,CAAE,CAAC;UAC7E,OAAOA,MAAM,CAACd,IAAI;;QAEtB,IAAIc,MAAM,CAACE,OAAO,EAAE;UAAEL,YAAY,GAAGG,MAAM,CAACE,OAAO;;QACnD,IAAI,CAACjC,IAAI,CAAC,OAAO,EAAE;UAAE0B,MAAM,EAAE,2BAA2B;UAAEH,OAAO;UAAEQ;QAAM,CAAE,CAAC;OAChF,CAAC,OAAOG,KAAK,EAAE;MAEhB;MACAxJ,MAAM,CAACmJ,IAAI,CAACM,UAAU,GAAG,GAAG,IAAIN,IAAI,CAACM,UAAU,IAAI,GAAG,2CAAApK,MAAA,CAA4C6J,YAAa,GAC3G,gBAAgB,EAAE;QAAEQ,MAAM,EAAE,sBAAsB;QAAEC,WAAW,EAAEzB,EAAE;QAAE0B,IAAI,EAAE;UAAElB,GAAG;UAAEQ;QAAY;MAAE,CAAE,CAAC;MAEvG;MACAV,aAAa,CAACtD,IAAI,CAACgE,YAAY,CAAC;;IAGpClJ,MAAM,CAAC,KAAK,0CAAAX,MAAA,CAA2CmJ,aAAa,CAAC5D,GAAG,CAAEiF,CAAC,IAAK3H,IAAI,CAACC,SAAS,CAAC0H,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAE,GAAI,gBAAgB,EAAE;MAChIJ,MAAM,EAAE,kBAAkB;MAC1BC,WAAW,EAAEzB,EAAE;MAAE0B,IAAI,EAAE;QAAExB,IAAI;QAAEI;MAAa;KAC/C,CAAC;EACN;EAEA;;;;;EAKAuB,UAAUA,CAACjI,KAAkB,EAAEqF,OAAgB;IAC3C,OAAO,IAAInG,KAAK,CAACN,WAAW,CAACoB,KAAK,CAAC,EAAE,IAAI,CAAC;EAC9C;EAEA;;;;;EAKAkI,QAAQA,CAAClI,KAAgB,EAAEqF,OAAgB;IACvC,OAAO,IAAIjG,GAAG,CAACP,SAAS,CAACmB,KAAK,CAAC,EAAE,IAAI,CAAC;EAC1C;EAEA;;;;;EAKAmI,uBAAuBA,CAACnI,KAA+B,EAAEqF,OAAgB;IACrE,OAAO,IAAIhG,kBAAkB,CAACP,wBAAwB,CAACkB,KAAK,CAAC,EAAE,IAAI,CAAC;EACxE;EAEA;;;;;EAKAoI,wBAAwBA,CAAChC,EAA6B,EAAEf,OAAgB;IACpE,OAAO,IAAI/F,mBAAmB,CAACP,yBAAyB,CAACqH,EAAE,CAAC,EAAE,IAAI,CAAC;EACvE;EAEA;;;;;;EAMAiC,cAAcA,CAAA;IACVnK,MAAM,CAAC,KAAK,EAAE,iCAAiC,EAAE,uBAAuB,EAAE;MACtEoK,SAAS,EAAE;KACd,CAAC;EACN;EAEA;;;;;;EAMA,MAAMC,QAAQA,CAAUC,GAAyB;IAC7CtK,MAAM,CAAC,KAAK,yBAAAX,MAAA,CAA0BiL,GAAG,CAACC,MAAO,GAAI,uBAAuB,EAAE;MAC1EH,SAAS,EAAEE,GAAG,CAACC,MAAM;MACrBX,IAAI,EAAEU;KACT,CAAC;EACN;EAEA;EAEA,MAAME,cAAcA,CAAA;IAChB,MAAMC,WAAW,GAAG7K,SAAS,CAAC,MAAM8K,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAAU;MAAEJ,MAAM,EAAE;IAAgB,CAAE,CAAC,EAAE,WAAW,CAAC;IAC7F,IAAI/C,qBAAA,CAAKnB,gBAAgB,EAArB,IAAK,CAAgB,IAAI,CAAC,EAAE;MAAEY,qBAAA,CAAKZ,gBAAgB,EAArB,IAAI,EAAoBoE,WAAnB,CAAgB;;IACvD,OAAOA,WAAW;EACtB;EAEA;;;;;EAKAG,WAAWA,CAACjG,OAAoB;IAC5B,OAAO3F,cAAc,CAAC2F,OAAO,EAAE,IAAI,CAAC;EACxC;EAEA;;;;EAIAkG,YAAYA,CAACC,QAAmB;IAC5B,IAAIA,QAAQ,IAAI,IAAI,EAAE;MAAE,OAAO,QAAQ;;IAEvC,QAAQA,QAAQ;MACZ,KAAK,UAAU;QACX,OAAO,KAAK;MAChB,KAAK,WAAW;MAChB,KAAK,QAAQ;MACb,KAAK,SAAS;MACd,KAAK,MAAM;QACP,OAAOA,QAAQ;;IAIvB,IAAIrL,WAAW,CAACqL,QAAQ,CAAC,EAAE;MACvB,IAAIrL,WAAW,CAACqL,QAAQ,EAAE,EAAE,CAAC,EAAE;QAAE,OAAOA,QAAQ;;MAChD,OAAO1K,UAAU,CAAC0K,QAAQ,CAAC;;IAG/B,IAAI,OAAOA,QAAS,KAAK,QAAQ,EAAE;MAC/BA,QAAQ,GAAGlL,SAAS,CAACkL,QAAQ,EAAE,UAAU,CAAC;;IAG9C,IAAI,OAAOA,QAAS,KAAK,QAAQ,EAAE;MAC/B,IAAIA,QAAQ,IAAI,CAAC,EAAE;QAAE,OAAO1K,UAAU,CAAC0K,QAAQ,CAAC;;MAChD,IAAItD,qBAAA,CAAKnB,gBAAgB,EAArB,IAAK,CAAgB,IAAI,CAAC,EAAE;QAAE,OAAOjG,UAAU,CAACoH,qBAAA,CAAKnB,gBAAgB,EAArB,IAAK,CAAgB,GAAGyE,QAAQ,CAAC;;MACrF,OAAO,IAAI,CAACN,cAAc,EAAE,CAACzI,IAAI,CAAEgJ,CAAC,IAAK3K,UAAU,CAAC2K,CAAC,GAAWD,QAAQ,CAAC,CAAC;;IAG9E7K,cAAc,CAAC,KAAK,EAAE,kBAAkB,EAAE,UAAU,EAAE6K,QAAQ,CAAC;EACnE;EAEA;;;;;EAKAE,UAAUA,CAACtG,MAAkC;IAEzC;IACA,MAAMN,MAAM,GAAG,CAACM,MAAM,CAACN,MAAM,IAAI,EAAG,EAAEQ,GAAG,CAAEC,CAAC,IAAI;MAC5C,IAAIA,CAAC,IAAI,IAAI,EAAE;QAAE,OAAO,IAAI;;MAC5B,IAAIrC,KAAK,CAACC,OAAO,CAACoC,CAAC,CAAC,EAAE;QAClB,OAAOlB,SAAS,CAACkB,CAAC,CAACD,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACtC,WAAW,EAAE,CAAC,CAAC;;MAEnD,OAAOsC,CAAC,CAACtC,WAAW,EAAE;IAC1B,CAAC,CAAC;IAEF,MAAM0I,SAAS,GAAI,WAAW,IAAIvG,MAAM,GAAIA,MAAM,CAACuG,SAAS,GAAEC,SAAS;IAEvE,MAAM9D,OAAO,GAAGA,CAAC+D,QAAuB,EAAEC,SAAkB,EAAEC,OAAgB,KAAI;MAC9E,IAAI1G,OAAO,GAAuCuG,SAAS;MAC3D,QAAQC,QAAQ,CAAC/F,MAAM;QACnB,KAAK,CAAC;UAAE;QACR,KAAK,CAAC;UACFT,OAAO,GAAGwG,QAAQ,CAAC,CAAC,CAAC;UACrB;QACJ;UACIA,QAAQ,CAACvI,IAAI,EAAE;UACf+B,OAAO,GAAGwG,QAAQ;;MAG1B,IAAIF,SAAS,EAAE;QACX,IAAIG,SAAS,IAAI,IAAI,IAAIC,OAAO,IAAI,IAAI,EAAE;UACtC,MAAM,IAAIlH,KAAK,CAAC,gBAAgB,CAAC;;;MAIzC,MAAMO,MAAM,GAAQ,EAAG;MACvB,IAAIC,OAAO,EAAE;QAAED,MAAM,CAACC,OAAO,GAAGA,OAAO;;MACvC,IAAIP,MAAM,CAACgB,MAAM,EAAE;QAAEV,MAAM,CAACN,MAAM,GAAGA,MAAM;;MAC3C,IAAIgH,SAAS,EAAE;QAAE1G,MAAM,CAAC0G,SAAS,GAAGA,SAAS;;MAC7C,IAAIC,OAAO,EAAE;QAAE3G,MAAM,CAAC2G,OAAO,GAAGA,OAAO;;MACvC,IAAIJ,SAAS,EAAE;QAAEvG,MAAM,CAACuG,SAAS,GAAGA,SAAS;;MAE7C,OAAOvG,MAAM;IACjB,CAAC;IAED;IACA,IAAIC,OAAO,GAAoC,EAAG;IAClD,IAAID,MAAM,CAACC,OAAO,EAAE;MAChB,IAAInC,KAAK,CAACC,OAAO,CAACiC,MAAM,CAACC,OAAO,CAAC,EAAE;QAC/B,KAAK,MAAMM,IAAI,IAAIP,MAAM,CAACC,OAAO,EAAE;UAAEA,OAAO,CAACO,IAAI,CAAC,IAAI,CAAC0F,WAAW,CAAC3F,IAAI,CAAC,CAAC;;OAC5E,MAAM;QACHN,OAAO,CAACO,IAAI,CAAC,IAAI,CAAC0F,WAAW,CAAClG,MAAM,CAACC,OAAO,CAAC,CAAC;;;IAItD,IAAIyG,SAAS,GAAyCF,SAAS;IAC/D,IAAI,WAAW,IAAIxG,MAAM,EAAE;MAAE0G,SAAS,GAAG,IAAI,CAACP,YAAY,CAACnG,MAAM,CAAC0G,SAAS,CAAC;;IAE5E,IAAIC,OAAO,GAAyCH,SAAS;IAC7D,IAAI,SAAS,IAAIxG,MAAM,EAAE;MAAE2G,OAAO,GAAG,IAAI,CAACR,YAAY,CAACnG,MAAM,CAAC2G,OAAO,CAAC;;IAEtE,IAAI1G,OAAO,CAACD,MAAM,CAAEa,CAAC,IAAM,OAAOA,CAAE,KAAK,QAAS,CAAC,CAACH,MAAM,IACrDgG,SAAS,IAAI,IAAI,IAAI,OAAOA,SAAU,KAAK,QAAS,IACpDC,OAAO,IAAI,IAAI,IAAI,OAAOA,OAAQ,KAAK,QAAS,EAAE;MAEnD,OAAOhG,OAAO,CAACC,GAAG,CAAC,CAAED,OAAO,CAACC,GAAG,CAACX,OAAO,CAAC,EAAEyG,SAAS,EAAEC,OAAO,CAAE,CAAC,CAACtJ,IAAI,CAAEsH,MAAM,IAAI;QAC7E,OAAOjC,OAAO,CAACiC,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;MACnD,CAAC,CAAC;;IAGN,OAAOjC,OAAO,CAAgBzC,OAAO,EAAEyG,SAAS,EAAEC,OAAO,CAAC;EAC9D;EAEA;;;;;EAKAC,sBAAsBA,CAACC,QAA4B;IAC/C,MAAM1C,OAAO,GAA6B9H,WAAW,CAACwK,QAAQ,CAAC;IAE/D,MAAMxG,QAAQ,GAAyB,EAAG;IAC1C,CAAE,IAAI,EAAE,MAAM,CAAE,CAACI,OAAO,CAAEpC,GAAG,IAAI;MAC7B,IAAU8F,OAAQ,CAAC9F,GAAG,CAAC,IAAI,IAAI,EAAE;QAAE;;MAEnC,MAAMkC,IAAI,GAAGjG,cAAc,CAAO6J,OAAQ,CAAC9F,GAAG,CAAC,EAAE,IAAI,CAAC;MACtD,IAAIlB,SAAS,CAACoD,IAAI,CAAC,EAAE;QACjBF,QAAQ,CAACG,IAAI,CAAE,kBAAK;UAAoB2D,OAAQ,CAAC9F,GAAG,CAAC,GAAG,MAAMkC,IAAI;QAAE,CAAC,CAAC,CAAE,CAAC;OAC5E,MAAM;QACG4D,OAAQ,CAAC9F,GAAG,CAAC,GAAGkC,IAAI;;IAElC,CAAC,CAAC;IAEF,IAAI4D,OAAO,CAACiC,QAAQ,IAAI,IAAI,EAAE;MAC1B,MAAMA,QAAQ,GAAG,IAAI,CAACD,YAAY,CAAChC,OAAO,CAACiC,QAAQ,CAAC;MACpD,IAAIjJ,SAAS,CAACiJ,QAAQ,CAAC,EAAE;QACrB/F,QAAQ,CAACG,IAAI,CAAE,kBAAK;UAAc2D,OAAO,CAACiC,QAAQ,GAAG,MAAMA,QAAQ;QAAE,CAAC,CAAC,CAAE,CAAC;OAC7E,MAAM;QACHjC,OAAO,CAACiC,QAAQ,GAAGA,QAAQ;;;IAInC,IAAI/F,QAAQ,CAACK,MAAM,EAAE;MACjB,OAAQ,kBAAK;QACT,MAAMC,OAAO,CAACC,GAAG,CAACP,QAAQ,CAAC;QAC3B,OAAO8D,OAAO;MAClB,CAAC,CAAC,CAAE;;IAGR,OAAOA,OAAO;EAClB;EAEA,MAAM2C,UAAUA,CAAA;IAEZ;IACA,IAAIhE,qBAAA,CAAKtB,eAAe,EAApB,IAAK,CAAe,IAAI,IAAI,EAAE;MAE9B;MACA,MAAMuF,aAAa,GAAG,CAAC,YAAW;QAC9B,IAAI;UACA,MAAMtE,OAAO,GAAG,MAAM,IAAI,CAACgD,cAAc,EAAE;UAC3C,IAAI,CAAC7C,IAAI,CAAC,SAAS,EAAEH,OAAO,EAAE,IAAI,CAAC;UACnC,OAAOA,OAAO;SACjB,CAAC,OAAOqC,KAAK,EAAE;UACZ,IAAIhC,qBAAA,CAAKtB,eAAe,EAApB,IAAK,CAAe,KAAKuF,aAAc,EAAE;YACzCxE,qBAAA,CAAKf,eAAe,EAApB,IAAI,EAAmB,IAAlB,CAAe;;UAExB,MAAMsD,KAAK;;MAEnB,CAAC,EAAC,CAAE;MAEJvC,qBAAA,CAAKf,eAAe,EAApB,IAAI,EAAmBuF,aAAlB,CAAe;MACpB,OAAO,CAAC,MAAMA,aAAa,EAAEC,KAAK,EAAE;;IAGxC,MAAMC,cAAc,GAAGnE,qBAAA,CAAKtB,eAAe,EAApB,IAAK,CAAe;IAE3C,MAAM,CAAE0F,QAAQ,EAAEC,MAAM,CAAE,GAAG,MAAMxG,OAAO,CAACC,GAAG,CAAC,CAC3CqG,cAAc,EACd,IAAI,CAACxB,cAAc,EAAE,CAAI;IAAA,CAC5B,CAAC;IAEF,IAAIyB,QAAQ,CAACE,OAAO,KAAKD,MAAM,CAACC,OAAO,EAAE;MACrC,IAAItE,qBAAA,CAAKrB,WAAW,EAAhB,IAAK,CAAW,EAAE;QAClB;QACA,IAAI,CAACmB,IAAI,CAAC,SAAS,EAAEuE,MAAM,EAAED,QAAQ,CAAC;QAEtC;QACA,IAAIpE,qBAAA,CAAKtB,eAAe,EAApB,IAAK,CAAe,KAAKyF,cAAc,EAAE;UACzC1E,qBAAA,CAAKf,eAAe,EAApB,IAAI,EAAmBb,OAAO,CAAC+B,OAAO,CAACyE,MAAM,CAAxC,CAAe;;OAE3B,MAAM;QACH;QACA7L,MAAM,CAAC,KAAK,sBAAAX,MAAA,CAAuBuM,QAAQ,CAACE,OAAQ,UAAAzM,MAAA,CAAQwM,MAAM,CAACC,OAAQ,QAAK,eAAe,EAAE;UAC7FrH,KAAK,EAAE;SACV,CAAC;;;IAIV,OAAOmH,QAAQ,CAACF,KAAK,EAAE;EAC3B;EAEA,MAAMK,UAAUA,CAAA;IACZ,MAAM5E,OAAO,GAAG,MAAM,IAAI,CAACqE,UAAU,EAAE;IAEvC,MAAMQ,cAAc,GAAG,MAAAA,CAAA,KAAW;MAC9B,MAAM;QAAEC,MAAM;QAAEC,QAAQ;QAAEC;MAAW,CAAE,GAAG,MAAM5L,iBAAiB,CAAC;QAC9D0L,MAAM,EAAEvB,iBAAA,CAAAhE,uBAAA,MAAI,EAAC0F,SAAA,CAAS,CAAAzB,IAAA,CAAd,IAAI,EAAW,QAAQ,EAAE,KAAK,CAAC;QACvCuB,QAAQ,EAAG,CAAC,YAAW;UACnB,IAAI;YACA,MAAMpK,KAAK,GAAG,MAAM4I,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAAU;cAAEJ,MAAM,EAAE;YAAa,CAAE,CAAC;YAC5D,OAAO7K,SAAS,CAACoC,KAAK,EAAE,WAAW,CAAC;WACvC,CAAC,OAAO0H,KAAK,EAAE;UAChB,OAAO,IAAI;QACf,CAAC,EAAC,CAAG;QACL2C,WAAW,EAAG,CAAC,YAAW;UACtB,IAAI;YACA,MAAMrK,KAAK,GAAG,MAAM4I,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAAU;cAAEJ,MAAM,EAAE;YAAgB,CAAE,CAAC;YAC/D,OAAO7K,SAAS,CAACoC,KAAK,EAAE,WAAW,CAAC;WACvC,CAAC,OAAO0H,KAAK,EAAE;UAChB,OAAO,IAAI;QACf,CAAC,EAAC;OACL,CAAC;MAEF,IAAI6C,YAAY,GAAkB,IAAI;MACtC,IAAIC,oBAAoB,GAAkB,IAAI;MAE9C;MACA,MAAMC,KAAK,GAAG,IAAI,CAACxC,UAAU,CAACkC,MAAM,EAAE9E,OAAO,CAAC;MAC9C,IAAIoF,KAAK,IAAIA,KAAK,CAACC,aAAa,EAAE;QAC9BF,oBAAoB,GAAIH,WAAW,IAAI,IAAI,GAAIA,WAAW,GAAExK,MAAM,CAAC,YAAY,CAAC;QAChF0K,YAAY,GAAIE,KAAK,CAACC,aAAa,GAAG9K,IAAI,GAAI4K,oBAAoB;;MAGtE,OAAO,IAAIrL,OAAO,CAACiL,QAAQ,EAAEG,YAAY,EAAEC,oBAAoB,CAAC;IACpE,CAAC;IAED;IACA,MAAM3E,MAAM,GAAiCR,OAAO,CAACY,SAAS,CAAC,kDAAkD,CAAC;IAClH,IAAIJ,MAAM,EAAE;MACR,MAAM2C,GAAG,GAAG,IAAIpK,YAAY,CAACyH,MAAM,CAACe,GAAG,CAAC;MACxC,MAAM+D,OAAO,GAAG,MAAM9E,MAAM,CAAC+E,WAAW,CAACV,cAAc,EAAE,IAAI,EAAE1B,GAAG,CAAC;MACnE,OAAO,IAAIrJ,OAAO,CAACwL,OAAO,CAACP,QAAQ,EAAEO,OAAO,CAACJ,YAAY,EAAEI,OAAO,CAACH,oBAAoB,CAAC;;IAG5F,OAAO,MAAMN,cAAc,EAAE;EACjC;EAGA,MAAMW,WAAWA,CAACC,GAAuB;IACrC,IAAI1E,EAAE,GAAG,IAAI,CAACoD,sBAAsB,CAACsB,GAAG,CAAC;IACzC,IAAI/K,SAAS,CAACqG,EAAE,CAAC,EAAE;MAAEA,EAAE,GAAG,MAAMA,EAAE;;IAClC,OAAOxI,SAAS,CAAC,MAAMgL,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAAU;MACjCJ,MAAM,EAAE,aAAa;MAAEZ,WAAW,EAAEzB;KACvC,CAAC,EAAE,WAAW,CAAC;EACpB;EA6EA,MAAMyC,IAAIA,CAACiC,GAAuB;IAC9B,MAAM;MAAE1E,EAAE;MAAE4C;IAAQ,CAAE,GAAG,MAAMvK,iBAAiB,CAAC;MAC7C2H,EAAE,EAAE,IAAI,CAACoD,sBAAsB,CAACsB,GAAG,CAAC;MACpC9B,QAAQ,EAAE,IAAI,CAACD,YAAY,CAAC+B,GAAG,CAAC9B,QAAQ;KAC3C,CAAC;IAEF,OAAO,MAAMJ,iBAAA,CAAAhE,uBAAA,MAAI,EAACmG,aAAA,CAAa,CAAAlC,IAAA,CAAlB,IAAI,EAAeD,iBAAA,CAAAhE,uBAAA,MAAI,EAACoG,KAAA,CAAK,CAAAnC,IAAA,CAAV,IAAI,EAAOzC,EAAE,EAAE4C,QAAQ,EAAE8B,GAAG,CAACG,cAAc,GAAG,CAAC,GAAE,CAAC,CAAC,EAAE;EACzF;EAEA;;EAYA,MAAMC,UAAUA,CAACrI,OAAoB,EAAEmG,QAAmB;IACtD,OAAOpL,SAAS,CAAC,MAAMgL,iBAAA,CAAAhE,uBAAA,MAAI,EAACuG,gBAAA,CAAgB,CAAAtC,IAAA,CAArB,IAAI,EAAkB;MAAEJ,MAAM,EAAE;IAAY,CAAE,EAAE5F,OAAO,EAAEmG,QAAQ,CAAC,EAAE,WAAW,CAAC;EAC3G;EAEA,MAAMoC,mBAAmBA,CAACvI,OAAoB,EAAEmG,QAAmB;IAC/D,OAAOlL,SAAS,CAAC,MAAM8K,iBAAA,CAAAhE,uBAAA,MAAI,EAACuG,gBAAA,CAAgB,CAAAtC,IAAA,CAArB,IAAI,EAAkB;MAAEJ,MAAM,EAAE;IAAqB,CAAE,EAAE5F,OAAO,EAAEmG,QAAQ,CAAC,EAAE,WAAW,CAAC;EACpH;EAEA,MAAMqC,OAAOA,CAACxI,OAAoB,EAAEmG,QAAmB;IACnD,OAAOtL,OAAO,CAAC,MAAMkL,iBAAA,CAAAhE,uBAAA,MAAI,EAACuG,gBAAA,CAAgB,CAAAtC,IAAA,CAArB,IAAI,EAAkB;MAAEJ,MAAM,EAAE;IAAS,CAAE,EAAE5F,OAAO,EAAEmG,QAAQ,CAAC,CAAC;EACzF;EAEA,MAAMsC,UAAUA,CAACzI,OAAoB,EAAE0I,SAAuB,EAAEvC,QAAmB;IAC/E,MAAMwC,QAAQ,GAAG5N,SAAS,CAAC2N,SAAS,EAAE,UAAU,CAAC;IACjD,OAAO7N,OAAO,CAAC,MAAMkL,iBAAA,CAAAhE,uBAAA,MAAI,EAACuG,gBAAA,CAAgB,CAAAtC,IAAA,CAArB,IAAI,EAAkB;MAAEJ,MAAM,EAAE,YAAY;MAAE+C;IAAQ,CAAE,EAAE3I,OAAO,EAAEmG,QAAQ,CAAC,CAAC;EACtG;EAEA;EACA,MAAMyC,oBAAoBA,CAACC,QAAgB;IACvC,MAAM;MAAE/C,WAAW;MAAElG,IAAI;MAAE4C;IAAO,CAAE,GAAG,MAAM5G,iBAAiB,CAAC;MAC1DkK,WAAW,EAAE,IAAI,CAACD,cAAc,EAAE;MAClCjG,IAAI,EAAE,IAAI,CAAC8F,QAAQ,CAAC;QAChBE,MAAM,EAAE,sBAAsB;QAC9BkD,iBAAiB,EAAED;OACtB,CAAC;MACFrG,OAAO,EAAE,IAAI,CAACqE,UAAU;KAC5B,CAAC;IAEF,MAAMtD,EAAE,GAAG9I,WAAW,CAACyE,IAAI,CAAC2J,QAAQ,CAAC;IACrC,IAAItF,EAAE,CAAC3D,IAAI,KAAKA,IAAI,EAAE;MAClB,MAAM,IAAIJ,KAAK,CAAC,wCAAwC,CAAC;;IAG7D,OAAO,IAAI,CAAC+F,wBAAwB,CAAMhC,EAAE,EAAEf,OAAO,CAAC,CAACuG,sBAAsB,CAACjD,WAAW,CAAC;EAC9F;EAmBA;EACA,MAAMkD,QAAQA,CAACpB,KAAwB,EAAEqB,WAAqB;IAC1D,MAAM;MAAEzG,OAAO;MAAE0G;IAAM,CAAE,GAAG,MAAMtN,iBAAiB,CAAC;MAChD4G,OAAO,EAAE,IAAI,CAACqE,UAAU,EAAE;MAC1BqC,MAAM,EAAEnD,iBAAA,CAAAhE,uBAAA,MAAI,EAAC0F,SAAA,CAAS,CAAAzB,IAAA,CAAd,IAAI,EAAW4B,KAAK,EAAE,CAAC,CAACqB,WAAW;KAC9C,CAAC;IACF,IAAIC,MAAM,IAAI,IAAI,EAAE;MAAE,OAAO,IAAI;;IAEjC,OAAO,IAAI,CAAC9D,UAAU,CAAC8D,MAAM,EAAE1G,OAAO,CAAC;EAC3C;EAEA,MAAM2G,cAAcA,CAACvJ,IAAY;IAC7B,MAAM;MAAE4C,OAAO;MAAE0G;IAAM,CAAE,GAAG,MAAMtN,iBAAiB,CAAC;MAChD4G,OAAO,EAAE,IAAI,CAACqE,UAAU,EAAE;MAC1BqC,MAAM,EAAEnD,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAAU;QAAEJ,MAAM,EAAE,gBAAgB;QAAEhG;MAAI,CAAE;KAC3D,CAAC;IACF,IAAIsJ,MAAM,IAAI,IAAI,EAAE;MAAE,OAAO,IAAI;;IAEjC,OAAO,IAAI,CAAC3D,wBAAwB,CAAC2D,MAAM,EAAE1G,OAAO,CAAC;EACzD;EAEA,MAAM4G,qBAAqBA,CAACxJ,IAAY;IACpC,MAAM;MAAE4C,OAAO;MAAE0G;IAAM,CAAE,GAAG,MAAMtN,iBAAiB,CAAC;MAChD4G,OAAO,EAAE,IAAI,CAACqE,UAAU,EAAE;MAC1BqC,MAAM,EAAEnD,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAAU;QAAEJ,MAAM,EAAE,uBAAuB;QAAEhG;MAAI,CAAE;KAClE,CAAC;IACF,IAAIsJ,MAAM,IAAI,IAAI,EAAE;MAAE,OAAO,IAAI;;IAEjC;IACA;IACA,IAAIA,MAAM,CAAC3B,QAAQ,IAAI,IAAI,IAAI2B,MAAM,CAACG,iBAAiB,IAAI,IAAI,EAAE;MAC7D,MAAM9F,EAAE,GAAG,MAAMwC,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAAU;QAAEJ,MAAM,EAAE,gBAAgB;QAAEhG;MAAI,CAAE,CAAC;MAClE,IAAI2D,EAAE,IAAI,IAAI,EAAE;QAAE,MAAM,IAAI/D,KAAK,CAAC,qDAAqD,CAAC;;MACxF0J,MAAM,CAACG,iBAAiB,GAAG9F,EAAE,CAACgE,QAAQ;;IAG1C,OAAO,IAAI,CAACjC,uBAAuB,CAAC4D,MAAM,EAAE1G,OAAO,CAAC;EACxD;EAEA,MAAM8G,oBAAoBA,CAAC1J,IAAY;IACnC,MAAM;MAAE8E;IAAM,CAAE,GAAG,MAAM9I,iBAAiB,CAAC;MACvC4G,OAAO,EAAE,IAAI,CAACqE,UAAU,EAAE;MAC1BnC,MAAM,EAAEqB,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAAU;QAAEJ,MAAM,EAAE,sBAAsB;QAAEhG;MAAI,CAAE;KACjE,CAAC;IACF,IAAI8E,MAAM,IAAI,IAAI,EAAE;MAAE,OAAO,IAAI;;IACjC,OAAO7J,OAAO,CAAC6J,MAAM,CAAC;EAC1B;EAEA;EACA,MAAM6E,OAAOA,CAACC,OAAmC;IAC7C,IAAIzJ,MAAM,GAAG,IAAI,CAACsG,UAAU,CAACmD,OAAO,CAAC;IACrC,IAAItM,SAAS,CAAC6C,MAAM,CAAC,EAAE;MAAEA,MAAM,GAAG,MAAMA,MAAM;;IAE9C,MAAM;MAAEyC,OAAO;MAAE0G;IAAM,CAAE,GAAG,MAAMtN,iBAAiB,CAAC;MAChD4G,OAAO,EAAE,IAAI,CAACqE,UAAU,EAAE;MAC1BqC,MAAM,EAAEnD,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAA4B;QAAEJ,MAAM,EAAE,SAAS;QAAE7F;MAAM,CAAE;KACxE,CAAC;IAEF,OAAOmJ,MAAM,CAACjJ,GAAG,CAAEwJ,CAAC,IAAK,IAAI,CAACpE,QAAQ,CAACoE,CAAC,EAAEjH,OAAO,CAAC,CAAC;EACvD;EAEA;EACAkH,YAAYA,CAACvC,OAAe;IACxB9L,MAAM,CAAC,KAAK,EAAE,2CAA2C,EAAE,uBAAuB,EAAE;MAChFoK,SAAS,EAAE;KACd,CAAC;EACN;EAEA,MAAMkE,WAAWA,CAACpL,IAAY;IAC1B,OAAO,MAAMzC,WAAW,CAAC8N,QAAQ,CAAC,IAAI,EAAErL,IAAI,CAAC;EACjD;EAEA,MAAMsL,SAASA,CAACtL,IAAY;IACxB,MAAMuL,QAAQ,GAAG,MAAM,IAAI,CAACH,WAAW,CAACpL,IAAI,CAAC;IAC7C,IAAIuL,QAAQ,EAAE;MAAE,OAAO,MAAMA,QAAQ,CAACD,SAAS,EAAE;;IACjD,OAAO,IAAI;EACf;EAEA,MAAME,WAAWA,CAACxL,IAAY;IAC1B,MAAMuL,QAAQ,GAAG,MAAM,IAAI,CAACH,WAAW,CAACpL,IAAI,CAAC;IAC7C,IAAIuL,QAAQ,EAAE;MAAE,OAAO,MAAMA,QAAQ,CAAC1P,UAAU,EAAE;;IAClD,OAAO,IAAI;EACf;EAEA,MAAM4P,aAAaA,CAAChK,OAAe;IAC/BA,OAAO,GAAG5F,UAAU,CAAC4F,OAAO,CAAC;IAC7B,MAAMiK,IAAI,GAAGzP,QAAQ,CAACwF,OAAO,CAACkK,SAAS,CAAC,CAAC,CAAC,CAACtM,WAAW,EAAE,GAAG,eAAe,CAAC;IAE3E,IAAI;MAEA,MAAMuM,OAAO,GAAG,MAAMrO,WAAW,CAACsO,aAAa,CAAC,IAAI,CAAC;MACrD,MAAMC,WAAW,GAAG,IAAI9P,QAAQ,CAAC4P,OAAO,EAAE,CACtC,mDAAmD,CACtD,EAAE,IAAI,CAAC;MAER,MAAML,QAAQ,GAAG,MAAMO,WAAW,CAACP,QAAQ,CAACG,IAAI,CAAC;MACjD,IAAIH,QAAQ,IAAI,IAAI,IAAIA,QAAQ,KAAKxP,WAAW,EAAE;QAAE,OAAO,IAAI;;MAE/D,MAAMgQ,gBAAgB,GAAG,IAAI/P,QAAQ,CAACuP,QAAQ,EAAE,CAC5C,8CAA8C,CACjD,EAAE,IAAI,CAAC;MACR,MAAMvL,IAAI,GAAG,MAAM+L,gBAAgB,CAAC/L,IAAI,CAAC0L,IAAI,CAAC;MAE9C;MACA,MAAMM,KAAK,GAAG,MAAM,IAAI,CAACR,WAAW,CAACxL,IAAI,CAAC;MAC1C,IAAIgM,KAAK,KAAKvK,OAAO,EAAE;QAAE,OAAO,IAAI;;MAEpC,OAAOzB,IAAI;KAEd,CAAC,OAAOsG,KAAK,EAAE;MACZ;MACA,IAAI1J,OAAO,CAAC0J,KAAK,EAAE,UAAU,CAAC,IAAIA,KAAK,CAAC1H,KAAK,KAAK,IAAI,EAAE;QACpD,OAAO,IAAI;;MAGf;MACA,IAAIhC,OAAO,CAAC0J,KAAK,EAAE,gBAAgB,CAAC,EAAE;QAAE,OAAO,IAAI;;MAEnD,MAAMA,KAAK;;IAGf,OAAO,IAAI;EACf;EAEA,MAAM2F,kBAAkBA,CAAC5K,IAAY,EAAE6K,SAAyB,EAAEC,OAAuB;IACrF,MAAMC,QAAQ,GAAIF,SAAS,IAAI,IAAI,GAAIA,SAAS,GAAE,CAAC;IACnD,IAAIE,QAAQ,KAAK,CAAC,EAAE;MAAE,OAAO,IAAI,CAACvB,qBAAqB,CAACxJ,IAAI,CAAC;;IAE7D,OAAO,IAAIc,OAAO,CAAC,OAAO+B,OAAO,EAAEmI,MAAM,KAAI;MACzC,IAAIC,KAAK,GAAiB,IAAI;MAE9B,MAAMC,QAAQ,GAAI,MAAOhF,WAAmB,IAAI;QAC5C,IAAI;UACA,MAAMiF,OAAO,GAAG,MAAM,IAAI,CAAC3B,qBAAqB,CAACxJ,IAAI,CAAC;UACtD,IAAImL,OAAO,IAAI,IAAI,EAAE;YACjB,IAAIjF,WAAW,GAAGiF,OAAO,CAACjF,WAAW,GAAG,CAAC,IAAI6E,QAAQ,EAAE;cACnDlI,OAAO,CAACsI,OAAO,CAAC;cAChB;cACA,IAAIF,KAAK,EAAE;gBACPG,YAAY,CAACH,KAAK,CAAC;gBACnBA,KAAK,GAAG,IAAI;;cAEhB;;;SAGX,CAAC,OAAOhG,KAAK,EAAE;UACZoG,OAAO,CAACC,GAAG,CAAC,KAAK,EAAErG,KAAK,CAAC;;QAE7B,IAAI,CAACsG,IAAI,CAAC,OAAO,EAAEL,QAAQ,CAAC;MAChC,CAAE;MAEF,IAAIJ,OAAO,IAAI,IAAI,EAAE;QACjBG,KAAK,GAAGnI,UAAU,CAAC,MAAK;UACpB,IAAImI,KAAK,IAAI,IAAI,EAAE;YAAE;;UACrBA,KAAK,GAAG,IAAI;UACZ,IAAI,CAACO,GAAG,CAAC,OAAO,EAAEN,QAAQ,CAAC;UAC3BF,MAAM,CAACxP,SAAS,CAAC,SAAS,EAAE,SAAS,EAAE;YAAE2J,MAAM,EAAE;UAAS,CAAE,CAAC,CAAC;QAClE,CAAC,EAAE2F,OAAO,CAAC;;MAGfI,QAAQ,CAAC,MAAM,IAAI,CAACjF,cAAc,EAAE,CAAC;IACzC,CAAC,CAAC;EACN;EAEA,MAAMwF,YAAYA,CAAClF,QAAmB;IAClC9K,MAAM,CAAC,KAAK,EAAE,qBAAqB,EAAE,iBAAiB,EAAE;MACpDoK,SAAS,EAAE;KACd,CAAC;EACN;EAEA;;;EAGA6F,aAAaA,CAACC,OAAe;IACzB,MAAMV,KAAK,GAAGhI,qBAAA,CAAKjB,OAAO,EAAZ,IAAK,CAAO,CAACqB,GAAG,CAACsI,OAAO,CAAC;IACvC,IAAI,CAACV,KAAK,EAAE;MAAE;;IACd,IAAIA,KAAK,CAACA,KAAK,EAAE;MAAEG,YAAY,CAACH,KAAK,CAACA,KAAK,CAAC;;IAC5ChI,qBAAA,CAAKjB,OAAO,EAAZ,IAAK,CAAO,CAAC4J,MAAM,CAACD,OAAO,CAAC;EAChC;EAEA;;;;;;;;EAQAE,WAAWA,CAACC,KAAiB,EAAEhB,OAAgB;IAAA,IAAAiB,eAAA,EAAAC,gBAAA;IAC3C,IAAIlB,OAAO,IAAI,IAAI,EAAE;MAAEA,OAAO,GAAG,CAAC;;IAClC,MAAMa,OAAO,IAAGjJ,qBAAA,CAAKX,UAAU,EAAf,IAAI,GAAAgK,eAAA,GAAJ9I,qBAAA,CAAKlB,UAAU,EAAf,IAAK,CAAU,EAAAiK,gBAAA,GAAAD,eAAA,IAAAA,eAAA,CAAV,CAAU,EAAAC,gBAAA,CAAE;IACjC,MAAMC,IAAI,GAAGA,CAAA,KAAK;MACdhJ,qBAAA,CAAKjB,OAAO,EAAZ,IAAK,CAAO,CAAC4J,MAAM,CAACD,OAAO,CAAC;MAC5BG,KAAK,EAAE;IACX,CAAC;IAED,IAAI,IAAI,CAACI,MAAM,EAAE;MACbjJ,qBAAA,CAAKjB,OAAO,EAAZ,IAAK,CAAO,CAACsB,GAAG,CAACqI,OAAO,EAAE;QAAEV,KAAK,EAAE,IAAI;QAAEgB,IAAI;QAAEE,IAAI,EAAErB;MAAO,CAAE,CAAC;KAClE,MAAM;MACH,MAAMG,KAAK,GAAGnI,UAAU,CAACmJ,IAAI,EAAEnB,OAAO,CAAC;MACvC7H,qBAAA,CAAKjB,OAAO,EAAZ,IAAK,CAAO,CAACsB,GAAG,CAACqI,OAAO,EAAE;QAAEV,KAAK;QAAEgB,IAAI;QAAEE,IAAI,EAAElL,OAAO;MAAE,CAAE,CAAC;;IAG/D,OAAO0K,OAAO;EAClB;EAEA;;;EAGAS,kBAAkBA,CAACH,IAA6B;IAC5C,KAAK,MAAMI,GAAG,IAAIpJ,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,CAAC9B,MAAM,EAAE,EAAE;MACnCyM,IAAI,CAACI,GAAG,CAACC,UAAU,CAAC;;EAE5B;EAEA;;;;EAIAC,cAAcA,CAACF,GAAiB;IAC5B,QAAQA,GAAG,CAACvM,IAAI;MACZ,KAAK,OAAO;MACZ,KAAK,OAAO;MACZ,KAAK,SAAS;QACV,OAAO,IAAIrB,mBAAmB,CAAC4N,GAAG,CAACvM,IAAI,CAAC;MAC5C,KAAK,OAAO;QAAE;UACV,MAAMwM,UAAU,GAAG,IAAIxP,sBAAsB,CAAC,IAAI,CAAC;UACnDwP,UAAU,CAACjL,eAAe,GAAG,IAAI,CAACA,eAAe;UACjD,OAAOiL,UAAU;;MAErB,KAAK,MAAM;MAAE,KAAK,WAAW;QACzB,OAAO,IAAIvP,yBAAyB,CAAC,IAAI,EAAEsP,GAAG,CAACvM,IAAI,CAAC;MACxD,KAAK,OAAO;QACR,OAAO,IAAI9C,sBAAsB,CAAC,IAAI,EAAEqP,GAAG,CAAClM,MAAM,CAAC;MACvD,KAAK,aAAa;QACd,OAAO,IAAIjD,4BAA4B,CAAC,IAAI,EAAEmP,GAAG,CAACrM,IAAI,CAAC;MAC3D,KAAK,QAAQ;QACT,OAAO,IAAI/C,uBAAuB,CAAC,IAAI,EAAEoP,GAAG,CAAClM,MAAM,CAAC;;IAG5D,MAAM,IAAIP,KAAK,uBAAA9E,MAAA,CAAwBuR,GAAG,CAACvM,IAAK,CAAE,CAAC;EACvD;EAEA;;;;;;;;;EASA0M,kBAAkBA,CAACC,MAAkB,EAAEC,MAAkB;IACrD,KAAK,MAAML,GAAG,IAAIpJ,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,CAAC9B,MAAM,EAAE,EAAE;MACnC,IAAI6M,GAAG,CAACC,UAAU,KAAKG,MAAM,EAAE;QAC3B,IAAIJ,GAAG,CAACM,OAAO,EAAE;UAAEN,GAAG,CAACC,UAAU,CAACxN,IAAI,EAAE;;QACxCuN,GAAG,CAACC,UAAU,GAAGI,MAAM;QACvB,IAAIL,GAAG,CAACM,OAAO,EAAE;UAAED,MAAM,CAAC7N,KAAK,EAAE;;QACjC,IAAIoE,qBAAA,CAAKxB,YAAY,EAAjB,IAAK,CAAY,IAAI,IAAI,EAAE;UAAEiL,MAAM,CAAC3N,KAAK,CAACkE,qBAAA,CAAKxB,YAAY,EAAjB,IAAK,CAAY,CAAC;;QAChE;;;EAGZ;EA+BA,MAAMmL,EAAEA,CAAC1M,KAAoB,EAAEgL,QAAkB;IAC7C,MAAMmB,GAAG,GAAG,MAAMlG,iBAAA,CAAAhE,uBAAA,MAAI,EAAC0K,OAAA,CAAO,CAAAzG,IAAA,CAAZ,IAAI,EAASlG,KAAK,CAAC;IACrCmM,GAAG,CAACS,SAAS,CAACnM,IAAI,CAAC;MAAEuK,QAAQ;MAAEK,IAAI,EAAE;IAAK,CAAE,CAAC;IAC7C,IAAI,CAACc,GAAG,CAACM,OAAO,EAAE;MACdN,GAAG,CAACC,UAAU,CAACzN,KAAK,EAAE;MACtBwN,GAAG,CAACM,OAAO,GAAG,IAAI;MAClB,IAAI1J,qBAAA,CAAKxB,YAAY,EAAjB,IAAK,CAAY,IAAI,IAAI,EAAE;QAAE4K,GAAG,CAACC,UAAU,CAACvN,KAAK,CAACkE,qBAAA,CAAKxB,YAAY,EAAjB,IAAK,CAAY,CAAC;;;IAE5E,OAAO,IAAI;EACf;EAEA,MAAM8J,IAAIA,CAACrL,KAAoB,EAAEgL,QAAkB;IAC/C,MAAMmB,GAAG,GAAG,MAAMlG,iBAAA,CAAAhE,uBAAA,MAAI,EAAC0K,OAAA,CAAO,CAAAzG,IAAA,CAAZ,IAAI,EAASlG,KAAK,CAAC;IACrCmM,GAAG,CAACS,SAAS,CAACnM,IAAI,CAAC;MAAEuK,QAAQ;MAAEK,IAAI,EAAE;IAAI,CAAE,CAAC;IAC5C,IAAI,CAACc,GAAG,CAACM,OAAO,EAAE;MACdN,GAAG,CAACC,UAAU,CAACzN,KAAK,EAAE;MACtBwN,GAAG,CAACM,OAAO,GAAG,IAAI;MAClB,IAAI1J,qBAAA,CAAKxB,YAAY,EAAjB,IAAK,CAAY,IAAI,IAAI,EAAE;QAAE4K,GAAG,CAACC,UAAU,CAACvN,KAAK,CAACkE,qBAAA,CAAKxB,YAAY,EAAjB,IAAK,CAAY,CAAC;;;IAE5E,OAAO,IAAI;EACf;EAEA,MAAMsB,IAAIA,CAAC7C,KAAoB,EAAqB;IAAA,SAAA6M,IAAA,GAAAC,SAAA,CAAAnM,MAAA,EAAhBoM,IAAgB,OAAAhP,KAAA,CAAA8O,IAAA,OAAAA,IAAA,WAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;MAAhBD,IAAgB,CAAAC,IAAA,QAAAF,SAAA,CAAAE,IAAA;IAAA;IAChD,MAAMb,GAAG,GAAG,MAAMlG,iBAAA,CAAAhE,uBAAA,MAAI,EAACgL,OAAA,CAAO,CAAA/G,IAAA,CAAZ,IAAI,EAASlG,KAAK,EAAE+M,IAAI,CAAC;IAC3C;IACA;IACA,IAAI,CAACZ,GAAG,IAAIA,GAAG,CAACS,SAAS,CAACjM,MAAM,KAAK,CAAC,EAAE;MAAE,OAAO,KAAK;;IAAG;IAEzD,MAAMuM,KAAK,GAAGf,GAAG,CAACS,SAAS,CAACjM,MAAM;IAClCwL,GAAG,CAACS,SAAS,GAAGT,GAAG,CAACS,SAAS,CAAC3M,MAAM,CAACkN,IAAA,IAAuB;MAAA,IAAtB;QAAEnC,QAAQ;QAAEK;MAAI,CAAE,GAAA8B,IAAA;MACpD,MAAMC,OAAO,GAAG,IAAIvR,YAAY,CAAC,IAAI,EAAGwP,IAAI,GAAG,IAAI,GAAEL,QAAQ,EAAGhL,KAAK,CAAC;MACtE,IAAI;QACAgL,QAAQ,CAAC9E,IAAI,CAAC,IAAI,EAAE,GAAG6G,IAAI,EAAEK,OAAO,CAAC;OACxC,CAAC,OAAMrI,KAAK,EAAE;MACf,OAAO,CAACsG,IAAI;IAChB,CAAC,CAAC;IAEF,IAAIc,GAAG,CAACS,SAAS,CAACjM,MAAM,KAAK,CAAC,EAAE;MAC5B,IAAIwL,GAAG,CAACM,OAAO,EAAE;QAAEN,GAAG,CAACC,UAAU,CAACxN,IAAI,EAAE;;MACxCmE,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,CAACsK,MAAM,CAACS,GAAG,CAACtM,GAAG,CAAC;;IAG9B,OAAQqN,KAAK,GAAG,CAAC;EACrB;EAEA,MAAMG,aAAaA,CAACrN,KAAqB;IACrC,IAAIA,KAAK,EAAE;MACP,MAAMmM,GAAG,GAAG,MAAMlG,iBAAA,CAAAhE,uBAAA,MAAI,EAACgL,OAAA,CAAO,CAAA/G,IAAA,CAAZ,IAAI,EAASlG,KAAK,CAAC;MACrC,IAAI,CAACmM,GAAG,EAAE;QAAE,OAAO,CAAC;;MACpB,OAAOA,GAAG,CAACS,SAAS,CAACjM,MAAM;;IAG/B,IAAI2M,KAAK,GAAG,CAAC;IACb,KAAK,MAAM;MAAEV;IAAS,CAAE,IAAI7J,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,CAAC9B,MAAM,EAAE,EAAE;MAC7CgO,KAAK,IAAIV,SAAS,CAACjM,MAAM;;IAE7B,OAAO2M,KAAK;EAChB;EAEA,MAAMV,SAASA,CAAC5M,KAAqB;IACjC,IAAIA,KAAK,EAAE;MACP,MAAMmM,GAAG,GAAG,MAAMlG,iBAAA,CAAAhE,uBAAA,MAAI,EAACgL,OAAA,CAAO,CAAA/G,IAAA,CAAZ,IAAI,EAASlG,KAAK,CAAC;MACrC,IAAI,CAACmM,GAAG,EAAE;QAAE,OAAQ,EAAG;;MACvB,OAAOA,GAAG,CAACS,SAAS,CAACzM,GAAG,CAACoN,KAAA;QAAA,IAAC;UAAEvC;QAAQ,CAAE,GAAAuC,KAAA;QAAA,OAAKvC,QAAQ;MAAA,EAAC;;IAExD,IAAIpG,MAAM,GAAoB,EAAG;IACjC,KAAK,MAAM;MAAEgI;IAAS,CAAE,IAAI7J,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,CAAC9B,MAAM,EAAE,EAAE;MAC7CsF,MAAM,GAAGA,MAAM,CAAChK,MAAM,CAACgS,SAAS,CAACzM,GAAG,CAACqN,KAAA;QAAA,IAAC;UAAExC;QAAQ,CAAE,GAAAwC,KAAA;QAAA,OAAKxC,QAAQ;MAAA,EAAC,CAAC;;IAErE,OAAOpG,MAAM;EACjB;EAEA,MAAM0G,GAAGA,CAACtL,KAAoB,EAAEgL,QAAmB;IAC/C,MAAMmB,GAAG,GAAG,MAAMlG,iBAAA,CAAAhE,uBAAA,MAAI,EAACgL,OAAA,CAAO,CAAA/G,IAAA,CAAZ,IAAI,EAASlG,KAAK,CAAC;IACrC,IAAI,CAACmM,GAAG,EAAE;MAAE,OAAO,IAAI;;IAEvB,IAAInB,QAAQ,EAAE;MACV,MAAMxG,KAAK,GAAG2H,GAAG,CAACS,SAAS,CAACzM,GAAG,CAACsN,KAAA;QAAA,IAAC;UAAEzC;QAAQ,CAAE,GAAAyC,KAAA;QAAA,OAAKzC,QAAQ;MAAA,EAAC,CAAC3G,OAAO,CAAC2G,QAAQ,CAAC;MAC7E,IAAIxG,KAAK,IAAI,CAAC,EAAE;QAAE2H,GAAG,CAACS,SAAS,CAACc,MAAM,CAAClJ,KAAK,EAAE,CAAC,CAAC;;;IAGpD,IAAI,CAACwG,QAAQ,IAAImB,GAAG,CAACS,SAAS,CAACjM,MAAM,KAAK,CAAC,EAAE;MACzC,IAAIwL,GAAG,CAACM,OAAO,EAAE;QAAEN,GAAG,CAACC,UAAU,CAACxN,IAAI,EAAE;;MACxCmE,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,CAACsK,MAAM,CAACS,GAAG,CAACtM,GAAG,CAAC;;IAG9B,OAAO,IAAI;EACf;EAEA,MAAM8N,kBAAkBA,CAAC3N,KAAqB;IAC1C,IAAIA,KAAK,EAAE;MACP,MAAM;QAAEH,GAAG;QAAE4M,OAAO;QAAEL;MAAU,CAAE,GAAG,MAAMnG,iBAAA,CAAAhE,uBAAA,MAAI,EAAC0K,OAAA,CAAO,CAAAzG,IAAA,CAAZ,IAAI,EAASlG,KAAK,CAAC;MAC9D,IAAIyM,OAAO,EAAE;QAAEL,UAAU,CAACxN,IAAI,EAAE;;MAChCmE,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,CAACsK,MAAM,CAAC7L,GAAG,CAAC;KACzB,MAAM;MACH,KAAK,MAAM,CAAEA,GAAG,EAAE;QAAE4M,OAAO;QAAEL;MAAU,CAAE,CAAE,IAAIrJ,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,EAAE;QACvD,IAAIqL,OAAO,EAAE;UAAEL,UAAU,CAACxN,IAAI,EAAE;;QAChCmE,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,CAACsK,MAAM,CAAC7L,GAAG,CAAC;;;IAG9B,OAAO,IAAI;EACf;EAEA;EACA,MAAM+N,WAAWA,CAAC5N,KAAoB,EAAEgL,QAAkB;IACvD,OAAO,MAAM,IAAI,CAAC0B,EAAE,CAAC1M,KAAK,EAAEgL,QAAQ,CAAC;EACxC;EAEA;EACA,MAAM6C,cAAcA,CAAC7N,KAAoB,EAAEgL,QAAkB;IAC1D,OAAO,IAAI,CAACM,GAAG,CAACtL,KAAK,EAAEgL,QAAQ,CAAC;EACnC;EAEA;;;;;;;EAOA,IAAI8C,SAASA,CAAA;IACT,OAAO/K,qBAAA,CAAKvB,UAAU,EAAf,IAAK,CAAU;EAC1B;EAEA;;;;;;EAMAuM,OAAOA,CAAA;IACH;IACA,IAAI,CAACJ,kBAAkB,EAAE;IAEzB;IACA,KAAK,MAAMlC,OAAO,IAAI1I,qBAAA,CAAKjB,OAAO,EAAZ,IAAK,CAAO,CAAC7D,IAAI,EAAE,EAAE;MACvC,IAAI,CAACuN,aAAa,CAACC,OAAO,CAAC;;IAG/BjJ,qBAAA,CAAKhB,UAAU,EAAf,IAAI,EAAc,IAAb,CAAU;EACnB;EAEA;;;;;;;;;;;EAWA,IAAIwK,MAAMA,CAAA;IAAc,OAAQjJ,qBAAA,CAAKxB,YAAY,EAAjB,IAAK,CAAY,IAAI,IAAI;EAAG;EAC5D,IAAIyK,MAAMA,CAACnN,KAAc;IACrB,IAAI,CAAC,CAACA,KAAK,KAAK,IAAI,CAACmN,MAAM,EAAE;MAAE;;IAE/B,IAAI,IAAI,CAACA,MAAM,EAAE;MACb,IAAI,CAACjN,MAAM,EAAE;KAChB,MAAM;MACH,IAAI,CAACF,KAAK,CAAC,KAAK,CAAC;;EAEzB;EAEA;;;;;EAKAA,KAAKA,CAACC,eAAyB;IAC3B0D,qBAAA,CAAKZ,gBAAgB,EAArB,IAAI,EAAoB,CAAC,CAApB,CAAgB;IAErB,IAAImB,qBAAA,CAAKxB,YAAY,EAAjB,IAAK,CAAY,IAAI,IAAI,EAAE;MAC3B,IAAIwB,qBAAA,CAAKxB,YAAY,EAAjB,IAAK,CAAY,IAAI,CAAC,CAACzC,eAAe,EAAE;QAAE;;MAC9CvD,MAAM,CAAC,KAAK,EAAE,wCAAwC,EAAE,uBAAuB,EAAE;QAC7EoK,SAAS,EAAE;OACd,CAAC;;IAGN,IAAI,CAACuG,kBAAkB,CAAE8B,CAAC,IAAKA,CAAC,CAACnP,KAAK,CAACC,eAAe,CAAC,CAAC;IACxD0D,qBAAA,CAAKjB,YAAY,EAAjB,IAAI,EAAgB,CAAC,CAACzC,eAAjB,CAAY;IAEjB,KAAK,MAAMiM,KAAK,IAAIhI,qBAAA,CAAKjB,OAAO,EAAZ,IAAK,CAAO,CAACxC,MAAM,EAAE,EAAE;MACvC;MACA,IAAIyL,KAAK,CAACA,KAAK,EAAE;QAAEG,YAAY,CAACH,KAAK,CAACA,KAAK,CAAC;;MAE5C;MACAA,KAAK,CAACkB,IAAI,GAAGlL,OAAO,EAAE,GAAGgK,KAAK,CAACkB,IAAI;;EAE3C;EAEA;;;EAGAlN,MAAMA,CAAA;IACF,IAAIgE,qBAAA,CAAKxB,YAAY,EAAjB,IAAK,CAAY,IAAI,IAAI,EAAE;MAAE;;IAEjC,IAAI,CAAC2K,kBAAkB,CAAE8B,CAAC,IAAKA,CAAC,CAACjP,MAAM,EAAE,CAAC;IAC1CyD,qBAAA,CAAKjB,YAAY,EAAjB,IAAI,EAAgB,IAAf,CAAY;IACjB,KAAK,MAAMwJ,KAAK,IAAIhI,qBAAA,CAAKjB,OAAO,EAAZ,IAAK,CAAO,CAACxC,MAAM,EAAE,EAAE;MACvC;MACA,IAAIsL,OAAO,GAAGG,KAAK,CAACkB,IAAI;MACxB,IAAIrB,OAAO,GAAG,CAAC,EAAE;QAAEA,OAAO,GAAG,CAAC;;MAE9B;MACAG,KAAK,CAACkB,IAAI,GAAGlL,OAAO,EAAE;MAEtB;MACA6B,UAAU,CAACmI,KAAK,CAACgB,IAAI,EAAEnB,OAAO,CAAC;;EAEvC;;AACH,eAAAhF,SA5iC2BC,GAAyB;EAC7C,MAAM+E,OAAO,GAAG7H,qBAAA,CAAKf,QAAQ,EAAb,IAAK,CAAQ,CAACd,YAAY;EAE1C;EACA,IAAI0J,OAAO,GAAG,CAAC,EAAE;IAAE,OAAO,MAAM,IAAI,CAAChF,QAAQ,CAACC,GAAG,CAAC;;EAElD;EACA,MAAMhG,GAAG,GAAGtC,MAAM,CAACsI,GAAG,CAACC,MAAM,EAAED,GAAG,CAAC;EAEnC,IAAIoI,OAAO,GAAGlL,qBAAA,CAAKpB,aAAa,EAAlB,IAAK,CAAa,CAACwB,GAAG,CAACtD,GAAG,CAAC;EACzC,IAAI,CAACoO,OAAO,EAAE;IACVA,OAAO,GAAG,IAAI,CAACrI,QAAQ,CAACC,GAAG,CAAC;IAE5B9C,qBAAA,CAAKpB,aAAa,EAAlB,IAAK,CAAa,CAACyB,GAAG,CAACvD,GAAG,EAAEoO,OAAO,CAAC;IAEpCrL,UAAU,CAAC,MAAK;MACZ,IAAIG,qBAAA,CAAKpB,aAAa,EAAlB,IAAK,CAAa,CAACwB,GAAG,CAACtD,GAAG,CAAC,KAAKoO,OAAO,EAAE;QACzClL,qBAAA,CAAKpB,aAAa,EAAlB,IAAK,CAAa,CAAC+J,MAAM,CAAC7L,GAAG,CAAC;;IAEtC,CAAC,EAAE+K,OAAO,CAAC;;EAGf,OAAO,MAAMqD,OAAO;AACxB;AAAC,eAAA5F,MAwYW5E,EAA4B,EAAE4C,QAAgB,EAAE6H,OAAe;EACvE3S,MAAM,CAAE2S,OAAO,GAAG/Q,kBAAkB,EAAE,yCAAyC,EAAE,gBAAgB,EAAE;IAC9F8H,MAAM,EAAE,oBAAoB;IAC5BC,WAAW,EAAEhH,MAAM,CAACuE,MAAM,CAAC,EAAG,EAAEgB,EAAE,EAAE;MAAE4C,QAAQ;MAAEiC,cAAc,EAAE;IAAI,CAAE;GACzE,CAAC;EAEF;EACA,MAAMpD,WAAW,GAA6B5I,WAAW,CAACmH,EAAE,CAAC;EAE7D,IAAI;IACA,OAAO1I,OAAO,CAAC,MAAM,IAAI,CAAC6K,QAAQ,CAAC;MAAEE,MAAM,EAAE,MAAM;MAAEZ,WAAW;MAAEmB;IAAQ,CAAE,CAAC,CAAC;GAEjF,CAAC,OAAOtB,KAAU,EAAE;IACjB;IACA,IAAI,CAAC,IAAI,CAACxB,eAAe,IAAInI,eAAe,CAAC2J,KAAK,CAAC,IAAIA,KAAK,CAACjB,IAAI,IAAIoK,OAAO,IAAI,CAAC,IAAI7H,QAAQ,KAAK,QAAQ,IAAInB,WAAW,CAACtB,EAAE,IAAI,IAAI,IAAI9I,SAAS,CAACiK,KAAK,CAACjB,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,YAAY,EAAE;MAClL,MAAMA,IAAI,GAAGiB,KAAK,CAACjB,IAAI;MAEvB,MAAMqK,QAAQ,GAAG,MAAM5T,cAAc,CAAC2K,WAAW,CAACtB,EAAE,EAAE,IAAI,CAAC;MAE3D;MACA,IAAIwK,QAAkB;MACtB,IAAI;QACAA,QAAQ,GAAGC,mBAAmB,CAACvT,SAAS,CAACiK,KAAK,CAACjB,IAAI,EAAE,CAAC,CAAC,CAAC;OAC3D,CAAC,OAAOiB,KAAU,EAAE;QACjBxJ,MAAM,CAAC,KAAK,EAAEwJ,KAAK,CAACD,OAAO,EAAE,gBAAgB,EAAE;UAC3CG,MAAM,EAAE,UAAU;UAAEC,WAAW;UAAEC,IAAI,EAAE;YAAErB;UAAI;SAAI,CAAC;;MAG1D;MACAvI,MAAM,CAAC6S,QAAQ,CAACvK,MAAM,CAAC/F,WAAW,EAAE,KAAKqQ,QAAQ,CAACrQ,WAAW,EAAE,EAC3D,2BAA2B,EAAE,gBAAgB,EAAE;QAC3CyG,MAAM,EAAE,MAAM;QACdT,IAAI;QACJmB,MAAM,EAAE,gBAAgB;QACxBC,WAAW,EAAOA,WAAW;QAC7BoJ,UAAU,EAAE,IAAI;QAChBC,MAAM,EAAE;UACJC,SAAS,EAAE,qDAAqD;UAChE/P,IAAI,EAAE,gBAAgB;UACtBsO,IAAI,EAAEqB,QAAQ,CAACK;;OAEtB,CAAC;MAEN,MAAMC,UAAU,GAAG,MAAM,IAAI,CAAClL,aAAa,CAAC0B,WAAW,EAAEkJ,QAAQ,CAAC1K,QAAQ,EAAE0K,QAAQ,CAACzK,IAAI,CAAC;MAC1FpI,MAAM,CAACmT,UAAU,IAAI,IAAI,EAAE,gCAAgC,EAAE,gBAAgB,EAAE;QAC3EzJ,MAAM,EAAE,cAAc;QAAEC,WAAW;QAAEC,IAAI,EAAE;UAAErB,IAAI,EAAEiB,KAAK,CAACjB,IAAI;UAAE2K,SAAS,EAAEL,QAAQ,CAACK;QAAS;OAAI,CAAC;MAErG,MAAMhL,EAAE,GAAG;QACPG,EAAE,EAAEuK,QAAQ;QACZrK,IAAI,EAAElJ,MAAM,CAAC,CAAEwT,QAAQ,CAACO,QAAQ,EAAEC,WAAW,CAAC,CAAEF,UAAU,EAAEN,QAAQ,CAACS,SAAS,CAAE,CAAC,CAAE;OACtF;MAED,IAAI,CAAChM,IAAI,CAAC,OAAO,EAAE;QAAE0B,MAAM,EAAE,kBAAkB;QAAEW,WAAW,EAAEzB;MAAE,CAAE,CAAC;MACnE,IAAI;QACA,MAAMmB,MAAM,GAAG,MAAMqB,iBAAA,CAAAhE,uBAAA,MAAI,EAACoG,KAAA,CAAK,CAAAnC,IAAA,CAAV,IAAI,EAAOzC,EAAE,EAAE4C,QAAQ,EAAE6H,OAAO,GAAG,CAAC,CAAC;QAC1D,IAAI,CAACrL,IAAI,CAAC,OAAO,EAAE;UAAE0B,MAAM,EAAE,2BAA2B;UAAEW,WAAW,EAAEhH,MAAM,CAACuE,MAAM,CAAC,EAAG,EAAEgB,EAAE,CAAC;UAAEmB;QAAM,CAAE,CAAC;QACxG,OAAOA,MAAM;OAChB,CAAC,OAAOG,KAAK,EAAE;QACZ,IAAI,CAAClC,IAAI,CAAC,OAAO,EAAE;UAAE0B,MAAM,EAAE,0BAA0B;UAAEW,WAAW,EAAEhH,MAAM,CAACuE,MAAM,CAAC,EAAG,EAAEgB,EAAE,CAAC;UAAEsB;QAAK,CAAE,CAAC;QACtG,MAAMA,KAAK;;;IAInB,MAAMA,KAAK;;AAEpB;AAAC,eAAAqD,cAEsB0G,OAAmB;EACtC,MAAM;IAAEzR;EAAK,CAAE,GAAG,MAAMvB,iBAAiB,CAAC;IACtC4G,OAAO,EAAE,IAAI,CAACqE,UAAU,EAAE;IAC1B1J,KAAK,EAAEyR;GACV,CAAC;EACF,OAAOzR,KAAK;AAChB;AAAC,eAAAmL,iBAYsBpE,OAA+B,EAAEsC,QAAqB,EAAEqI,SAAoB;EAC/F,IAAI7O,OAAO,GAA6B,IAAI,CAACiG,WAAW,CAACO,QAAQ,CAAC;EAClE,IAAIL,QAAQ,GAA6B,IAAI,CAACD,YAAY,CAAC2I,SAAS,CAAC;EAErE,IAAI,OAAO7O,OAAQ,KAAK,QAAQ,IAAI,OAAOmG,QAAS,KAAK,QAAQ,EAAE;IAC/D,CAAEnG,OAAO,EAAEmG,QAAQ,CAAE,GAAG,MAAMzF,OAAO,CAACC,GAAG,CAAC,CAAEX,OAAO,EAAEmG,QAAQ,CAAE,CAAC;;EAGpE,OAAO,MAAMJ,iBAAA,CAAAhE,uBAAA,MAAI,EAACmG,aAAA,CAAa,CAAAlC,IAAA,CAAlB,IAAI,EAAeD,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAAUhI,MAAM,CAACuE,MAAM,CAAC2B,OAAO,EAAE;IAAElE,OAAO;IAAEmG;EAAQ,CAAE,CAAC,EAAE;AACjG;AAAC,eAAAsB,UAsCeG,KAAwB,EAAEkH,mBAA4B;EAClE;EAEA,IAAIhU,WAAW,CAAC8M,KAAK,EAAE,EAAE,CAAC,EAAE;IACxB,OAAO,MAAM7B,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAAU;MACvBJ,MAAM,EAAE,UAAU;MAAEU,SAAS,EAAEsB,KAAK;MAAEkH;KACzC,CAAC;;EAGN,IAAI3I,QAAQ,GAAG,IAAI,CAACD,YAAY,CAAC0B,KAAK,CAAC;EACvC,IAAI,OAAOzB,QAAS,KAAK,QAAQ,EAAE;IAAEA,QAAQ,GAAG,MAAMA,QAAQ;;EAE9D,OAAO,MAAMJ,iBAAA,CAAAhE,uBAAA,MAAI,EAAC2D,QAAA,CAAQ,CAAAM,IAAA,CAAb,IAAI,EAAU;IACvBJ,MAAM,EAAE,UAAU;IAAEO,QAAQ;IAAE2I;GACjC,CAAC;AACN;AAAC,eAAA/B,QA0QajN,KAAoB,EAAEiP,QAAqB;EACrD,IAAI9C,GAAG,GAAG,MAAM5M,eAAe,CAACS,KAAK,EAAE,IAAI,CAAC;EAC5C;EACA;EACA,IAAImM,GAAG,CAACvM,IAAI,KAAK,OAAO,IAAIqP,QAAQ,IAAIA,QAAQ,CAACtO,MAAM,GAAG,CAAC,IAAIsO,QAAQ,CAAC,CAAC,CAAC,CAACC,OAAO,KAAK,IAAI,EAAE;IACzF/C,GAAG,GAAG,MAAM5M,eAAe,CAAC;MAAEQ,MAAM,EAAE,UAAU;MAAEqL,GAAG,EAAE6D,QAAQ,CAAC,CAAC;IAAC,CAAE,EAAE,IAAI,CAAC;;EAE/E,OAAOlM,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,CAAC+B,GAAG,CAACgJ,GAAG,CAACtM,GAAG,CAAC,IAAI,IAAI;AAC1C;AAAC,eAAA8M,QAEa3M,KAAoB;EAC9B,MAAMmP,YAAY,GAAG,MAAM5P,eAAe,CAACS,KAAK,EAAE,IAAI,CAAC;EAEvD;EACA,MAAMH,GAAG,GAAGsP,YAAY,CAACtP,GAAG;EAE5B,IAAIsM,GAAG,GAAGpJ,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,CAAC+B,GAAG,CAACtD,GAAG,CAAC;EAC7B,IAAI,CAACsM,GAAG,EAAE;IACN,MAAMC,UAAU,GAAG,IAAI,CAACC,cAAc,CAAC8C,YAAY,CAAC;IAEpD,MAAMC,cAAc,GAAG,IAAI/N,OAAO,EAAE;IACpC,MAAMgO,OAAO,GAAG,IAAIvM,GAAG,EAAE;IACzBqJ,GAAG,GAAG;MAAEC,UAAU;MAAEvM,GAAG;MAAEuP,cAAc;MAAEC,OAAO;MAAE5C,OAAO,EAAE,KAAK;MAAEG,SAAS,EAAE;IAAG,CAAE;IAClF7J,qBAAA,CAAK3B,KAAK,EAAV,IAAK,CAAK,CAACgC,GAAG,CAACvD,GAAG,EAAEsM,GAAG,CAAC;;EAG5B,OAAOA,GAAG;AACd;AAwNJ,SAASmD,YAAYA,CAAC1K,MAAc,EAAEjG,KAAa;EAC/C,IAAI;IACA,MAAM4Q,KAAK,GAAGC,WAAW,CAAC5K,MAAM,EAAEjG,KAAK,CAAC;IACxC,IAAI4Q,KAAK,EAAE;MAAE,OAAOxT,YAAY,CAACwT,KAAK,CAAC;;GAC1C,CAAC,OAAMxK,KAAK,EAAE;EACf,OAAO,IAAI;AACf;AAEA,SAASyK,WAAWA,CAAC5K,MAAc,EAAEjG,KAAa;EAC9C,IAAIiG,MAAM,KAAK,IAAI,EAAE;IAAE,OAAO,IAAI;;EAClC,IAAI;IACA,MAAM6K,MAAM,GAAGtU,SAAS,CAACL,SAAS,CAAC8J,MAAM,EAAEjG,KAAK,EAAEA,KAAK,GAAG,EAAE,CAAC,CAAC;IAC9D,MAAMgC,MAAM,GAAGxF,SAAS,CAACL,SAAS,CAAC8J,MAAM,EAAE6K,MAAM,EAAEA,MAAM,GAAG,EAAE,CAAC,CAAC;IAEhE,OAAO3U,SAAS,CAAC8J,MAAM,EAAE6K,MAAM,GAAG,EAAE,EAAEA,MAAM,GAAG,EAAE,GAAG9O,MAAM,CAAC;GAC9D,CAAC,OAAOoE,KAAK,EAAE;EAChB,OAAO,IAAI;AACf;AAEA,SAAS2K,MAAMA,CAACrS,KAAa;EACzB,MAAMuH,MAAM,GAAGlJ,SAAS,CAAC2B,KAAK,CAAC;EAC/B,IAAIuH,MAAM,CAACjE,MAAM,GAAG,EAAE,EAAE;IAAE,MAAM,IAAIjB,KAAK,CAAC,6BAA6B,CAAC;;EAExE,MAAMiQ,MAAM,GAAG,IAAIC,UAAU,CAAC,EAAE,CAAC;EACjCD,MAAM,CAACvM,GAAG,CAACwB,MAAM,EAAE,EAAE,GAAGA,MAAM,CAACjE,MAAM,CAAC;EACtC,OAAOgP,MAAM;AACjB;AAEA,SAASE,QAAQA,CAACxS,KAAiB;EAC/B,IAAKA,KAAK,CAACsD,MAAM,GAAG,EAAE,KAAM,CAAC,EAAE;IAAE,OAAOtD,KAAK;;EAE7C,MAAMuH,MAAM,GAAG,IAAIgL,UAAU,CAACE,IAAI,CAACC,IAAI,CAAC1S,KAAK,CAACsD,MAAM,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;EAChEiE,MAAM,CAACxB,GAAG,CAAC/F,KAAK,CAAC;EACjB,OAAOuH,MAAM;AACjB;AAEA,MAAMoL,KAAK,GAAe,IAAIJ,UAAU,CAAC,EAAG,CAAC;AAE7C;AACA,SAAShB,WAAWA,CAACqB,KAAuB;EACxC,MAAMrL,MAAM,GAAsB,EAAG;EAErC,IAAIsL,SAAS,GAAG,CAAC;EAEjB;EACA,KAAK,IAAIlM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiM,KAAK,CAACtP,MAAM,EAAEqD,CAAC,EAAE,EAAE;IACnCY,MAAM,CAACnE,IAAI,CAACuP,KAAK,CAAC;IAClBE,SAAS,IAAI,EAAE;;EAGnB,KAAK,IAAIlM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiM,KAAK,CAACtP,MAAM,EAAEqD,CAAC,EAAE,EAAE;IACnC,MAAMF,IAAI,GAAG5I,QAAQ,CAAC+U,KAAK,CAACjM,CAAC,CAAC,CAAC;IAE/B;IACAY,MAAM,CAACZ,CAAC,CAAC,GAAG0L,MAAM,CAACQ,SAAS,CAAC;IAE7B;IACAtL,MAAM,CAACnE,IAAI,CAACiP,MAAM,CAAC5L,IAAI,CAACnD,MAAM,CAAC,CAAC;IAChCiE,MAAM,CAACnE,IAAI,CAACoP,QAAQ,CAAC/L,IAAI,CAAC,CAAC;IAC3BoM,SAAS,IAAI,EAAE,GAAGJ,IAAI,CAACC,IAAI,CAACjM,IAAI,CAACnD,MAAM,GAAG,EAAE,CAAC,GAAG,EAAE;;EAGtD,OAAO/F,MAAM,CAACgK,MAAM,CAAC;AACzB;AAEA,MAAMuL,KAAK,GAAG,oEAAoE;AAClF,SAAS9B,mBAAmBA,CAACvK,IAAY;EACrC,MAAMc,MAAM,GAAa;IACrBf,MAAM,EAAE,EAAE;IAAEF,IAAI,EAAE,EAAG;IAAED,QAAQ,EAAE,EAAE;IAAEiL,QAAQ,EAAE,EAAE;IAAEE,SAAS,EAAE,EAAE;IAAEJ,SAAS,EAAE;GAChF;EAEDlT,MAAM,CAACV,UAAU,CAACiJ,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,kCAAkC,EAAE,gBAAgB,EAAE;IACrFmB,MAAM,EAAE;GACX,CAAC;EAEF,MAAMpB,MAAM,GAAG/I,SAAS,CAACgJ,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;EACrCvI,MAAM,CAACT,SAAS,CAAC+I,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,KAAK/I,SAAS,CAACqV,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,+BAA+B,EAAE,gBAAgB,EAAE;IAC5GlL,MAAM,EAAE;GACX,CAAC;EACFL,MAAM,CAACf,MAAM,GAAG/I,SAAS,CAAC+I,MAAM,EAAE,EAAE,CAAC;EAErC;EACA,IAAI;IACA,MAAMF,IAAI,GAAkB,EAAE;IAC9B,MAAMyM,UAAU,GAAGjV,SAAS,CAACL,SAAS,CAACgJ,IAAI,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IACrD,MAAMuM,UAAU,GAAGlV,SAAS,CAACL,SAAS,CAACgJ,IAAI,EAAEsM,UAAU,EAAEA,UAAU,GAAG,EAAE,CAAC,CAAC;IAC1E,MAAME,QAAQ,GAAGxV,SAAS,CAACgJ,IAAI,EAAEsM,UAAU,GAAG,EAAE,CAAC;IACjD,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,EAAEE,CAAC,EAAE,EAAE;MACjC,MAAMtM,GAAG,GAAGqL,YAAY,CAACgB,QAAQ,EAAEC,CAAC,GAAG,EAAE,CAAC;MAC1C,IAAItM,GAAG,IAAI,IAAI,EAAE;QAAE,MAAM,IAAIvE,KAAK,CAAC,OAAO,CAAC;;MAC3CiE,IAAI,CAAClD,IAAI,CAACwD,GAAG,CAAC;;IAElBW,MAAM,CAACjB,IAAI,GAAGA,IAAI;GACrB,CAAC,OAAOoB,KAAK,EAAE;IACZxJ,MAAM,CAAC,KAAK,EAAE,6BAA6B,EAAE,gBAAgB,EAAE;MAC3D0J,MAAM,EAAE;KACX,CAAC;;EAGN;EACA,IAAI;IACA,MAAMvB,QAAQ,GAAG8L,WAAW,CAAC1L,IAAI,EAAE,EAAE,CAAC;IACtC,IAAIJ,QAAQ,IAAI,IAAI,EAAE;MAAE,MAAM,IAAIhE,KAAK,CAAC,OAAO,CAAC;;IAChDkF,MAAM,CAAClB,QAAQ,GAAGA,QAAQ;GAC7B,CAAC,OAAOqB,KAAK,EAAE;IACZxJ,MAAM,CAAC,KAAK,EAAE,iCAAiC,EAAE,gBAAgB,EAAE;MAC/D0J,MAAM,EAAE;KACX,CAAC;;EAGN;EACA1J,MAAM,CAACT,SAAS,CAACgJ,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,KAAKhJ,SAAS,CAACqV,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,0CAA0C,EAAE,gBAAgB,EAAE;IACxHlL,MAAM,EAAE;GACX,CAAC;EACFL,MAAM,CAAC+J,QAAQ,GAAG7T,SAAS,CAACgJ,IAAI,EAAE,EAAE,EAAE,GAAG,CAAC;EAE1C;EACA,IAAI;IACA,MAAM+K,SAAS,GAAGW,WAAW,CAAC1L,IAAI,EAAE,GAAG,CAAC;IACxC,IAAI+K,SAAS,IAAI,IAAI,EAAE;MAAE,MAAM,IAAInP,KAAK,CAAC,OAAO,CAAC;;IACjDkF,MAAM,CAACiK,SAAS,GAAGA,SAAS;GAC/B,CAAC,OAAO9J,KAAK,EAAE;IACZxJ,MAAM,CAAC,KAAK,EAAE,kCAAkC,EAAE,gBAAgB,EAAE;MAChE0J,MAAM,EAAE;KACX,CAAC;;EAGNL,MAAM,CAAC6J,SAAS,GAAG,yCAAyC,CAAC+B,KAAK,CAAC,GAAG,CAAC,CAACrQ,GAAG,CAAExC,CAAC,IAAWiH,MAAO,CAACjH,CAAC,CAAC,CAAC;EAEpG,OAAOiH,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}