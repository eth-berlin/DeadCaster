{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MockKeyFetcher__cipher;\nimport { getBytes } from 'ethers';\nimport { CallError, OASIS_CALL_DATA_PUBLIC_KEY } from './index.js';\nimport { NETWORKS } from './networks.js';\nimport { X25519DeoxysII } from './cipher.js';\nconst DEFAULT_PUBKEY_CACHE_EXPIRATION_MS = 60 * 5 * 1000; // 5 minutes in milliseconds\nfunction toCallDataPublicKey(result, chainId) {\n  const key = getBytes(result.key);\n  return {\n    key,\n    checksum: getBytes(result.checksum),\n    signature: getBytes(result.signature),\n    epoch: result.epoch,\n    chainId,\n    fetched: new Date()\n  };\n}\n// TODO: remove, this is unecessary, node has `fetch` now?\nfunction fetchRuntimePublicKeyNode(gwUrl) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // Import http or https, depending on the URI scheme.\n    const https = yield import( /* webpackIgnore: true */gwUrl.split(':')[0]);\n    const body = makeCallDataPublicKeyBody();\n    return new Promise((resolve, reject) => {\n      const opts = {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n          'content-length': body.length\n        }\n      };\n      const req = https.request(gwUrl, opts, res => {\n        const chunks = [];\n        res.on('error', err => reject(err));\n        res.on('data', chunk => chunks.push(chunk));\n        res.on('end', () => {\n          resolve(JSON.parse(Buffer.concat(chunks).toString()));\n        });\n      });\n      req.on('error', err => reject(err));\n      req.write(body);\n      req.end();\n    });\n  });\n}\nfunction fetchRuntimePublicKeyBrowser(gwUrl, fetchImpl) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const res = yield fetchImpl(gwUrl, {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json'\n      },\n      body: makeCallDataPublicKeyBody()\n    });\n    if (!res.ok) {\n      throw new CallError('Failed to fetch runtime public key.', res);\n    }\n    return yield res.json();\n  });\n}\nfunction makeCallDataPublicKeyBody() {\n  return JSON.stringify({\n    jsonrpc: '2.0',\n    id: Math.floor(Math.random() * 1e9),\n    method: OASIS_CALL_DATA_PUBLIC_KEY,\n    params: []\n  });\n}\nexport function fetchRuntimePublicKeyByChainId(chainId, opts) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      defaultGateway\n    } = NETWORKS[chainId];\n    if (!defaultGateway) throw new Error(`Unable to fetch runtime public key for network with unknown ID: ${chainId}.`);\n    const fetchImpl = (_a = opts === null || opts === void 0 ? void 0 : opts.fetch) !== null && _a !== void 0 ? _a : globalThis === null || globalThis === void 0 ? void 0 : globalThis.fetch;\n    const res = yield fetchImpl ? fetchRuntimePublicKeyBrowser(defaultGateway, fetchImpl) : fetchRuntimePublicKeyNode(defaultGateway);\n    return toCallDataPublicKey(res.result, chainId);\n  });\n}\nfunction fromQuantity(x) {\n  if (typeof x === 'string') {\n    if (x.startsWith('0x')) {\n      return parseInt(x, 16);\n    }\n    return parseInt(x); // Assumed to be base 10\n  }\n  return x;\n}\n/**\n * Picks the most user-trusted runtime calldata public key source based on what\n * connections are available.\n *\n * NOTE: MetaMask does not support Web3 methods it doesn't know about, so we have to\n *       fall-back to manually querying the default gateway.\n */\nexport function fetchRuntimePublicKey(upstream) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const provider = 'provider' in upstream ? upstream['provider'] : upstream;\n    let chainId;\n    if (provider) {\n      let resp;\n      // It's probably an EIP-1193 provider\n      if ('request' in provider) {\n        const source = provider;\n        chainId = fromQuantity(yield source.request({\n          method: 'eth_chainId'\n        }));\n        try {\n          resp = yield source.request({\n            method: OASIS_CALL_DATA_PUBLIC_KEY,\n            params: []\n          });\n        } catch (ex) {\n          // don't do anything, move on to try next\n        }\n      }\n      // If it's a `send` provider\n      else if ('send' in provider) {\n        const source = provider;\n        chainId = fromQuantity(yield source.send('eth_chainId', []));\n        try {\n          resp = yield source.send(OASIS_CALL_DATA_PUBLIC_KEY, []);\n        } catch (ex) {\n          // don't do anything, move on to try chainId fetch\n        }\n      }\n      // Otherwise, we have no idea what to do with this provider!\n      else {\n        throw new Error('fetchRuntimePublicKey does not support non-request non-send provier!');\n      }\n      if (resp && 'key' in resp) {\n        return toCallDataPublicKey(resp, chainId);\n      }\n    }\n    if (!chainId) {\n      throw new Error('fetchRuntimePublicKey failed to retrieve chainId from provider');\n    }\n    return fetchRuntimePublicKeyByChainId(chainId);\n  });\n}\nexport class AbstractKeyFetcher {}\nexport class KeyFetcher extends AbstractKeyFetcher {\n  constructor(in_timeoutMilliseconds) {\n    super();\n    if (!in_timeoutMilliseconds) {\n      in_timeoutMilliseconds = DEFAULT_PUBKEY_CACHE_EXPIRATION_MS;\n    }\n    this.timeoutMilliseconds = in_timeoutMilliseconds;\n  }\n  /**\n   * Retrieve cached key if possible, otherwise fetch a fresh one\n   *\n   * @param upstream Upstream ETH JSON-RPC provider\n   * @returns calldata public key\n   */\n  fetch(upstream) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pubkey) {\n        const pk = this.pubkey;\n        const expiry = Date.now() - this.timeoutMilliseconds;\n        if (pk.fetched && pk.fetched.valueOf() > expiry) {\n          // XXX: if provider switch chain, may return cached key for wrong chain\n          return pk;\n        }\n      }\n      return this.pubkey = yield fetchRuntimePublicKey(upstream);\n    });\n  }\n  cipher(upstream) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const kp = yield this.fetch(upstream);\n      return X25519DeoxysII.ephemeral(kp.key, kp.epoch);\n    });\n  }\n}\nexport class MockKeyFetcher extends AbstractKeyFetcher {\n  constructor(in_cipher) {\n    super();\n    _MockKeyFetcher__cipher.set(this, void 0);\n    __classPrivateFieldSet(this, _MockKeyFetcher__cipher, in_cipher, \"f\");\n  }\n  fetch() {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new Error(\"MockKeyFetcher doesn't support fetch(), only cipher()\");\n    });\n  }\n  cipher() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return __classPrivateFieldGet(this, _MockKeyFetcher__cipher, \"f\");\n    });\n  }\n}\n_MockKeyFetcher__cipher = new WeakMap();","map":{"version":3,"names":["getBytes","CallError","OASIS_CALL_DATA_PUBLIC_KEY","NETWORKS","X25519DeoxysII","DEFAULT_PUBKEY_CACHE_EXPIRATION_MS","toCallDataPublicKey","result","chainId","key","checksum","signature","epoch","fetched","Date","fetchRuntimePublicKeyNode","gwUrl","https","split","body","makeCallDataPublicKeyBody","Promise","resolve","reject","opts","method","headers","length","req","request","res","chunks","on","err","chunk","push","JSON","parse","Buffer","concat","toString","write","end","fetchRuntimePublicKeyBrowser","fetchImpl","ok","json","stringify","jsonrpc","id","Math","floor","random","params","fetchRuntimePublicKeyByChainId","defaultGateway","Error","_a","fetch","globalThis","fromQuantity","x","startsWith","parseInt","fetchRuntimePublicKey","upstream","provider","resp","source","ex","send","AbstractKeyFetcher","KeyFetcher","constructor","in_timeoutMilliseconds","timeoutMilliseconds","pubkey","pk","expiry","now","valueOf","cipher","kp","ephemeral","MockKeyFetcher","in_cipher","_MockKeyFetcher__cipher","set","__classPrivateFieldSet","__classPrivateFieldGet"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@oasisprotocol/sapphire-paratime/src/calldatapublickey.ts"],"sourcesContent":["import { getBytes } from 'ethers';\n\nimport { UpstreamProvider, EIP1193Provider } from './interfaces.js';\nimport { CallError, OASIS_CALL_DATA_PUBLIC_KEY } from './index.js';\nimport { NETWORKS } from './networks.js';\nimport { Cipher, Mock as MockCipher, X25519DeoxysII } from './cipher.js';\n\nconst DEFAULT_PUBKEY_CACHE_EXPIRATION_MS = 60 * 5 * 1000; // 5 minutes in milliseconds\n\n// -----------------------------------------------------------------------------\n// Fetch calldata public key\n// Well use provider when possible, and fallback to HTTP(S)? requests\n// e.g. MetaMask doesn't allow the oasis_callDataPublicKey JSON-RPC method\n\ntype RawCallDataPublicKeyResponseResult = {\n  key: string;\n  checksum: string;\n  signature: string;\n  epoch: number;\n};\n\ntype RawCallDataPublicKeyResponse = {\n  result: RawCallDataPublicKeyResponseResult;\n};\n\nexport interface CallDataPublicKey {\n  // PublicKey is the requested public key.\n  key: Uint8Array;\n\n  // Checksum is the checksum of the key manager state.\n  checksum: Uint8Array;\n\n  // Signature is the Sign(sk, (key || checksum)) from the key manager.\n  signature: Uint8Array;\n\n  // Epoch is the epoch of the ephemeral runtime key.\n  epoch: number;\n\n  // Which chain ID is this key for?\n  chainId: number;\n\n  // When was the key fetched\n  fetched: Date;\n}\n\nfunction toCallDataPublicKey(\n  result: RawCallDataPublicKeyResponseResult,\n  chainId: number,\n) {\n  const key = getBytes(result.key);\n  return {\n    key,\n    checksum: getBytes(result.checksum),\n    signature: getBytes(result.signature),\n    epoch: result.epoch,\n    chainId,\n    fetched: new Date(),\n  } as CallDataPublicKey;\n}\n\n// TODO: remove, this is unecessary, node has `fetch` now?\nasync function fetchRuntimePublicKeyNode(\n  gwUrl: string,\n): Promise<RawCallDataPublicKeyResponse> {\n  // Import http or https, depending on the URI scheme.\n  const https = await import(/* webpackIgnore: true */ gwUrl.split(':')[0]);\n\n  const body = makeCallDataPublicKeyBody();\n  return new Promise((resolve, reject) => {\n    const opts = {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json',\n        'content-length': body.length,\n      },\n    };\n    const req = https.request(gwUrl, opts, (res: any) => {\n      const chunks: Buffer[] = [];\n      res.on('error', (err: any) => reject(err));\n      res.on('data', (chunk: any) => chunks.push(chunk));\n      res.on('end', () => {\n        resolve(JSON.parse(Buffer.concat(chunks).toString()));\n      });\n    });\n    req.on('error', (err: Error) => reject(err));\n    req.write(body);\n    req.end();\n  });\n}\n\nasync function fetchRuntimePublicKeyBrowser(\n  gwUrl: string,\n  fetchImpl: typeof fetch,\n): Promise<RawCallDataPublicKeyResponse> {\n  const res = await fetchImpl(gwUrl, {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n    },\n    body: makeCallDataPublicKeyBody(),\n  });\n  if (!res.ok) {\n    throw new CallError('Failed to fetch runtime public key.', res);\n  }\n  return await res.json();\n}\n\nfunction makeCallDataPublicKeyBody(): string {\n  return JSON.stringify({\n    jsonrpc: '2.0',\n    id: Math.floor(Math.random() * 1e9),\n    method: OASIS_CALL_DATA_PUBLIC_KEY,\n    params: [],\n  });\n}\n\nexport async function fetchRuntimePublicKeyByChainId(\n  chainId: number,\n  opts?: { fetch?: typeof fetch },\n): Promise<CallDataPublicKey> {\n  const { defaultGateway } = NETWORKS[chainId];\n  if (!defaultGateway)\n    throw new Error(\n      `Unable to fetch runtime public key for network with unknown ID: ${chainId}.`,\n    );\n  const fetchImpl = opts?.fetch ?? globalThis?.fetch;\n  const res = await (fetchImpl\n    ? fetchRuntimePublicKeyBrowser(defaultGateway, fetchImpl)\n    : fetchRuntimePublicKeyNode(defaultGateway));\n  return toCallDataPublicKey(res.result, chainId);\n}\n\nfunction fromQuantity(x: number | string): number {\n  if (typeof x === 'string') {\n    if (x.startsWith('0x')) {\n      return parseInt(x, 16);\n    }\n    return parseInt(x); // Assumed to be base 10\n  }\n  return x;\n}\n\n/**\n * Picks the most user-trusted runtime calldata public key source based on what\n * connections are available.\n *\n * NOTE: MetaMask does not support Web3 methods it doesn't know about, so we have to\n *       fall-back to manually querying the default gateway.\n */\nexport async function fetchRuntimePublicKey(\n  upstream: UpstreamProvider,\n): Promise<CallDataPublicKey> {\n  const provider = 'provider' in upstream ? upstream['provider'] : upstream;\n  let chainId: number | undefined;\n  if (provider) {\n    let resp;\n    // It's probably an EIP-1193 provider\n    if ('request' in provider) {\n      const source = provider as EIP1193Provider;\n      chainId = fromQuantity(\n        (await source.request({ method: 'eth_chainId' })) as string | number,\n      );\n      try {\n        resp = await source.request({\n          method: OASIS_CALL_DATA_PUBLIC_KEY,\n          params: [],\n        });\n      } catch (ex) {\n        // don't do anything, move on to try next\n      }\n    }\n    // If it's a `send` provider\n    else if ('send' in provider) {\n      const source = provider as {\n        send: (method: string, params: any[]) => Promise<any>;\n      };\n      chainId = fromQuantity(await source.send('eth_chainId', []));\n      try {\n        resp = await source.send(OASIS_CALL_DATA_PUBLIC_KEY, []);\n      } catch (ex) {\n        // don't do anything, move on to try chainId fetch\n      }\n    }\n    // Otherwise, we have no idea what to do with this provider!\n    else {\n      throw new Error(\n        'fetchRuntimePublicKey does not support non-request non-send provier!',\n      );\n    }\n    if (resp && 'key' in resp) {\n      return toCallDataPublicKey(resp, chainId);\n    }\n  }\n\n  if (!chainId) {\n    throw new Error(\n      'fetchRuntimePublicKey failed to retrieve chainId from provider',\n    );\n  }\n  return fetchRuntimePublicKeyByChainId(chainId);\n}\n\nexport abstract class AbstractKeyFetcher {\n  public abstract fetch(upstream: UpstreamProvider): Promise<CallDataPublicKey>;\n  public abstract cipher(upstream: UpstreamProvider): Promise<Cipher>;\n}\n\nexport class KeyFetcher extends AbstractKeyFetcher {\n  readonly timeoutMilliseconds: number;\n  public pubkey?: CallDataPublicKey;\n\n  constructor(in_timeoutMilliseconds?: number) {\n    super();\n    if (!in_timeoutMilliseconds) {\n      in_timeoutMilliseconds = DEFAULT_PUBKEY_CACHE_EXPIRATION_MS;\n    }\n    this.timeoutMilliseconds = in_timeoutMilliseconds;\n  }\n\n  /**\n   * Retrieve cached key if possible, otherwise fetch a fresh one\n   *\n   * @param upstream Upstream ETH JSON-RPC provider\n   * @returns calldata public key\n   */\n  public async fetch(upstream: UpstreamProvider): Promise<CallDataPublicKey> {\n    if (this.pubkey) {\n      const pk = this.pubkey;\n      const expiry = Date.now() - this.timeoutMilliseconds;\n      if (pk.fetched && pk.fetched.valueOf() > expiry) {\n        // XXX: if provider switch chain, may return cached key for wrong chain\n        return pk;\n      }\n    }\n    return (this.pubkey = await fetchRuntimePublicKey(upstream));\n  }\n\n  public async cipher(upstream: UpstreamProvider): Promise<Cipher> {\n    const kp = await this.fetch(upstream);\n    return X25519DeoxysII.ephemeral(kp.key, kp.epoch);\n  }\n}\n\nexport class MockKeyFetcher extends AbstractKeyFetcher {\n  #_cipher: MockCipher;\n\n  constructor(in_cipher: MockCipher) {\n    super();\n    this.#_cipher = in_cipher;\n  }\n\n  public async fetch(): Promise<CallDataPublicKey> {\n    throw new Error(\"MockKeyFetcher doesn't support fetch(), only cipher()\");\n  }\n\n  public async cipher(): Promise<Cipher> {\n    return this.#_cipher;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}