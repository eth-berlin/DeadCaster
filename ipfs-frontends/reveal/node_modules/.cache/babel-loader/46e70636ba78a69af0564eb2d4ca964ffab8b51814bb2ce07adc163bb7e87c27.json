{"ast":null,"code":"export const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction isBuffer(buf) {\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\nexport function asU8A(buf) {\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ? (bytes, start, end) => {\n  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n} : (bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ? string => {\n  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);\n} : string => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ? (bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n  return bytes.slice(start, end);\n} : (bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ? (chunks, length) => {\n  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n} : (chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      b = b.subarray(0, out.length - off);\n    }\n    out.set(b, off);\n    off += b.length;\n  }\n  return out;\n};\nexport const alloc = useBuffer ? size => {\n  return globalThis.Buffer.allocUnsafe(size);\n} : size => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ? d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n} : d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '');\n};\nexport const fromHex = useBuffer ? hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  return globalThis.Buffer.from(hex, 'hex');\n} : hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '').filter(Boolean).map(e => parseInt(e, 16)));\n};\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n}\nexport function compare(b1, b2) {\n  if (isBuffer(b1) && isBuffer(b2)) {\n    return b1.compare(b2);\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n    return b1[i] < b2[i] ? -1 : 1;\n  }\n  return 0;\n}\nfunction utf8ToBytes(string, units = Infinity) {\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n    if (codePoint > 55295 && codePoint < 57344) {\n      if (!leadSurrogate) {\n        if (codePoint > 56319) {\n          if ((units -= 3) > -1) bytes.push(239, 191, 189);\n          continue;\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1) bytes.push(239, 191, 189);\n          continue;\n        }\n        leadSurrogate = codePoint;\n        continue;\n      }\n      if (codePoint < 56320) {\n        if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        leadSurrogate = codePoint;\n        continue;\n      }\n      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1) bytes.push(239, 191, 189);\n    }\n    leadSurrogate = null;\n    if (codePoint < 128) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 2048) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n    } else if (codePoint < 65536) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else if (codePoint < 1114112) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n  return bytes;\n}\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 128) {\n            codePoint = firstByte;\n          }\n          break;\n        case 2:\n          secondByte = buf[offset + 1];\n          if ((secondByte & 192) === 128) {\n            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n            if (tempCodePoint > 127) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 3:\n          secondByte = buf[offset + 1];\n          thirdByte = buf[offset + 2];\n          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 4:\n          secondByte = buf[offset + 1];\n          thirdByte = buf[offset + 2];\n          fourthByte = buf[offset + 3];\n          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n    if (codePoint === null) {\n      codePoint = 65533;\n      bytesPerSequence = 1;\n    } else if (codePoint > 65535) {\n      codePoint -= 65536;\n      res.push(codePoint >>> 10 & 1023 | 55296);\n      codePoint = 56320 | codePoint & 1023;\n    }\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n  return decodeCodePointsArray(res);\n}\nconst MAX_ARGUMENTS_LENGTH = 4096;\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints);\n  }\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}","map":{"version":3,"names":["useBuffer","globalThis","process","browser","Buffer","isBuffer","textDecoder","TextDecoder","textEncoder","TextEncoder","buf","asU8A","Uint8Array","from","buffer","byteOffset","byteLength","toString","bytes","start","end","subarray","utf8Slice","decode","fromString","string","length","utf8ToBytes","encode","fromArray","arr","slice","concat","chunks","map","c","out","off","b","set","alloc","size","allocUnsafe","toHex","d","toBytes","Array","prototype","reduce","call","p","padStart","fromHex","hex","split","i","filter","Boolean","e","parseInt","obj","constructor","name","ArrayBuffer","isView","Error","compare","b1","b2","units","Infinity","codePoint","leadSurrogate","charCodeAt","push","offset","res","firstByte","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","len","String","fromCharCode","apply"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/cborg/esm/lib/byte-utils.js"],"sourcesContent":["export const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction isBuffer(buf) {\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\nexport function asU8A(buf) {\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ? (bytes, start, end) => {\n  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n} : (bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ? string => {\n  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);\n} : string => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ? (bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n  return bytes.slice(start, end);\n} : (bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ? (chunks, length) => {\n  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n} : (chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      b = b.subarray(0, out.length - off);\n    }\n    out.set(b, off);\n    off += b.length;\n  }\n  return out;\n};\nexport const alloc = useBuffer ? size => {\n  return globalThis.Buffer.allocUnsafe(size);\n} : size => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ? d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n} : d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${ p }${ c.toString(16).padStart(2, '0') }`, '');\n};\nexport const fromHex = useBuffer ? hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  return globalThis.Buffer.from(hex, 'hex');\n} : hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${ c }${ d[i + 1] }` : '').filter(Boolean).map(e => parseInt(e, 16)));\n};\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n}\nexport function compare(b1, b2) {\n  if (isBuffer(b1) && isBuffer(b2)) {\n    return b1.compare(b2);\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n    return b1[i] < b2[i] ? -1 : 1;\n  }\n  return 0;\n}\nfunction utf8ToBytes(string, units = Infinity) {\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n    if (codePoint > 55295 && codePoint < 57344) {\n      if (!leadSurrogate) {\n        if (codePoint > 56319) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        }\n        leadSurrogate = codePoint;\n        continue;\n      }\n      if (codePoint < 56320) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n        leadSurrogate = codePoint;\n        continue;\n      }\n      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1)\n        bytes.push(239, 191, 189);\n    }\n    leadSurrogate = null;\n    if (codePoint < 128) {\n      if ((units -= 1) < 0)\n        break;\n      bytes.push(codePoint);\n    } else if (codePoint < 2048) {\n      if ((units -= 2) < 0)\n        break;\n      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n    } else if (codePoint < 65536) {\n      if ((units -= 3) < 0)\n        break;\n      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else if (codePoint < 1114112) {\n      if ((units -= 4) < 0)\n        break;\n      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n  return bytes;\n}\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n      case 1:\n        if (firstByte < 128) {\n          codePoint = firstByte;\n        }\n        break;\n      case 2:\n        secondByte = buf[offset + 1];\n        if ((secondByte & 192) === 128) {\n          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n          if (tempCodePoint > 127) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 3:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 4:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        fourthByte = buf[offset + 3];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n            codePoint = tempCodePoint;\n          }\n        }\n      }\n    }\n    if (codePoint === null) {\n      codePoint = 65533;\n      bytesPerSequence = 1;\n    } else if (codePoint > 65535) {\n      codePoint -= 65536;\n      res.push(codePoint >>> 10 & 1023 | 55296);\n      codePoint = 56320 | codePoint & 1023;\n    }\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n  return decodeCodePointsArray(res);\n}\nconst MAX_ARGUMENTS_LENGTH = 4096;\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints);\n  }\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}