{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _defineProperty from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\nimport { keccak256 } from \"../crypto/index.js\";\nimport { id } from \"../hash/index.js\";\nimport { concat, dataSlice, getBigInt, getBytes, getBytesCopy, hexlify, zeroPadBytes, zeroPadValue, isHexString, defineProperties, assertArgument, toBeHex, assert } from \"../utils/index.js\";\nimport { AbiCoder } from \"./abi-coder.js\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder.js\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, Fragment, FunctionFragment, ParamType } from \"./fragments.js\";\nimport { Typed } from \"./typed.js\";\nexport { checkResultErrors, Result };\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */\nexport class LogDescription {\n  /**\n   *  @_ignore:\n   */\n  constructor(fragment, topic, args) {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    _defineProperty(this, \"fragment\", void 0);\n    /**\n     *  The name of the Event.\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     *  The full Event signature.\n     */\n    _defineProperty(this, \"signature\", void 0);\n    /**\n     *  The topic hash for the Event.\n     */\n    _defineProperty(this, \"topic\", void 0);\n    /**\n     *  The arguments passed into the Event with ``emit``.\n     */\n    _defineProperty(this, \"args\", void 0);\n    const name = fragment.name,\n      signature = fragment.format();\n    defineProperties(this, {\n      fragment,\n      name,\n      signature,\n      topic,\n      args\n    });\n  }\n}\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */\nexport class TransactionDescription {\n  /**\n   *  @_ignore:\n   */\n  constructor(fragment, selector, args, value) {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    _defineProperty(this, \"fragment\", void 0);\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     *  The arguments passed to the Function from the transaction ``data``.\n     */\n    _defineProperty(this, \"args\", void 0);\n    /**\n     *  The full Function signature from the transaction ``data``.\n     */\n    _defineProperty(this, \"signature\", void 0);\n    /**\n     *  The selector for the Function from the transaction ``data``.\n     */\n    _defineProperty(this, \"selector\", void 0);\n    /**\n     *  The ``value`` (in wei) from the transaction.\n     */\n    _defineProperty(this, \"value\", void 0);\n    const name = fragment.name,\n      signature = fragment.format();\n    defineProperties(this, {\n      fragment,\n      name,\n      args,\n      signature,\n      selector,\n      value\n    });\n  }\n}\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */\nexport class ErrorDescription {\n  /**\n   *  @_ignore:\n   */\n  constructor(fragment, selector, args) {\n    /**\n     *  The matching fragment.\n     */\n    _defineProperty(this, \"fragment\", void 0);\n    /**\n     *  The name of the Error.\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    _defineProperty(this, \"args\", void 0);\n    /**\n     *  The full Error signature.\n     */\n    _defineProperty(this, \"signature\", void 0);\n    /**\n     *  The selector for the Error.\n     */\n    _defineProperty(this, \"selector\", void 0);\n    const name = fragment.name,\n      signature = fragment.format();\n    defineProperties(this, {\n      fragment,\n      name,\n      args,\n      signature,\n      selector\n    });\n  }\n}\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */\nexport class Indexed {\n  /**\n   *  Returns ``true`` if %%value%% is an **Indexed**.\n   *\n   *  This provides a Type Guard for property access.\n   */\n  static isIndexed(value) {\n    return !!(value && value._isIndexed);\n  }\n  /**\n   *  @_ignore:\n   */\n  constructor(hash) {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    _defineProperty(this, \"hash\", void 0);\n    /**\n     *  @_ignore:\n     */\n    _defineProperty(this, \"_isIndexed\", void 0);\n    defineProperties(this, {\n      hash,\n      _isIndexed: true\n    });\n  }\n}\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n  \"0\": \"generic panic\",\n  \"1\": \"assert(false)\",\n  \"17\": \"arithmetic overflow\",\n  \"18\": \"division or modulo by zero\",\n  \"33\": \"enum overflow\",\n  \"34\": \"invalid encoded storage byte array accessed\",\n  \"49\": \"out-of-bounds array access; popping on an empty array\",\n  \"50\": \"out-of-bounds access of an array or bytesN\",\n  \"65\": \"out of memory\",\n  \"81\": \"uninitialized function\"\n};\nconst BuiltinErrors = {\n  \"0x08c379a0\": {\n    signature: \"Error(string)\",\n    name: \"Error\",\n    inputs: [\"string\"],\n    reason: message => {\n      return \"reverted with reason string \".concat(JSON.stringify(message));\n    }\n  },\n  \"0x4e487b71\": {\n    signature: \"Panic(uint256)\",\n    name: \"Panic\",\n    inputs: [\"uint256\"],\n    reason: code => {\n      let reason = \"unknown panic code\";\n      if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n        reason = PanicReasons[code.toString()];\n      }\n      return \"reverted with panic code 0x\".concat(code.toString(16), \" (\").concat(reason, \")\");\n    }\n  }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nvar _errors = /*#__PURE__*/new WeakMap();\nvar _events = /*#__PURE__*/new WeakMap();\nvar _functions = /*#__PURE__*/new WeakMap();\nvar _abiCoder = /*#__PURE__*/new WeakMap();\nvar _Interface_brand = /*#__PURE__*/new WeakSet();\nexport class Interface {\n  /**\n   *  Create a new Interface for the %%fragments%%.\n   */\n  constructor(fragments) {\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    _classPrivateMethodInitSpec(this, _Interface_brand);\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    _defineProperty(this, \"fragments\", void 0);\n    /**\n     *  The Contract constructor.\n     */\n    _defineProperty(this, \"deploy\", void 0);\n    /**\n     *  The Fallback method, if any.\n     */\n    _defineProperty(this, \"fallback\", void 0);\n    /**\n     *  If receiving ether is supported.\n     */\n    _defineProperty(this, \"receive\", void 0);\n    _classPrivateFieldInitSpec(this, _errors, void 0);\n    _classPrivateFieldInitSpec(this, _events, void 0);\n    _classPrivateFieldInitSpec(this, _functions, void 0);\n    //    #structs: Map<string, StructFragment>;\n    _classPrivateFieldInitSpec(this, _abiCoder, void 0);\n    let abi = [];\n    if (typeof fragments === \"string\") {\n      abi = JSON.parse(fragments);\n    } else {\n      abi = fragments;\n    }\n    _classPrivateFieldSet(_functions, this, new Map());\n    _classPrivateFieldSet(_errors, this, new Map());\n    _classPrivateFieldSet(_events, this, new Map());\n    //        this.#structs = new Map();\n    const frags = [];\n    for (const a of abi) {\n      try {\n        frags.push(Fragment.from(a));\n      } catch (error) {\n        console.log(\"[Warning] Invalid Fragment \".concat(JSON.stringify(a), \":\"), error.message);\n      }\n    }\n    defineProperties(this, {\n      fragments: Object.freeze(frags)\n    });\n    let fallback = null;\n    let receive = false;\n    _classPrivateFieldSet(_abiCoder, this, this.getAbiCoder());\n    // Add all fragments by their signature\n    this.fragments.forEach((fragment, index) => {\n      let bucket;\n      switch (fragment.type) {\n        case \"constructor\":\n          if (this.deploy) {\n            console.log(\"duplicate definition - constructor\");\n            return;\n          }\n          //checkNames(fragment, \"input\", fragment.inputs);\n          defineProperties(this, {\n            deploy: fragment\n          });\n          return;\n        case \"fallback\":\n          if (fragment.inputs.length === 0) {\n            receive = true;\n          } else {\n            assertArgument(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", \"fragments[\".concat(index, \"]\"), fragment);\n            fallback = fragment;\n            receive = fallback.payable;\n          }\n          return;\n        case \"function\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n          bucket = _classPrivateFieldGet(_functions, this);\n          break;\n        case \"event\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          bucket = _classPrivateFieldGet(_events, this);\n          break;\n        case \"error\":\n          bucket = _classPrivateFieldGet(_errors, this);\n          break;\n        default:\n          return;\n      }\n      // Two identical entries; ignore it\n      const signature = fragment.format();\n      if (bucket.has(signature)) {\n        return;\n      }\n      bucket.set(signature, fragment);\n    });\n    // If we do not have a constructor add a default\n    if (!this.deploy) {\n      defineProperties(this, {\n        deploy: ConstructorFragment.from(\"constructor()\")\n      });\n    }\n    defineProperties(this, {\n      fallback,\n      receive\n    });\n  }\n  /**\n   *  Returns the entire Human-Readable ABI, as an array of\n   *  signatures, optionally as %%minimal%% strings, which\n   *  removes parameter names and unneceesary spaces.\n   */\n  format(minimal) {\n    const format = minimal ? \"minimal\" : \"full\";\n    const abi = this.fragments.map(f => f.format(format));\n    return abi;\n  }\n  /**\n   *  Return the JSON-encoded ABI. This is the format Solidiy\n   *  returns.\n   */\n  formatJson() {\n    const abi = this.fragments.map(f => f.format(\"json\"));\n    // We need to re-bundle the JSON fragments a bit\n    return JSON.stringify(abi.map(j => JSON.parse(j)));\n  }\n  /**\n   *  The ABI coder that will be used to encode and decode binary\n   *  data.\n   */\n  getAbiCoder() {\n    return AbiCoder.defaultAbiCoder();\n  }\n  /**\n   *  Get the function name for %%key%%, which may be a function selector,\n   *  function name or function signature that belongs to the ABI.\n   */\n  getFunctionName(key) {\n    const fragment = _assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, null, false);\n    assertArgument(fragment, \"no matching function\", \"key\", key);\n    return fragment.name;\n  }\n  /**\n   *  Returns true if %%key%% (a function selector, function name or\n   *  function signature) is present in the ABI.\n   *\n   *  In the case of a function name, the name may be ambiguous, so\n   *  accessing the [[FunctionFragment]] may require refinement.\n   */\n  hasFunction(key) {\n    return !!_assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, null, false);\n  }\n  /**\n   *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n   *  selector, function name or function signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple functions match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single function in\n   *  the ABI, this will throw.\n   */\n  getFunction(key, values) {\n    return _assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, values || null, true);\n  }\n  /**\n   *  Iterate over all functions, calling %%callback%%, sorted by their name.\n   */\n  forEachFunction(callback) {\n    const names = Array.from(_classPrivateFieldGet(_functions, this).keys());\n    names.sort((a, b) => a.localeCompare(b));\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(_classPrivateFieldGet(_functions, this).get(name), i);\n    }\n  }\n  // Find an event definition by any means necessary (unless it is ambiguous)\n\n  /**\n   *  Get the event name for %%key%%, which may be a topic hash,\n   *  event name or event signature that belongs to the ABI.\n   */\n  getEventName(key) {\n    const fragment = _assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, null, false);\n    assertArgument(fragment, \"no matching event\", \"key\", key);\n    return fragment.name;\n  }\n  /**\n   *  Returns true if %%key%% (an event topic hash, event name or\n   *  event signature) is present in the ABI.\n   *\n   *  In the case of an event name, the name may be ambiguous, so\n   *  accessing the [[EventFragment]] may require refinement.\n   */\n  hasEvent(key) {\n    return !!_assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, null, false);\n  }\n  /**\n   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n   *  event name or event signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple events match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single event in\n   *  the ABI, this will throw.\n   */\n  getEvent(key, values) {\n    return _assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, values || null, true);\n  }\n  /**\n   *  Iterate over all events, calling %%callback%%, sorted by their name.\n   */\n  forEachEvent(callback) {\n    const names = Array.from(_classPrivateFieldGet(_events, this).keys());\n    names.sort((a, b) => a.localeCompare(b));\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(_classPrivateFieldGet(_events, this).get(name), i);\n    }\n  }\n  /**\n   *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n   *  selector, error name or error signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple errors match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single error in\n   *  the ABI, this will throw.\n   */\n  getError(key, values) {\n    if (isHexString(key)) {\n      const selector = key.toLowerCase();\n      if (BuiltinErrors[selector]) {\n        return ErrorFragment.from(BuiltinErrors[selector].signature);\n      }\n      for (const fragment of _classPrivateFieldGet(_errors, this).values()) {\n        if (selector === fragment.selector) {\n          return fragment;\n        }\n      }\n      return null;\n    }\n    // It is a bare name, look up the function (will return null if ambiguous)\n    if (key.indexOf(\"(\") === -1) {\n      const matching = [];\n      for (const [name, fragment] of _classPrivateFieldGet(_errors, this)) {\n        if (name.split(\"(\" /* fix:) */)[0] === key) {\n          matching.push(fragment);\n        }\n      }\n      if (matching.length === 0) {\n        if (key === \"Error\") {\n          return ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic\") {\n          return ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        return null;\n      } else if (matching.length > 1) {\n        const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n        assertArgument(false, \"ambiguous error description (i.e. \".concat(matchStr, \")\"), \"name\", key);\n      }\n      return matching[0];\n    }\n    // Normalize the signature and lookup the function\n    key = ErrorFragment.from(key).format();\n    if (key === \"Error(string)\") {\n      return ErrorFragment.from(\"error Error(string)\");\n    }\n    if (key === \"Panic(uint256)\") {\n      return ErrorFragment.from(\"error Panic(uint256)\");\n    }\n    const result = _classPrivateFieldGet(_errors, this).get(key);\n    if (result) {\n      return result;\n    }\n    return null;\n  }\n  /**\n   *  Iterate over all errors, calling %%callback%%, sorted by their name.\n   */\n  forEachError(callback) {\n    const names = Array.from(_classPrivateFieldGet(_errors, this).keys());\n    names.sort((a, b) => a.localeCompare(b));\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(_classPrivateFieldGet(_errors, this).get(name), i);\n    }\n  }\n  // Get the 4-byte selector used by Solidity to identify a function\n  /*\n  getSelector(fragment: ErrorFragment | FunctionFragment): string {\n  if (typeof(fragment) === \"string\") {\n      const matches: Array<Fragment> = [ ];\n       try { matches.push(this.getFunction(fragment)); } catch (error) { }\n      try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n       if (matches.length === 0) {\n          logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n      } else if (matches.length > 1) {\n          logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n      }\n       fragment = matches[0];\n  }\n   return dataSlice(id(fragment.format()), 0, 4);\n  }\n  */\n  // Get the 32-byte topic hash used by Solidity to identify an event\n  /*\n  getEventTopic(fragment: EventFragment): string {\n      //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n      return id(fragment.format());\n  }\n  */\n  _decodeParams(params, data) {\n    return _classPrivateFieldGet(_abiCoder, this).decode(params, data);\n  }\n  _encodeParams(params, values) {\n    return _classPrivateFieldGet(_abiCoder, this).encode(params, values);\n  }\n  /**\n   *  Encodes a ``tx.data`` object for deploying the Contract with\n   *  the %%values%% as the constructor arguments.\n   */\n  encodeDeploy(values) {\n    return this._encodeParams(this.deploy.inputs, values || []);\n  }\n  /**\n   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n   *  specified error (see [[getError]] for valid values for\n   *  %%key%%).\n   *\n   *  Most developers should prefer the [[parseCallResult]] method instead,\n   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n   *  corresponding error.\n   */\n  decodeErrorResult(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getError(fragment);\n      assertArgument(f, \"unknown error\", \"fragment\", fragment);\n      fragment = f;\n    }\n    assertArgument(dataSlice(data, 0, 4) === fragment.selector, \"data signature does not match error \".concat(fragment.name, \".\"), \"data\", data);\n    return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n  }\n  /**\n   *  Encodes the transaction revert data for a call result that\n   *  reverted from the the Contract with the sepcified %%error%%\n   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n   *\n   *  This is generally not used by most developers, unless trying to mock\n   *  a result from a Contract.\n   */\n  encodeErrorResult(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getError(fragment);\n      assertArgument(f, \"unknown error\", \"fragment\", fragment);\n      fragment = f;\n    }\n    return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n  }\n  /**\n   *  Decodes the %%data%% from a transaction ``tx.data`` for\n   *  the function specified (see [[getFunction]] for valid values\n   *  for %%fragment%%).\n   *\n   *  Most developers should prefer the [[parseTransaction]] method\n   *  instead, which will automatically detect the fragment.\n   */\n  decodeFunctionData(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    assertArgument(dataSlice(data, 0, 4) === fragment.selector, \"data signature does not match function \".concat(fragment.name, \".\"), \"data\", data);\n    return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n  }\n  /**\n   *  Encodes the ``tx.data`` for a transaction that calls the function\n   *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n   *  the %%values%%.\n   */\n  encodeFunctionData(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n  }\n  /**\n   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n   *  specified function (see [[getFunction]] for valid values for\n   *  %%key%%).\n   *\n   *  Most developers should prefer the [[parseCallResult]] method instead,\n   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n   *  corresponding error.\n   */\n  decodeFunctionResult(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    let message = \"invalid length for result data\";\n    const bytes = getBytesCopy(data);\n    if (bytes.length % 32 === 0) {\n      try {\n        return _classPrivateFieldGet(_abiCoder, this).decode(fragment.outputs, bytes);\n      } catch (error) {\n        message = \"could not decode result data\";\n      }\n    }\n    // Call returned data with no error, but the data is junk\n    assert(false, message, \"BAD_DATA\", {\n      value: hexlify(bytes),\n      info: {\n        method: fragment.name,\n        signature: fragment.format()\n      }\n    });\n  }\n  makeError(_data, tx) {\n    const data = getBytes(_data, \"data\");\n    const error = AbiCoder.getBuiltinCallException(\"call\", tx, data);\n    // Not a built-in error; try finding a custom error\n    const customPrefix = \"execution reverted (unknown custom error)\";\n    if (error.message.startsWith(customPrefix)) {\n      const selector = hexlify(data.slice(0, 4));\n      const ef = this.getError(selector);\n      if (ef) {\n        try {\n          const args = _classPrivateFieldGet(_abiCoder, this).decode(ef.inputs, data.slice(4));\n          error.revert = {\n            name: ef.name,\n            signature: ef.format(),\n            args\n          };\n          error.reason = error.revert.signature;\n          error.message = \"execution reverted: \".concat(error.reason);\n        } catch (e) {\n          error.message = \"execution reverted (coult not decode custom error)\";\n        }\n      }\n    }\n    // Add the invocation, if available\n    const parsed = this.parseTransaction(tx);\n    if (parsed) {\n      error.invocation = {\n        method: parsed.name,\n        signature: parsed.signature,\n        args: parsed.args\n      };\n    }\n    return error;\n  }\n  /**\n   *  Encodes the result data (e.g. from an ``eth_call``) for the\n   *  specified function (see [[getFunction]] for valid values\n   *  for %%fragment%%) with %%values%%.\n   *\n   *  This is generally not used by most developers, unless trying to mock\n   *  a result from a Contract.\n   */\n  encodeFunctionResult(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    return hexlify(_classPrivateFieldGet(_abiCoder, this).encode(fragment.outputs, values || []));\n  }\n  /*\n      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n          const promises: Array<Promise<>> = [ ];\n          const process = function(type: ParamType, value: any): any {\n              if (type.baseType === \"array\") {\n                  return descend(type.child\n              }\n              if (type. === \"address\") {\n              }\n          };\n  \n          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n              if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n              \n          };\n  \n          const result: Array<any> = [ ];\n          values.forEach((value, index) => {\n              if (value == null) {\n                  topics.push(null);\n              } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                  logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n              } else if (Array.isArray(value)) {\n                  topics.push(value.map((value) => encodeTopic(param, value)));\n              } else {\n                  topics.push(encodeTopic(param, value));\n              }\n          });\n      }\n  */\n  // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n  encodeFilterTopics(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n    assert(values.length <= fragment.inputs.length, \"too many arguments for \".concat(fragment.format()), \"UNEXPECTED_ARGUMENT\", {\n      count: values.length,\n      expectedCount: fragment.inputs.length\n    });\n    const topics = [];\n    if (!fragment.anonymous) {\n      topics.push(fragment.topicHash);\n    }\n    // @TODO: Use the coders for this; to properly support tuples, etc.\n    const encodeTopic = (param, value) => {\n      if (param.type === \"string\") {\n        return id(value);\n      } else if (param.type === \"bytes\") {\n        return keccak256(hexlify(value));\n      }\n      if (param.type === \"bool\" && typeof value === \"boolean\") {\n        value = value ? \"0x01\" : \"0x00\";\n      } else if (param.type.match(/^u?int/)) {\n        value = toBeHex(value); // @TODO: Should this toTwos??\n      } else if (param.type.match(/^bytes/)) {\n        value = zeroPadBytes(value, 32);\n      } else if (param.type === \"address\") {\n        // Check addresses are valid\n        _classPrivateFieldGet(_abiCoder, this).encode([\"address\"], [value]);\n      }\n      return zeroPadValue(hexlify(value), 32);\n    };\n    values.forEach((value, index) => {\n      const param = fragment.inputs[index];\n      if (!param.indexed) {\n        assertArgument(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n        return;\n      }\n      if (value == null) {\n        topics.push(null);\n      } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n        assertArgument(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n      } else if (Array.isArray(value)) {\n        topics.push(value.map(value => encodeTopic(param, value)));\n      } else {\n        topics.push(encodeTopic(param, value));\n      }\n    });\n    // Trim off trailing nulls\n    while (topics.length && topics[topics.length - 1] === null) {\n      topics.pop();\n    }\n    return topics;\n  }\n  encodeEventLog(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n    const topics = [];\n    const dataTypes = [];\n    const dataValues = [];\n    if (!fragment.anonymous) {\n      topics.push(fragment.topicHash);\n    }\n    assertArgument(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n    fragment.inputs.forEach((param, index) => {\n      const value = values[index];\n      if (param.indexed) {\n        if (param.type === \"string\") {\n          topics.push(id(value));\n        } else if (param.type === \"bytes\") {\n          topics.push(keccak256(value));\n        } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n          // @TODO\n          throw new Error(\"not implemented\");\n        } else {\n          topics.push(_classPrivateFieldGet(_abiCoder, this).encode([param.type], [value]));\n        }\n      } else {\n        dataTypes.push(param);\n        dataValues.push(value);\n      }\n    });\n    return {\n      data: _classPrivateFieldGet(_abiCoder, this).encode(dataTypes, dataValues),\n      topics: topics\n    };\n  }\n  // Decode a filter for the event and the search criteria\n  decodeEventLog(fragment, data, topics) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n    if (topics != null && !fragment.anonymous) {\n      const eventTopic = fragment.topicHash;\n      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n      topics = topics.slice(1);\n    }\n    const indexed = [];\n    const nonIndexed = [];\n    const dynamic = [];\n    fragment.inputs.forEach((param, index) => {\n      if (param.indexed) {\n        if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n          indexed.push(ParamType.from({\n            type: \"bytes32\",\n            name: param.name\n          }));\n          dynamic.push(true);\n        } else {\n          indexed.push(param);\n          dynamic.push(false);\n        }\n      } else {\n        nonIndexed.push(param);\n        dynamic.push(false);\n      }\n    });\n    const resultIndexed = topics != null ? _classPrivateFieldGet(_abiCoder, this).decode(indexed, concat(topics)) : null;\n    const resultNonIndexed = _classPrivateFieldGet(_abiCoder, this).decode(nonIndexed, data, true);\n    //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n    const values = [];\n    const keys = [];\n    let nonIndexedIndex = 0,\n      indexedIndex = 0;\n    fragment.inputs.forEach((param, index) => {\n      let value = null;\n      if (param.indexed) {\n        if (resultIndexed == null) {\n          value = new Indexed(null);\n        } else if (dynamic[index]) {\n          value = new Indexed(resultIndexed[indexedIndex++]);\n        } else {\n          try {\n            value = resultIndexed[indexedIndex++];\n          } catch (error) {\n            value = error;\n          }\n        }\n      } else {\n        try {\n          value = resultNonIndexed[nonIndexedIndex++];\n        } catch (error) {\n          value = error;\n        }\n      }\n      values.push(value);\n      keys.push(param.name || null);\n    });\n    return Result.fromItems(values, keys);\n  }\n  /**\n   *  Parses a transaction, finding the matching function and extracts\n   *  the parameter values along with other useful function details.\n   *\n   *  If the matching function cannot be found, return null.\n   */\n  parseTransaction(tx) {\n    const data = getBytes(tx.data, \"tx.data\");\n    const value = getBigInt(tx.value != null ? tx.value : 0, \"tx.value\");\n    const fragment = this.getFunction(hexlify(data.slice(0, 4)));\n    if (!fragment) {\n      return null;\n    }\n    const args = _classPrivateFieldGet(_abiCoder, this).decode(fragment.inputs, data.slice(4));\n    return new TransactionDescription(fragment, fragment.selector, args, value);\n  }\n  parseCallResult(data) {\n    throw new Error(\"@TODO\");\n  }\n  /**\n   *  Parses a receipt log, finding the matching event and extracts\n   *  the parameter values along with other useful event details.\n   *\n   *  If the matching event cannot be found, returns null.\n   */\n  parseLog(log) {\n    const fragment = this.getEvent(log.topics[0]);\n    if (!fragment || fragment.anonymous) {\n      return null;\n    }\n    // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n    //        Probably not, because just because it is the only event in the ABI does\n    //        not mean we have the full ABI; maybe just a fragment?\n    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n  }\n  /**\n   *  Parses a revert data, finding the matching error and extracts\n   *  the parameter values along with other useful error details.\n   *\n   *  If the matching error cannot be found, returns null.\n   */\n  parseError(data) {\n    const hexData = hexlify(data);\n    const fragment = this.getError(dataSlice(hexData, 0, 4));\n    if (!fragment) {\n      return null;\n    }\n    const args = _classPrivateFieldGet(_abiCoder, this).decode(fragment.inputs, dataSlice(hexData, 4));\n    return new ErrorDescription(fragment, fragment.selector, args);\n  }\n  /**\n   *  Creates a new [[Interface]] from the ABI %%value%%.\n   *\n   *  The %%value%% may be provided as an existing [[Interface]] object,\n   *  a JSON-encoded ABI or any Human-Readable ABI format.\n   */\n  static from(value) {\n    // Already an Interface, which is immutable\n    if (value instanceof Interface) {\n      return value;\n    }\n    // JSON\n    if (typeof value === \"string\") {\n      return new Interface(JSON.parse(value));\n    }\n    // An Interface; possibly from another v6 instance\n    if (typeof value.formatJson === \"function\") {\n      return new Interface(value.formatJson());\n    }\n    // A legacy Interface; from an older version\n    if (typeof value.format === \"function\") {\n      return new Interface(value.format(\"json\"));\n    }\n    // Array of fragments\n    return new Interface(value);\n  }\n}\nfunction _getFunction(key, values, forceUnique) {\n  // Selector\n  if (isHexString(key)) {\n    const selector = key.toLowerCase();\n    for (const fragment of _classPrivateFieldGet(_functions, this).values()) {\n      if (selector === fragment.selector) {\n        return fragment;\n      }\n    }\n    return null;\n  }\n  // It is a bare name, look up the function (will return null if ambiguous)\n  if (key.indexOf(\"(\") === -1) {\n    const matching = [];\n    for (const [name, fragment] of _classPrivateFieldGet(_functions, this)) {\n      if (name.split(\"(\" /* fix:) */)[0] === key) {\n        matching.push(fragment);\n      }\n    }\n    if (values) {\n      const lastValue = values.length > 0 ? values[values.length - 1] : null;\n      let valueLength = values.length;\n      let allowOptions = true;\n      if (Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n        allowOptions = false;\n        valueLength--;\n      }\n      // Remove all matches that don't have a compatible length. The args\n      // may contain an overrides, so the match may have n or n - 1 parameters\n      for (let i = matching.length - 1; i >= 0; i--) {\n        const inputs = matching[i].inputs.length;\n        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n          matching.splice(i, 1);\n        }\n      }\n      // Remove all matches that don't match the Typed signature\n      for (let i = matching.length - 1; i >= 0; i--) {\n        const inputs = matching[i].inputs;\n        for (let j = 0; j < values.length; j++) {\n          // Not a typed value\n          if (!Typed.isTyped(values[j])) {\n            continue;\n          }\n          // We are past the inputs\n          if (j >= inputs.length) {\n            if (values[j].type === \"overrides\") {\n              continue;\n            }\n            matching.splice(i, 1);\n            break;\n          }\n          // Make sure the value type matches the input type\n          if (values[j].type !== inputs[j].baseType) {\n            matching.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n    // We found a single matching signature with an overrides, but the\n    // last value is something that cannot possibly be an options\n    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n      const lastArg = values[values.length - 1];\n      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n        matching.splice(0, 1);\n      }\n    }\n    if (matching.length === 0) {\n      return null;\n    }\n    if (matching.length > 1 && forceUnique) {\n      const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n      assertArgument(false, \"ambiguous function description (i.e. matches \".concat(matchStr, \")\"), \"key\", key);\n    }\n    return matching[0];\n  }\n  // Normalize the signature and lookup the function\n  const result = _classPrivateFieldGet(_functions, this).get(FunctionFragment.from(key).format());\n  if (result) {\n    return result;\n  }\n  return null;\n}\nfunction _getEvent(key, values, forceUnique) {\n  // EventTopic\n  if (isHexString(key)) {\n    const eventTopic = key.toLowerCase();\n    for (const fragment of _classPrivateFieldGet(_events, this).values()) {\n      if (eventTopic === fragment.topicHash) {\n        return fragment;\n      }\n    }\n    return null;\n  }\n  // It is a bare name, look up the function (will return null if ambiguous)\n  if (key.indexOf(\"(\") === -1) {\n    const matching = [];\n    for (const [name, fragment] of _classPrivateFieldGet(_events, this)) {\n      if (name.split(\"(\" /* fix:) */)[0] === key) {\n        matching.push(fragment);\n      }\n    }\n    if (values) {\n      // Remove all matches that don't have a compatible length.\n      for (let i = matching.length - 1; i >= 0; i--) {\n        if (matching[i].inputs.length < values.length) {\n          matching.splice(i, 1);\n        }\n      }\n      // Remove all matches that don't match the Typed signature\n      for (let i = matching.length - 1; i >= 0; i--) {\n        const inputs = matching[i].inputs;\n        for (let j = 0; j < values.length; j++) {\n          // Not a typed value\n          if (!Typed.isTyped(values[j])) {\n            continue;\n          }\n          // Make sure the value type matches the input type\n          if (values[j].type !== inputs[j].baseType) {\n            matching.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n    if (matching.length === 0) {\n      return null;\n    }\n    if (matching.length > 1 && forceUnique) {\n      const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n      assertArgument(false, \"ambiguous event description (i.e. matches \".concat(matchStr, \")\"), \"key\", key);\n    }\n    return matching[0];\n  }\n  // Normalize the signature and lookup the function\n  const result = _classPrivateFieldGet(_events, this).get(EventFragment.from(key).format());\n  if (result) {\n    return result;\n  }\n  return null;\n}","map":{"version":3,"names":["keccak256","id","concat","dataSlice","getBigInt","getBytes","getBytesCopy","hexlify","zeroPadBytes","zeroPadValue","isHexString","defineProperties","assertArgument","toBeHex","assert","AbiCoder","checkResultErrors","Result","ConstructorFragment","ErrorFragment","EventFragment","Fragment","FunctionFragment","ParamType","Typed","LogDescription","constructor","fragment","topic","args","_defineProperty","name","signature","format","TransactionDescription","selector","value","ErrorDescription","Indexed","isIndexed","_isIndexed","hash","PanicReasons","BuiltinErrors","inputs","reason","message","JSON","stringify","code","toString","_errors","WeakMap","_events","_functions","_abiCoder","_Interface_brand","WeakSet","Interface","fragments","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","abi","parse","_classPrivateFieldSet","Map","frags","a","push","from","error","console","log","Object","freeze","fallback","receive","getAbiCoder","forEach","index","bucket","type","deploy","length","payable","_classPrivateFieldGet","has","set","minimal","map","f","formatJson","j","defaultAbiCoder","getFunctionName","key","_assertClassBrand","_getFunction","call","hasFunction","getFunction","values","forEachFunction","callback","names","Array","keys","sort","b","localeCompare","i","get","getEventName","_getEvent","hasEvent","getEvent","forEachEvent","getError","toLowerCase","indexOf","matching","split","matchStr","m","join","result","forEachError","_decodeParams","params","data","decode","_encodeParams","encode","encodeDeploy","decodeErrorResult","encodeErrorResult","decodeFunctionData","encodeFunctionData","decodeFunctionResult","bytes","outputs","info","method","makeError","_data","tx","getBuiltinCallException","customPrefix","startsWith","slice","ef","revert","e","parsed","parseTransaction","invocation","encodeFunctionResult","encodeFilterTopics","count","expectedCount","topics","anonymous","topicHash","encodeTopic","param","match","indexed","baseType","isArray","pop","encodeEventLog","dataTypes","dataValues","Error","decodeEventLog","eventTopic","nonIndexed","dynamic","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","fromItems","parseCallResult","parseLog","parseError","hexData","forceUnique","lastValue","valueLength","allowOptions","isTyped","splice","lastArg"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/ethers/src.ts/abi/interface.ts"],"sourcesContent":["/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\n\nimport { keccak256 } from \"../crypto/index.js\"\nimport { id } from \"../hash/index.js\"\nimport {\n    concat, dataSlice, getBigInt, getBytes, getBytesCopy,\n    hexlify, zeroPadBytes, zeroPadValue, isHexString, defineProperties,\n    assertArgument, toBeHex, assert\n} from \"../utils/index.js\";\n\nimport { AbiCoder } from \"./abi-coder.js\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder.js\";\nimport {\n    ConstructorFragment, ErrorFragment, EventFragment, FallbackFragment,\n    Fragment, FunctionFragment, ParamType\n} from \"./fragments.js\";\nimport { Typed } from \"./typed.js\";\n\nimport type { BigNumberish, BytesLike, CallExceptionError, CallExceptionTransaction } from \"../utils/index.js\";\n\nimport type { JsonFragment } from \"./fragments.js\";\n\n\nexport { checkResultErrors, Result };\n\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */\nexport class LogDescription {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    readonly fragment!: EventFragment;\n\n    /**\n     *  The name of the Event.\n     */\n    readonly name!: string;\n\n    /**\n     *  The full Event signature.\n     */\n    readonly signature!: string;\n\n    /**\n     *  The topic hash for the Event.\n     */\n    readonly topic!: string;\n\n    /**\n     *  The arguments passed into the Event with ``emit``.\n     */\n    readonly args!: Result\n\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment: EventFragment, topic: string, args: Result) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<LogDescription>(this, {\n            fragment, name, signature, topic, args\n        });\n    }\n}\n\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */\nexport class TransactionDescription {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    readonly fragment!: FunctionFragment;\n\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments passed to the Function from the transaction ``data``.\n     */\n    readonly args!: Result;\n\n    /**\n     *  The full Function signature from the transaction ``data``.\n     */\n    readonly signature!: string;\n\n    /**\n     *  The selector for the Function from the transaction ``data``.\n     */\n    readonly selector!: string;\n\n    /**\n     *  The ``value`` (in wei) from the transaction.\n     */\n    readonly value!: bigint;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment: FunctionFragment, selector: string, args: Result, value: bigint) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<TransactionDescription>(this, {\n            fragment, name, args, signature, selector, value\n        });\n    }\n}\n\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */\nexport class ErrorDescription {\n    /**\n     *  The matching fragment.\n     */\n    readonly fragment!: ErrorFragment;\n\n    /**\n     *  The name of the Error.\n     */\n    readonly name!: string;\n\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    readonly args!: Result;\n\n    /**\n     *  The full Error signature.\n     */\n    readonly signature!: string;\n\n    /**\n     *  The selector for the Error.\n     */\n    readonly selector!: string;\n\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment: ErrorFragment, selector: string, args: Result) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<ErrorDescription>(this, {\n            fragment, name, args, signature, selector\n        });\n    }\n}\n\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */\nexport class Indexed {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    readonly hash!: null | string;\n\n    /**\n     *  @_ignore:\n     */\n    readonly _isIndexed!: boolean;\n\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n\n    /**\n     *  @_ignore:\n     */\n    constructor(hash: null | string) {\n        defineProperties<Indexed>(this, { hash, _isIndexed: true })\n    }\n}\n\ntype ErrorInfo = {\n    signature: string,\n    inputs: Array<string>,\n    name: string,\n    reason: (...args: Array<any>) => string;\n};\n\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons: Record<string, string> = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\",\n}\n\nconst BuiltinErrors: Record<string, ErrorInfo> = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [ \"string\" ],\n        reason: (message: string) => {\n            return `reverted with reason string ${ JSON.stringify(message) }`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [ \"uint256\" ],\n        reason: (code: bigint) => {\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${ code.toString(16) } (${ reason })`;\n        }\n    }\n}\n\n/*\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n*/\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\n\n/**\n *  An **InterfaceAbi** may be any supported ABI format.\n *\n *  A string is expected to be a JSON string, which will be parsed\n *  using ``JSON.parse``. This means that the value **must** be a valid\n *  JSON string, with no stray commas, etc.\n *\n *  An array may contain any combination of:\n *  - Human-Readable fragments\n *  - Parsed JSON fragment\n *  - [[Fragment]] instances\n *\n *  A **Human-Readable Fragment** is a string which resembles a Solidity\n *  signature and is introduced in [this blog entry](link-ricmoo-humanreadableabi).\n *  For example, ``function balanceOf(address) view returns (uint)``.\n *\n *  A **Parsed JSON Fragment** is a JavaScript Object desribed in the\n *  [Solidity documentation](link-solc-jsonabi).\n */\nexport type InterfaceAbi = string | ReadonlyArray<Fragment | JsonFragment | string>;\n\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nexport class Interface {\n\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    readonly fragments!: ReadonlyArray<Fragment>;\n\n    /**\n     *  The Contract constructor.\n     */\n    readonly deploy!: ConstructorFragment;\n\n    /**\n     *  The Fallback method, if any.\n     */\n    readonly fallback!: null | FallbackFragment;\n\n    /**\n     *  If receiving ether is supported.\n     */\n    readonly receive!: boolean;\n\n    #errors: Map<string, ErrorFragment>;\n    #events: Map<string, EventFragment>;\n    #functions: Map<string, FunctionFragment>;\n//    #structs: Map<string, StructFragment>;\n\n    #abiCoder: AbiCoder;\n\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */\n    constructor(fragments: InterfaceAbi) {\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n//        this.#structs = new Map();\n\n\n        const frags: Array<Fragment> = [ ];\n        for (const a of abi) {\n            try {\n                frags.push(Fragment.from(a));\n            } catch (error: any) {\n                console.log(`[Warning] Invalid Fragment ${ JSON.stringify(a) }:`, error.message);\n            }\n        }\n\n        defineProperties<Interface>(this, {\n            fragments: Object.freeze(frags)\n        });\n\n        let fallback: null | FallbackFragment = null;\n        let receive = false;\n\n        this.#abiCoder = this.getAbiCoder();\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index) => {\n            let bucket: Map<string, Fragment>;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineProperties<Interface>(this, { deploy: <ConstructorFragment>fragment });\n                    return;\n\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        assertArgument(!fallback || (<FallbackFragment>fragment).payable !== fallback.payable,\n                            \"conflicting fallback fragments\", `fragments[${ index }]`, fragment);\n                        fallback = <FallbackFragment>fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n\n                default:\n                    return;\n            }\n\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) { return; }\n\n            bucket.set(signature, fragment);\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineProperties<Interface>(this, {\n                deploy: ConstructorFragment.from(\"constructor()\")\n            });\n        }\n\n        defineProperties<Interface>(this, { fallback, receive });\n    }\n\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */\n    format(minimal?: boolean): Array<string> {\n        const format = (minimal ? \"minimal\": \"full\");\n        const abi = this.fragments.map((f) => f.format(format));\n        return abi;\n    }\n\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */\n    formatJson(): string {\n        const abi = this.fragments.map((f) => f.format(\"json\"));\n\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j) => JSON.parse(j)));\n    }\n\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */\n    getAbiCoder(): AbiCoder {\n        return AbiCoder.defaultAbiCoder();\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key: string, values: null | Array<any | Typed>, forceUnique: boolean): null | FunctionFragment {\n\n        // Selector\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()) {\n                if (selector === fragment.selector) { return fragment; }\n            }\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching: Array<FunctionFragment> = [ ];\n            for (const [ name, fragment ] of this.#functions) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (values) {\n                const lastValue = (values.length > 0) ? values[values.length - 1]: null;\n\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) { continue; }\n\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") { continue; }\n                            matching.splice(i, 1);\n                            break;\n                        }\n\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof(lastArg) !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n\n            if (matching.length === 0) { return null; }\n\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous function description (i.e. matches ${ matchStr })`, \"key\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(FunctionFragment.from(key).format());\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */\n    getFunctionName(key: string): string {\n        const fragment = this.#getFunction(key, null, false);\n        assertArgument(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */\n    hasFunction(key: string): boolean {\n        return !!this.#getFunction(key, null, false);\n    }\n\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */\n    getFunction(key: string, values?: Array<any | Typed>): null | FunctionFragment {\n        return this.#getFunction(key, values || null, true);\n    }\n\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */\n    forEachFunction(callback: (func: FunctionFragment, index: number) => void): void {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<FunctionFragment>(this.#functions.get(name)), i);\n        }\n    }\n\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key: string, values: null | Array<null | any | Typed>, forceUnique: boolean): null | EventFragment {\n\n        // EventTopic\n        if (isHexString(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()) {\n                if (eventTopic === fragment.topicHash) { return fragment; }\n            }\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching: Array<EventFragment> = [ ];\n            for (const [ name, fragment ] of this.#events) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) { continue; }\n\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (matching.length === 0) { return null; }\n\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous event description (i.e. matches ${ matchStr })`, \"key\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(EventFragment.from(key).format());\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */\n    getEventName(key: string): string {\n        const fragment = this.#getEvent(key, null, false);\n        assertArgument(fragment, \"no matching event\", \"key\", key);\n\n        return fragment.name;\n    }\n\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */\n    hasEvent(key: string): boolean {\n        return !!this.#getEvent(key, null, false);\n    }\n\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */\n    getEvent(key: string, values?: Array<any | Typed>): null | EventFragment {\n        return this.#getEvent(key, values || null, true)\n    }\n\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */\n    forEachEvent(callback: (func: EventFragment, index: number) => void): void {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<EventFragment>(this.#events.get(name)), i);\n        }\n    }\n\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */\n    getError(key: string, values?: Array<any | Typed>): null | ErrorFragment {\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n\n            if (BuiltinErrors[selector]) {\n                return ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n\n            for (const fragment of this.#errors.values()) {\n                if (selector === fragment.selector) { return fragment; }\n            }\n\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching: Array<ErrorFragment> = [ ];\n            for (const [ name, fragment ] of this.#errors) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (matching.length === 0) {\n                if (key === \"Error\") { return ErrorFragment.from(\"error Error(string)\"); }\n                if (key === \"Panic\") { return ErrorFragment.from(\"error Panic(uint256)\"); }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous error description (i.e. ${ matchStr })`, \"name\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        key = ErrorFragment.from(key).format()\n        if (key === \"Error(string)\") { return ErrorFragment.from(\"error Error(string)\"); }\n        if (key === \"Panic(uint256)\") { return ErrorFragment.from(\"error Panic(uint256)\"); }\n\n        const result = this.#errors.get(key);\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */\n    forEachError(callback: (func: ErrorFragment, index: number) => void): void {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<ErrorFragment>(this.#errors.get(name)), i);\n        }\n    }\n\n    // Get the 4-byte selector used by Solidity to identify a function\n        /*\n    getSelector(fragment: ErrorFragment | FunctionFragment): string {\n        if (typeof(fragment) === \"string\") {\n            const matches: Array<Fragment> = [ ];\n\n            try { matches.push(this.getFunction(fragment)); } catch (error) { }\n            try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n            if (matches.length === 0) {\n                logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n            } else if (matches.length > 1) {\n                logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n            }\n\n            fragment = matches[0];\n        }\n\n        return dataSlice(id(fragment.format()), 0, 4);\n    }\n        */\n\n    // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this.#abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this.#abiCoder.encode(params, values)\n    }\n\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector,\n            `data signature does not match error ${ fragment.name }.`, \"data\", data);\n\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]);\n    }\n\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */\n    decodeFunctionData(fragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector,\n            `data signature does not match function ${ fragment.name }.`, \"data\", data);\n\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */\n    encodeFunctionData(fragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]);\n    }\n\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeFunctionResult(fragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        let message = \"invalid length for result data\";\n\n        const bytes = getBytesCopy(data);\n        if ((bytes.length % 32) === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n\n        // Call returned data with no error, but the data is junk\n        assert(false, message, \"BAD_DATA\", {\n            value: hexlify(bytes),\n            info: { method: fragment.name, signature: fragment.format() }\n        });\n    }\n\n    makeError(_data: BytesLike, tx: CallExceptionTransaction): CallExceptionError {\n        const data = getBytes(_data, \"data\");\n\n        const error = AbiCoder.getBuiltinCallException(\"call\", tx, data);\n\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = hexlify(data.slice(0, 4));\n\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name, signature: ef.format(), args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${ error.reason }`\n                 } catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`\n                }\n            }\n        }\n\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n\n        return error;\n    }\n\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeFunctionResult(fragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return hexlify(this.#abiCoder.encode(fragment.outputs, values || [ ]));\n    }\n/*\n    spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n        const promises: Array<Promise<>> = [ ];\n        const process = function(type: ParamType, value: any): any {\n            if (type.baseType === \"array\") {\n                return descend(type.child\n            }\n            if (type. === \"address\") {\n            }\n        };\n\n        const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n            if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n            \n        };\n\n        const result: Array<any> = [ ];\n        values.forEach((value, index) => {\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n    }\n*/\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment: EventFragment | string, values: ReadonlyArray<any>): Array<null | string | Array<string>> {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        assert(values.length <= fragment.inputs.length, `too many arguments for ${ fragment.format() }`,\n            \"UNEXPECTED_ARGUMENT\", { count: values.length, expectedCount: fragment.inputs.length })\n\n        const topics: Array<null | string | Array<string>> = [];\n        if (!fragment.anonymous) { topics.push(fragment.topicHash); }\n\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            if (param.type === \"bool\" && typeof(value) === \"boolean\") {\n                value = (value ? \"0x01\": \"0x00\");\n            } else if (param.type.match(/^u?int/)) {\n                value = toBeHex(value);  // @TODO: Should this toTwos??\n            } else if (param.type.match(/^bytes/)) {\n                value = zeroPadBytes(value, 32);\n            } else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode( [ \"address\" ], [ value ]);\n            }\n\n            return zeroPadValue(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            const param = (<EventFragment>fragment).inputs[index];\n\n            if (!param.indexed) {\n                assertArgument(value == null,\n                    \"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                assertArgument(false, \"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(fragment: EventFragment | string, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n\n        assertArgument(values.length === fragment.inputs.length,\n            \"event arguments/values mismatch\", \"values\", values);\n\n        fragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this.#abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this.#abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic,\n                \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n\n        const indexed: Array<ParamType> = [];\n        const nonIndexed: Array<ParamType> = [];\n        const dynamic: Array<boolean> = [];\n\n        fragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.from({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, concat(topics)): null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values: Array<any> = [ ];\n        const keys: Array<null | string> = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index) => {\n            let value: null | Indexed | Error = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error: any) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error: any) {\n                    value = error;\n                }\n            }\n\n            values.push(value);\n            keys.push(param.name || null);\n        });\n\n        return Result.fromItems(values, keys);\n    }\n\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */\n    parseTransaction(tx: { data: string, value?: BigNumberish }): null | TransactionDescription {\n        const data = getBytes(tx.data, \"tx.data\");\n        const value = getBigInt((tx.value != null) ? tx.value: 0, \"tx.value\");\n\n        const fragment = this.getFunction(hexlify(data.slice(0, 4)));\n\n        if (!fragment) { return null; }\n\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n\n    parseCallResult(data: BytesLike): Result {\n        throw new Error(\"@TODO\");\n    }\n\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseLog(log: { topics: ReadonlyArray<string>, data: string}): null | LogDescription {\n        const fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */\n    parseError(data: BytesLike): null | ErrorDescription {\n        const hexData = hexlify(data);\n\n        const fragment = this.getError(dataSlice(hexData, 0, 4));\n\n        if (!fragment) { return null; }\n\n        const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */\n    static from(value: InterfaceAbi | Interface): Interface {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) { return value; }\n\n        // JSON\n        if (typeof(value) === \"string\") { return new Interface(JSON.parse(value)); }\n\n        // An Interface; possibly from another v6 instance\n        if (typeof((<any>value).formatJson) === \"function\") {\n            return new Interface((<any>value).formatJson());\n        }\n\n        // A legacy Interface; from an older version\n        if (typeof((<any>value).format) === \"function\") {\n            return new Interface((<any>value).format(\"json\"));\n        }\n\n        // Array of fragments\n        return new Interface(value);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}