{"ast":null,"code":"import { Token, Type } from './token.js';\nimport { assertEnoughData, decodeErrPrefix } from './common.js';\nimport * as uint from './0uint.js';\nimport { compare, fromString, slice } from './byte-utils.js';\nfunction toToken(data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length);\n  const buf = slice(data, pos + prefix, pos + prefix + length);\n  return new Token(Type.bytes, buf, prefix + length);\n}\nexport function decodeBytesCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeBytes8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeBytes16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeBytes32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeBytes64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nfunction tokenBytes(token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;\n  }\n  return token.encodedBytes;\n}\nexport function encodeBytes(buf, token) {\n  const bytes = tokenBytes(token);\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length);\n  buf.push(bytes);\n}\nencodeBytes.encodedSize = function encodedSize(token) {\n  const bytes = tokenBytes(token);\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length;\n};\nencodeBytes.compareTokens = function compareTokens(tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));\n};\nexport function compareBytes(b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);\n}","map":{"version":3,"names":["Token","Type","assertEnoughData","decodeErrPrefix","uint","compare","fromString","slice","toToken","data","pos","prefix","length","buf","bytes","decodeBytesCompact","minor","_options","decodeBytes8","_minor","options","readUint8","decodeBytes16","readUint16","decodeBytes32","readUint32","decodeBytes64","l","readUint64","Error","tokenBytes","token","encodedBytes","undefined","type","string","value","encodeBytes","encodeUintValue","majorEncoded","push","encodedSize","compareTokens","tok1","tok2","compareBytes","b1","b2"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/cborg/esm/lib/2bytes.js"],"sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport {\n  compare,\n  fromString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length);\n  const buf = slice(data, pos + prefix, pos + prefix + length);\n  return new Token(Type.bytes, buf, prefix + length);\n}\nexport function decodeBytesCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeBytes8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeBytes16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeBytes32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeBytes64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer bytes lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nfunction tokenBytes(token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;\n  }\n  return token.encodedBytes;\n}\nexport function encodeBytes(buf, token) {\n  const bytes = tokenBytes(token);\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length);\n  buf.push(bytes);\n}\nencodeBytes.encodedSize = function encodedSize(token) {\n  const bytes = tokenBytes(token);\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length;\n};\nencodeBytes.compareTokens = function compareTokens(tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));\n};\nexport function compareBytes(b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}