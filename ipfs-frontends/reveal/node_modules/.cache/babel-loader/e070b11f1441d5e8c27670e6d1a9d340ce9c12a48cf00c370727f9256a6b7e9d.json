{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _assertClassBrand from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldSet from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport { isError } from \"../utils/index.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _filterIdPromise = /*#__PURE__*/new WeakMap();\nvar _poller = /*#__PURE__*/new WeakMap();\nvar _running = /*#__PURE__*/new WeakMap();\nvar _network = /*#__PURE__*/new WeakMap();\nvar _hault = /*#__PURE__*/new WeakMap();\nvar _FilterIdSubscriber_brand = /*#__PURE__*/new WeakSet();\nexport class FilterIdSubscriber {\n  /**\n   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n   *  and [[_emitResults]] to setup the subscription and provide the event\n   *  to the %%provider%%.\n   */\n  constructor(provider) {\n    _classPrivateMethodInitSpec(this, _FilterIdSubscriber_brand);\n    _classPrivateFieldInitSpec(this, _provider, void 0);\n    _classPrivateFieldInitSpec(this, _filterIdPromise, void 0);\n    _classPrivateFieldInitSpec(this, _poller, void 0);\n    _classPrivateFieldInitSpec(this, _running, void 0);\n    _classPrivateFieldInitSpec(this, _network, void 0);\n    _classPrivateFieldInitSpec(this, _hault, void 0);\n    _classPrivateFieldSet(_provider, this, provider);\n    _classPrivateFieldSet(_filterIdPromise, this, null);\n    _classPrivateFieldSet(_poller, this, _assertClassBrand(_FilterIdSubscriber_brand, this, _poll).bind(this));\n    _classPrivateFieldSet(_running, this, false);\n    _classPrivateFieldSet(_network, this, null);\n    _classPrivateFieldSet(_hault, this, false);\n  }\n  /**\n   *  Sub-classes **must** override this to begin the subscription.\n   */\n  _subscribe(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle the events.\n   */\n  _emitResults(provider, result) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle recovery on errors.\n   */\n  _recover(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  start() {\n    if (_classPrivateFieldGet(_running, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running, this, true);\n    _assertClassBrand(_FilterIdSubscriber_brand, this, _poll).call(this, -2);\n  }\n  stop() {\n    if (!_classPrivateFieldGet(_running, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running, this, false);\n    _classPrivateFieldSet(_hault, this, true);\n    _assertClassBrand(_FilterIdSubscriber_brand, this, _teardown).call(this);\n    _classPrivateFieldGet(_provider, this).off(\"block\", _classPrivateFieldGet(_poller, this));\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      _assertClassBrand(_FilterIdSubscriber_brand, this, _teardown).call(this);\n    }\n    _classPrivateFieldGet(_provider, this).off(\"block\", _classPrivateFieldGet(_poller, this));\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nasync function _poll(blockNumber) {\n  try {\n    // Subscribe if necessary\n    if (_classPrivateFieldGet(_filterIdPromise, this) == null) {\n      _classPrivateFieldSet(_filterIdPromise, this, this._subscribe(_classPrivateFieldGet(_provider, this)));\n    }\n    // Get the Filter ID\n    let filterId = null;\n    try {\n      filterId = await _classPrivateFieldGet(_filterIdPromise, this);\n    } catch (error) {\n      if (!isError(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n        throw error;\n      }\n    }\n    // The backend does not support Filter ID; downgrade to\n    // polling\n    if (filterId == null) {\n      _classPrivateFieldSet(_filterIdPromise, this, null);\n      _classPrivateFieldGet(_provider, this)._recoverSubscriber(this, this._recover(_classPrivateFieldGet(_provider, this)));\n      return;\n    }\n    const network = await _classPrivateFieldGet(_provider, this).getNetwork();\n    if (!_classPrivateFieldGet(_network, this)) {\n      _classPrivateFieldSet(_network, this, network);\n    }\n    if (_classPrivateFieldGet(_network, this).chainId !== network.chainId) {\n      throw new Error(\"chaid changed\");\n    }\n    if (_classPrivateFieldGet(_hault, this)) {\n      return;\n    }\n    const result = await _classPrivateFieldGet(_provider, this).send(\"eth_getFilterChanges\", [filterId]);\n    await this._emitResults(_classPrivateFieldGet(_provider, this), result);\n  } catch (error) {\n    console.log(\"@TODO\", error);\n  }\n  _classPrivateFieldGet(_provider, this).once(\"block\", _classPrivateFieldGet(_poller, this));\n}\nfunction _teardown() {\n  const filterIdPromise = _classPrivateFieldGet(_filterIdPromise, this);\n  if (filterIdPromise) {\n    _classPrivateFieldSet(_filterIdPromise, this, null);\n    filterIdPromise.then(filterId => {\n      if (_classPrivateFieldGet(_provider, this).destroyed) {\n        return;\n      }\n      _classPrivateFieldGet(_provider, this).send(\"eth_uninstallFilter\", [filterId]);\n    });\n  }\n}\nvar _event = /*#__PURE__*/new WeakMap();\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n  /**\n   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n   *  listening for %%filter%%.\n   */\n  constructor(provider, filter) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _event, void 0);\n    _classPrivateFieldSet(_event, this, copy(filter));\n  }\n  _recover(provider) {\n    return new PollingEventSubscriber(provider, _classPrivateFieldGet(_event, this));\n  }\n  async _subscribe(provider) {\n    const filterId = await provider.send(\"eth_newFilter\", [_classPrivateFieldGet(_event, this)]);\n    return filterId;\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(_classPrivateFieldGet(_event, this), provider._wrapLog(result, provider._network));\n    }\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n  async _subscribe(provider) {\n    return await provider.send(\"eth_newPendingTransactionFilter\", []);\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(\"pending\", result);\n    }\n  }\n}","map":{"version":3,"names":["isError","PollingEventSubscriber","copy","obj","JSON","parse","stringify","_provider","WeakMap","_filterIdPromise","_poller","_running","_network","_hault","_FilterIdSubscriber_brand","WeakSet","FilterIdSubscriber","constructor","provider","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateFieldSet","_assertClassBrand","_poll","bind","_subscribe","Error","_emitResults","result","_recover","start","_classPrivateFieldGet","call","stop","_teardown","off","pause","dropWhilePaused","resume","blockNumber","filterId","error","operation","_recoverSubscriber","network","getNetwork","chainId","send","console","log","once","filterIdPromise","then","destroyed","_event","FilterIdEventSubscriber","filter","results","emit","_wrapLog","FilterIdPendingSubscriber"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/ethers/src.ts/providers/subscriber-filterid.ts"],"sourcesContent":["import { isError } from \"../utils/index.js\";\n\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\n\nimport type { AbstractProvider, Subscriber } from \"./abstract-provider.js\";\nimport type { Network } from \"./network.js\";\nimport type { EventFilter } from \"./provider.js\";\nimport type { JsonRpcApiProvider } from \"./provider-jsonrpc.js\";\n\nfunction copy(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdSubscriber implements Subscriber {\n    #provider: JsonRpcApiProvider;\n\n    #filterIdPromise: null | Promise<string>;\n    #poller: (b: number) => Promise<void>;\n\n    #running: boolean;\n\n    #network: null | Network;\n\n    #hault: boolean;\n\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */\n    constructor(provider: JsonRpcApiProvider) {\n        this.#provider = provider;\n\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n\n        this.#running = false;\n\n        this.#network = null;\n\n        this.#hault = false;\n    }\n\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */\n    _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */\n    _emitResults(provider: AbstractProvider, result: Array<any>): Promise<void> {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */\n    _recover(provider: AbstractProvider): Subscriber {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    async #poll(blockNumber: number): Promise<void> {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n\n            // Get the Filter ID\n            let filterId: null | string = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            } catch (error) {\n                if (!isError(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) { this.#network = network; }\n\n            if ((this.#network as Network).chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n\n            if (this.#hault) { return; }\n\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [ filterId ]);\n            await this._emitResults(this.#provider, result);\n        } catch (error) { console.log(\"@TODO\", error); }\n\n        this.#provider.once(\"block\", this.#poller);\n    }\n\n    #teardown(): void {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId) => {\n                if (this.#provider.destroyed) { return; }\n                this.#provider.send(\"eth_uninstallFilter\", [ filterId ]);\n            });\n        }\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        this.#poll(-2);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        if (dropWhilePaused){ this.#teardown(); }\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    resume(): void { this.start(); }\n}\n\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event: EventFilter;\n\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */\n    constructor(provider: JsonRpcApiProvider, filter: EventFilter) {\n        super(provider);\n        this.#event = copy(filter);\n    }\n\n    _recover(provider: AbstractProvider): Subscriber {\n        return new PollingEventSubscriber(provider, this.#event);\n    }\n\n    async _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        const filterId = await provider.send(\"eth_newFilter\", [ this.#event ]);\n        return filterId;\n    }\n\n    async _emitResults(provider: JsonRpcApiProvider, results: Array<any>): Promise<void> {\n        for (const result of results) {\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        return await provider.send(\"eth_newPendingTransactionFilter\", [ ]);\n    }\n\n    async _emitResults(provider: JsonRpcApiProvider, results: Array<any>): Promise<void> {\n        for (const result of results) {\n            provider.emit(\"pending\", result);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}