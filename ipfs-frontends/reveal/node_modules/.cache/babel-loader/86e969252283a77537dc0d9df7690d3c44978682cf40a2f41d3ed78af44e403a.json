{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\n// Use the encode-latin.js script to create the necessary\n// data files to be consumed by this class\nimport { id } from \"../hash/index.js\";\nimport { assertArgument } from \"../utils/index.js\";\nimport { decodeOwl } from \"./decode-owl.js\";\nimport { Wordlist } from \"./wordlist.js\";\n/**\n *  An OWL format Wordlist is an encoding method that exploits\n *  the general locality of alphabetically sorted words to\n *  achieve a simple but effective means of compression.\n *\n *  This class is generally not useful to most developers as\n *  it is used mainly internally to keep Wordlists for languages\n *  based on ASCII-7 small.\n *\n *  If necessary, there are tools within the ``generation/`` folder\n *  to create the necessary data.\n */\nvar _data = /*#__PURE__*/new WeakMap();\nvar _checksum = /*#__PURE__*/new WeakMap();\nvar _words = /*#__PURE__*/new WeakMap();\nvar _WordlistOwl_brand = /*#__PURE__*/new WeakSet();\nexport class WordlistOwl extends Wordlist {\n  /**\n   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n   *  and validated against the %%checksum%%.\n   */\n  constructor(locale, data, _checksum2) {\n    super(locale);\n    _classPrivateMethodInitSpec(this, _WordlistOwl_brand);\n    _classPrivateFieldInitSpec(this, _data, void 0);\n    _classPrivateFieldInitSpec(this, _checksum, void 0);\n    _classPrivateFieldInitSpec(this, _words, void 0);\n    _classPrivateFieldSet(_data, this, data);\n    _classPrivateFieldSet(_checksum, this, _checksum2);\n    _classPrivateFieldSet(_words, this, null);\n  }\n  /**\n   *  The OWL-encoded data.\n   */\n  get _data() {\n    return _classPrivateFieldGet(_data, this);\n  }\n  /**\n   *  Decode all the words for the wordlist.\n   */\n  _decodeWords() {\n    return decodeOwl(_classPrivateFieldGet(_data, this));\n  }\n  getWord(index) {\n    const words = _assertClassBrand(_WordlistOwl_brand, this, _loadWords).call(this);\n    assertArgument(index >= 0 && index < words.length, \"invalid word index: \".concat(index), \"index\", index);\n    return words[index];\n  }\n  getWordIndex(word) {\n    return _assertClassBrand(_WordlistOwl_brand, this, _loadWords).call(this).indexOf(word);\n  }\n}\nfunction _loadWords() {\n  if (_classPrivateFieldGet(_words, this) == null) {\n    const words = this._decodeWords();\n    // Verify the computed list matches the official list\n    const checksum = id(words.join(\"\\n\") + \"\\n\");\n    /* c8 ignore start */\n    if (checksum !== _classPrivateFieldGet(_checksum, this)) {\n      throw new Error(\"BIP39 Wordlist for \".concat(this.locale, \" FAILED\"));\n    }\n    /* c8 ignore stop */\n    _classPrivateFieldSet(_words, this, words);\n  }\n  return _classPrivateFieldGet(_words, this);\n}","map":{"version":3,"names":["id","assertArgument","decodeOwl","Wordlist","_data","WeakMap","_checksum","_words","_WordlistOwl_brand","WeakSet","WordlistOwl","constructor","locale","data","checksum","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateFieldSet","_classPrivateFieldGet","_decodeWords","getWord","index","words","_assertClassBrand","_loadWords","call","length","concat","getWordIndex","word","indexOf","join","Error"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/ethers/src.ts/wordlists/wordlist-owl.ts"],"sourcesContent":["\n// Use the encode-latin.js script to create the necessary\n// data files to be consumed by this class\n\nimport { id } from \"../hash/index.js\";\nimport { assertArgument } from \"../utils/index.js\";\n\nimport { decodeOwl } from \"./decode-owl.js\";\nimport { Wordlist } from \"./wordlist.js\";\n\n/**\n *  An OWL format Wordlist is an encoding method that exploits\n *  the general locality of alphabetically sorted words to\n *  achieve a simple but effective means of compression.\n *\n *  This class is generally not useful to most developers as\n *  it is used mainly internally to keep Wordlists for languages\n *  based on ASCII-7 small.\n *\n *  If necessary, there are tools within the ``generation/`` folder\n *  to create the necessary data.\n */\nexport class WordlistOwl extends Wordlist {\n    #data: string;\n    #checksum: string;\n\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n     *  and validated against the %%checksum%%.\n     */\n    constructor(locale: string, data: string, checksum: string) {\n        super(locale);\n        this.#data = data;\n        this.#checksum = checksum;\n        this.#words = null;\n    }\n\n    /**\n     *  The OWL-encoded data.\n     */\n    get _data(): string { return this.#data; }\n\n    /**\n     *  Decode all the words for the wordlist.\n     */\n    _decodeWords(): Array<string> {\n        return decodeOwl(this.#data);\n    }\n\n    #words: null | Array<string>;\n    #loadWords(): Array<string> {\n        if (this.#words == null) {\n            const words = this._decodeWords();\n\n            // Verify the computed list matches the official list\n            const checksum = id(words.join(\"\\n\") + \"\\n\");\n            /* c8 ignore start */\n            if (checksum !== this.#checksum) {\n                throw new Error(`BIP39 Wordlist for ${ this.locale } FAILED`);\n            }\n            /* c8 ignore stop */\n\n            this.#words = words;\n        }\n        return this.#words;\n    }\n\n    getWord(index: number): string {\n        const words = this.#loadWords();\n        assertArgument(index >= 0 && index < words.length, `invalid word index: ${ index }`, \"index\", index);\n        return words[index];\n    }\n\n    getWordIndex(word: string): number {\n        return this.#loadWords().indexOf(word);\n    }\n}\n"],"mappings":";;;;;AACA;AACA;AAEA,SAASA,EAAE,QAAQ,kBAAkB;AACrC,SAASC,cAAc,QAAQ,mBAAmB;AAElD,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,QAAQ,QAAQ,eAAe;AAExC;;;;;;;;;;;;AAAA,IAAAC,KAAA,oBAAAC,OAAA;AAAA,IAAAC,SAAA,oBAAAD,OAAA;AAAA,IAAAE,MAAA,oBAAAF,OAAA;AAAA,IAAAG,kBAAA,oBAAAC,OAAA;AAYA,OAAM,MAAOC,WAAY,SAAQP,QAAQ;EAIrC;;;;EAIAQ,YAAYC,MAAc,EAAEC,IAAY,EAAEC,UAAgB;IACtD,KAAK,CAACF,MAAM,CAAC;IAACG,2BAAA,OAAAP,kBAAA;IARlBQ,0BAAA,OAAAZ,KAAK;IACLY,0BAAA,OAAAV,SAAS;IAyBTU,0BAAA,OAAAT,MAAM;IAjBFU,qBAAA,CAAKb,KAAK,EAAV,IAAI,EAASS,IAAR,CAAK;IACVI,qBAAA,CAAKX,SAAS,EAAd,IAAI,EAAaQ,UAAZ,CAAS;IACdG,qBAAA,CAAKV,MAAM,EAAX,IAAI,EAAU,IAAT,CAAM;EACf;EAEA;;;EAGA,IAAIH,KAAKA,CAAA;IAAa,OAAOc,qBAAA,CAAKd,KAAK,EAAV,IAAK,CAAK;EAAE;EAEzC;;;EAGAe,YAAYA,CAAA;IACR,OAAOjB,SAAS,CAACgB,qBAAA,CAAKd,KAAK,EAAV,IAAK,CAAK,CAAC;EAChC;EAoBAgB,OAAOA,CAACC,KAAa;IACjB,MAAMC,KAAK,GAAGC,iBAAA,CAAAf,kBAAA,MAAI,EAACgB,UAAA,CAAU,CAAAC,IAAA,CAAf,IAAI,CAAa;IAC/BxB,cAAc,CAACoB,KAAK,IAAI,CAAC,IAAIA,KAAK,GAAGC,KAAK,CAACI,MAAM,yBAAAC,MAAA,CAA0BN,KAAM,GAAI,OAAO,EAAEA,KAAK,CAAC;IACpG,OAAOC,KAAK,CAACD,KAAK,CAAC;EACvB;EAEAO,YAAYA,CAACC,IAAY;IACrB,OAAON,iBAAA,CAAAf,kBAAA,MAAI,EAACgB,UAAA,CAAU,CAAAC,IAAA,CAAf,IAAI,EAAcK,OAAO,CAACD,IAAI,CAAC;EAC1C;;AACH,SAAAL,WAAA,EA1Ba;EACN,IAAIN,qBAAA,CAAKX,MAAM,EAAX,IAAK,CAAM,IAAI,IAAI,EAAE;IACrB,MAAMe,KAAK,GAAG,IAAI,CAACH,YAAY,EAAE;IAEjC;IACA,MAAML,QAAQ,GAAGd,EAAE,CAACsB,KAAK,CAACS,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;IAC5C;IACA,IAAIjB,QAAQ,KAAKI,qBAAA,CAAKZ,SAAS,EAAd,IAAK,CAAS,EAAE;MAC7B,MAAM,IAAI0B,KAAK,uBAAAL,MAAA,CAAwB,IAAI,CAACf,MAAO,YAAS,CAAC;;IAEjE;IAEAK,qBAAA,CAAKV,MAAM,EAAX,IAAI,EAAUe,KAAT,CAAM;;EAEf,OAAOJ,qBAAA,CAAKX,MAAM,EAAX,IAAK,CAAM;AACtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}