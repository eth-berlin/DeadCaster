{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _SignedCallDataPack_instances, _SignedCallDataPack_encode;\nimport * as cbor from 'cborg';\nimport { ethers, toBeHex } from 'ethers';\nconst DEFAULT_GAS_PRICE = 1; // Default gas params are assigned in the web3 gateway.\nconst DEFAULT_GAS_LIMIT = 30000000;\nconst DEFAULT_VALUE = 0;\nconst DEFAULT_NONCE_RANGE = 20;\nconst DEFAULT_BLOCK_RANGE = 4000;\nconst DEFAULT_DATA = '0x';\nconst zeroAddress = () => `0x${'0'.repeat(40)}`;\nclass SignedCallCache {\n  constructor() {\n    // for each signer, we cache the signature of the hash of each SignableCall\n    this.cachedSignatures = new Map();\n    // for each ChainId, we cache the base block number to make the same leash\n    this.cachedLeashes = new Map();\n  }\n  clear() {\n    this.cachedSignatures.clear();\n    this.cachedLeashes.clear();\n  }\n  cache(address, chainId, call, hash, signature) {\n    if (!this.cachedSignatures.has(address)) this.cachedSignatures.set(address, new Map());\n    this.cachedSignatures.get(address).set(hash, signature);\n    this.cachedLeashes.set(chainId, {\n      nonce: call.leash.nonce,\n      block_number: call.leash.blockNumber,\n      block_hash: call.leash.blockHash,\n      block_range: call.leash.blockRange\n    });\n  }\n  get(address, hash) {\n    var _a;\n    return (_a = this.cachedSignatures.get(address)) === null || _a === void 0 ? void 0 : _a.get(hash);\n  }\n  getLeash(chainId) {\n    return this.cachedLeashes.get(chainId);\n  }\n}\nconst _cache = new SignedCallCache();\nexport function signedCallEIP712Params(chainId) {\n  return {\n    domain: {\n      name: 'oasis-runtime-sdk/evm: signed query',\n      version: '1.0.0',\n      chainId\n    },\n    types: {\n      Call: [{\n        name: 'from',\n        type: 'address'\n      }, {\n        name: 'to',\n        type: 'address'\n      }, {\n        name: 'gasLimit',\n        type: 'uint64'\n      }, {\n        name: 'gasPrice',\n        type: 'uint256'\n      }, {\n        name: 'value',\n        type: 'uint256'\n      }, {\n        name: 'data',\n        type: 'bytes'\n      }, {\n        name: 'leash',\n        type: 'Leash'\n      }],\n      Leash: [{\n        name: 'nonce',\n        type: 'uint64'\n      }, {\n        name: 'blockNumber',\n        type: 'uint64'\n      }, {\n        name: 'blockHash',\n        type: 'bytes32'\n      }, {\n        name: 'blockRange',\n        type: 'uint64'\n      }]\n    }\n  };\n}\n/**\n * Parameters that define a signed call that shall be\n * CBOR-encoded and sent as the call's `data` field.\n */\nexport class SignedCallDataPack {\n  static make(call, signer, overrides) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const leash = yield makeLeash(signer, overrides === null || overrides === void 0 ? void 0 : overrides.leash);\n      return new SignedCallDataPack(leash, yield signCall(makeSignableCall(call, leash), signer, {\n        chainId: overrides === null || overrides === void 0 ? void 0 : overrides.chainId\n      }), call.data ? parseBytesLike(call.data) : undefined);\n    });\n  }\n  constructor(leash, /** A signature over the call and leash as generated by `signCall`. */\n  signature,\n  /**\n   * An oasis-sdk `Call` without the optional fields.\n   *\n   * After encryption, `body` would be encrypted and this field would contain a\n   * `format` field. The runtime would decode the data as a `types::transaction::Call`.\n   **/\n  data) {\n    this.leash = leash;\n    this.signature = signature;\n    this.data = data;\n    _SignedCallDataPack_instances.add(this);\n  }\n  encode() {\n    return __classPrivateFieldGet(this, _SignedCallDataPack_instances, \"m\", _SignedCallDataPack_encode).call(this, this.data ? {\n      body: this.data\n    } : undefined);\n  }\n  /** Encodes the data pack after encrypting the signed call data. */\n  encryptEncode(cipher) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.data) return __classPrivateFieldGet(this, _SignedCallDataPack_instances, \"m\", _SignedCallDataPack_encode).call(this, yield cipher.encryptEnvelope(this.data));\n      return this.encode();\n    });\n  }\n}\n_SignedCallDataPack_instances = new WeakSet(), _SignedCallDataPack_encode = function _SignedCallDataPack_encode(data) {\n  return ethers.hexlify(cbor.encode({\n    data: data ? data : undefined,\n    leash: this.leash,\n    signature: this.signature\n  }));\n};\nfunction parseBytesLike(data) {\n  if (Array.isArray(data)) return new Uint8Array(data);\n  return ethers.getBytesCopy(data);\n}\nfunction stringifyBytesLike(data) {\n  if (Array.isArray(data)) return ethers.hexlify(new Uint8Array(data));\n  return ethers.hexlify(data);\n}\nfunction makeLeash(signer, overrides) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    // simply invalidate signedCall caches if overrided nonce or block are provided\n    if ((overrides === null || overrides === void 0 ? void 0 : overrides.nonce) !== undefined || (overrides === null || overrides === void 0 ? void 0 : overrides.block) !== undefined) {\n      _cache.clear();\n    }\n    let nonceP;\n    if (overrides === null || overrides === void 0 ? void 0 : overrides.nonce) {\n      nonceP = overrides.nonce;\n    } else if ('getNonce' in signer) {\n      // Ethers v6 has 'getNonce'\n      nonceP = signer.getNonce('pending');\n    } else {\n      // Ethers v5 doesn't, so use `getTransactionCount`\n      const addr = yield signer.getAddress();\n      nonceP = signer.provider.getTransactionCount(addr, 'pending');\n    }\n    let blockP;\n    if ((overrides === null || overrides === void 0 ? void 0 : overrides.block) !== undefined) {\n      blockP = overrides.block;\n    } else {\n      if (!signer.provider) throw new Error('`sapphire.wrap`ped signer was not connected to a provider');\n      const latestBlock = yield signer.provider.getBlock('latest');\n      if (!latestBlock) throw new Error('unable to get latest block');\n      blockP = signer.provider.getBlock(latestBlock.number - 2);\n    }\n    const [nonce, block] = yield Promise.all([nonceP, blockP]);\n    const blockRange = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.blockRange) !== null && _a !== void 0 ? _a : DEFAULT_BLOCK_RANGE;\n    // check whether we should use cached leashes\n    if ((overrides === null || overrides === void 0 ? void 0 : overrides.nonce) === undefined && (overrides === null || overrides === void 0 ? void 0 : overrides.block) === undefined) {\n      if (!signer.provider) throw new Error('`sapphire.wrap`ped signer was not connected to a provider');\n      const {\n        chainId\n      } = yield signer.provider.getNetwork();\n      const cachedLeash = _cache.getLeash(BigInt(chainId));\n      if (cachedLeash !== undefined) {\n        // this happens only if neither overried nonce nor block are provided\n        // so the pendingNonce and latestBlock are compared with the cachedLeash\n        if (cachedLeash.nonce > nonce && cachedLeash.block_number + blockRange > block.number + 2) {\n          // the cached leash can be still re-usable\n          return cachedLeash;\n        } else {\n          // the cached leash has been outdated\n          _cache.clear();\n        }\n      }\n    }\n    return {\n      nonce: (overrides === null || overrides === void 0 ? void 0 : overrides.nonce) ? overrides.nonce : nonce + DEFAULT_NONCE_RANGE,\n      block_number: block.number,\n      block_hash: ethers.getBytesCopy(block.hash),\n      block_range: blockRange\n    };\n  });\n}\nexport function makeSignableCall(call, leash) {\n  var _a, _b, _c, _d, _e;\n  return {\n    from: call.from,\n    to: (_a = call.to) !== null && _a !== void 0 ? _a : zeroAddress(),\n    gasLimit: Number(BigInt((_c = (_b = call.gasLimit) !== null && _b !== void 0 ? _b : call.gasLimit) !== null && _c !== void 0 ? _c : DEFAULT_GAS_LIMIT)),\n    gasPrice: BigInt((_d = call.gasPrice) !== null && _d !== void 0 ? _d : DEFAULT_GAS_PRICE),\n    value: BigInt((_e = call.value) !== null && _e !== void 0 ? _e : DEFAULT_VALUE),\n    data: call.data ? stringifyBytesLike(call.data) : DEFAULT_DATA,\n    leash: {\n      nonce: leash.nonce,\n      blockNumber: leash.block_number,\n      blockHash: leash.block_hash,\n      blockRange: leash.block_range\n    }\n  };\n}\nfunction signCall(call, signer, overrides) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const address = yield signer.getAddress();\n    let chainId;\n    if (overrides === null || overrides === void 0 ? void 0 : overrides.chainId) {\n      chainId = BigInt(overrides.chainId);\n    } else if (signer.provider) {\n      ({\n        chainId\n      } = yield signer.provider.getNetwork());\n    } else {\n      throw new Error('must either connect provider or provide manual chainId override');\n    }\n    const {\n      domain,\n      types\n    } = signedCallEIP712Params(Number(chainId));\n    const upgradedDomain = upgradeDomain(domain);\n    const upgradedCall = upgradeCall(call);\n    const hash = ethers.TypedDataEncoder.hash(upgradedDomain, types, upgradedCall);\n    let signature = _cache.get(address, hash);\n    if (signature !== undefined) return signature;\n    signature = ethers.getBytes('_signTypedData' in signer ? yield signer._signTypedData(upgradedDomain, types, upgradedCall) : yield signer.signTypedData(upgradedDomain, types, upgradedCall));\n    _cache.cache(address, BigInt(chainId), call, hash, signature);\n    return signature;\n  });\n}\nfunction upgradeDomain(domain) {\n  const x = Object.assign(Object.assign({}, domain), {\n    chainId: domain.chainId ? toBeHex(domain.chainId) : undefined\n  });\n  if (domain.salt) {\n    x['salt'] = parseBytesLike(domain.salt);\n  }\n  return x;\n}\nfunction upgradeCall(call) {\n  const big2int = b => {\n    if (b === undefined || b === null) return undefined;\n    if (typeof b === 'string') return b;\n    if (b instanceof BigInt) return toBeHex(b.toString());\n    return ethers.toQuantity(b);\n  };\n  return Object.assign(Object.assign({}, call), {\n    gasPrice: big2int(call.gasPrice),\n    value: big2int(call.value),\n    data: call.data ? ethers.getBytes(call.data) : undefined\n  });\n}","map":{"version":3,"names":["cbor","ethers","toBeHex","DEFAULT_GAS_PRICE","DEFAULT_GAS_LIMIT","DEFAULT_VALUE","DEFAULT_NONCE_RANGE","DEFAULT_BLOCK_RANGE","DEFAULT_DATA","zeroAddress","repeat","SignedCallCache","constructor","cachedSignatures","Map","cachedLeashes","clear","cache","address","chainId","call","hash","signature","has","set","get","nonce","leash","block_number","blockNumber","block_hash","blockHash","block_range","blockRange","_a","getLeash","_cache","signedCallEIP712Params","domain","name","version","types","Call","type","Leash","SignedCallDataPack","make","signer","overrides","makeLeash","signCall","makeSignableCall","data","parseBytesLike","undefined","encode","__classPrivateFieldGet","_SignedCallDataPack_instances","_SignedCallDataPack_encode","body","encryptEncode","cipher","encryptEnvelope","hexlify","Array","isArray","Uint8Array","getBytesCopy","stringifyBytesLike","block","nonceP","getNonce","addr","getAddress","provider","getTransactionCount","blockP","Error","latestBlock","getBlock","number","Promise","all","getNetwork","cachedLeash","BigInt","from","to","gasLimit","Number","_c","_b","gasPrice","_d","value","_e","upgradedDomain","upgradeDomain","upgradedCall","upgradeCall","TypedDataEncoder","getBytes","_signTypedData","signTypedData","x","Object","assign","salt","big2int","b","toString","toQuantity"],"sources":["/Users/flo/DeadCaster/ipfs-frontends/onboard/node_modules/@oasisprotocol/sapphire-paratime/src/signed_calls.ts"],"sourcesContent":["import * as cbor from 'cborg';\nimport {\n  ethers,\n  BigNumberish,\n  TypedDataDomain,\n  TypedDataField,\n  BlockTag,\n  toBeHex,\n  TransactionRequest,\n} from 'ethers';\nimport type {\n  CamelCasedProperties,\n  Promisable,\n  RequireExactlyOne,\n} from 'type-fest';\n\nimport { Cipher, Envelope } from './cipher.js';\nimport { Ethers5Signer } from './interfaces.js';\n\nconst DEFAULT_GAS_PRICE = 1; // Default gas params are assigned in the web3 gateway.\nconst DEFAULT_GAS_LIMIT = 30_000_000;\nconst DEFAULT_VALUE = 0;\nconst DEFAULT_NONCE_RANGE = 20;\nconst DEFAULT_BLOCK_RANGE = 4000;\nconst DEFAULT_DATA = '0x';\nconst zeroAddress = () => `0x${'0'.repeat(40)}`;\n\nclass SignedCallCache {\n  // for each signer, we cache the signature of the hash of each SignableCall\n  private cachedSignatures = new Map<string, Map<string, Uint8Array>>();\n  // for each ChainId, we cache the base block number to make the same leash\n  private cachedLeashes = new Map<bigint, Leash>();\n\n  public clear() {\n    this.cachedSignatures.clear();\n    this.cachedLeashes.clear();\n  }\n\n  public cache(\n    address: string,\n    chainId: bigint,\n    call: SignableEthCall,\n    hash: string,\n    signature: Uint8Array,\n  ) {\n    if (!this.cachedSignatures.has(address))\n      this.cachedSignatures.set(address, new Map<string, Uint8Array>());\n    this.cachedSignatures.get(address)!.set(hash, signature);\n    this.cachedLeashes.set(chainId, {\n      nonce: call.leash.nonce,\n      block_number: call.leash.blockNumber,\n      block_hash: call.leash.blockHash,\n      block_range: call.leash.blockRange,\n    });\n  }\n\n  public get(address: string, hash: string): Uint8Array | undefined {\n    return this.cachedSignatures.get(address)?.get(hash);\n  }\n\n  public getLeash(chainId: bigint): Leash | undefined {\n    return this.cachedLeashes.get(chainId);\n  }\n}\n\nconst _cache = new SignedCallCache();\n\nexport function signedCallEIP712Params(chainId: number): {\n  domain: TypedDataDomain;\n  types: Record<string, TypedDataField[]>;\n} {\n  return {\n    domain: {\n      name: 'oasis-runtime-sdk/evm: signed query',\n      version: '1.0.0',\n      chainId,\n    },\n    types: {\n      Call: [\n        { name: 'from', type: 'address' },\n        { name: 'to', type: 'address' },\n        { name: 'gasLimit', type: 'uint64' },\n        { name: 'gasPrice', type: 'uint256' },\n        { name: 'value', type: 'uint256' },\n        { name: 'data', type: 'bytes' },\n        { name: 'leash', type: 'Leash' },\n      ],\n      Leash: [\n        { name: 'nonce', type: 'uint64' },\n        { name: 'blockNumber', type: 'uint64' },\n        { name: 'blockHash', type: 'bytes32' },\n        { name: 'blockRange', type: 'uint64' },\n      ],\n    },\n  };\n}\n\n/**\n * Parameters that define a signed call that shall be\n * CBOR-encoded and sent as the call's `data` field.\n */\nexport class SignedCallDataPack {\n  static async make(\n    call: EthCall | TransactionRequest,\n    signer: Ethers5Signer | ethers.Signer,\n    overrides?: PrepareSignedCallOverrides,\n  ): Promise<SignedCallDataPack> {\n    const leash = await makeLeash(signer, overrides?.leash);\n    return new SignedCallDataPack(\n      leash,\n      await signCall(makeSignableCall(call, leash), signer, {\n        chainId: overrides?.chainId,\n      }),\n      call.data ? parseBytesLike(call.data) : undefined,\n    );\n  }\n\n  private constructor(\n    public readonly leash: Leash,\n    /** A signature over the call and leash as generated by `signCall`. */\n    public readonly signature: Uint8Array,\n    /**\n     * An oasis-sdk `Call` without the optional fields.\n     *\n     * After encryption, `body` would be encrypted and this field would contain a\n     * `format` field. The runtime would decode the data as a `types::transaction::Call`.\n     **/\n    public readonly data?: Uint8Array,\n  ) {}\n\n  public encode(): string {\n    return this.#encode(this.data ? { body: this.data } : undefined);\n  }\n\n  /** Encodes the data pack after encrypting the signed call data. */\n  public async encryptEncode(cipher: Cipher): Promise<string> {\n    if (this.data) return this.#encode(await cipher.encryptEnvelope(this.data));\n    return this.encode();\n  }\n\n  #encode(data?: Envelope | { body: Uint8Array }): string {\n    return ethers.hexlify(\n      cbor.encode({\n        data: data ? data : undefined,\n        leash: this.leash,\n        signature: this.signature,\n      }),\n    );\n  }\n}\n\nfunction parseBytesLike(data: ethers.BytesLike): Uint8Array {\n  if (Array.isArray(data)) return new Uint8Array(data);\n  return ethers.getBytesCopy(data as 'string' | Uint8Array);\n}\n\nfunction stringifyBytesLike(data: ethers.BytesLike): string {\n  if (Array.isArray(data)) return ethers.hexlify(new Uint8Array(data));\n  return ethers.hexlify(data as 'string' | Uint8Array);\n}\n\nasync function makeLeash(\n  signer: Ethers5Signer | ethers.Signer,\n  overrides?: LeashOverrides,\n): Promise<Leash> {\n  // simply invalidate signedCall caches if overrided nonce or block are provided\n  if (overrides?.nonce !== undefined || overrides?.block !== undefined) {\n    _cache.clear();\n  }\n\n  let nonceP: Promisable<number>;\n  if (overrides?.nonce) {\n    nonceP = overrides.nonce;\n  } else if ('getNonce' in signer) {\n    // Ethers v6 has 'getNonce'\n    nonceP = signer.getNonce('pending');\n  } else {\n    // Ethers v5 doesn't, so use `getTransactionCount`\n    const addr = await signer.getAddress();\n    nonceP = signer.provider!.getTransactionCount(addr, 'pending');\n  }\n\n  let blockP: Promisable<BlockId>;\n  if (overrides?.block !== undefined) {\n    blockP = overrides.block;\n  } else {\n    if (!signer.provider)\n      throw new Error(\n        '`sapphire.wrap`ped signer was not connected to a provider',\n      );\n    const latestBlock = await signer.provider.getBlock('latest');\n    if (!latestBlock) throw new Error('unable to get latest block');\n    blockP = signer.provider!.getBlock(\n      latestBlock.number - 2,\n    ) as Promise<BlockId>;\n  }\n  const [nonce, block] = await Promise.all([nonceP, blockP]);\n  const blockRange = overrides?.blockRange ?? DEFAULT_BLOCK_RANGE;\n\n  // check whether we should use cached leashes\n  if (overrides?.nonce === undefined && overrides?.block === undefined) {\n    if (!signer.provider)\n      throw new Error(\n        '`sapphire.wrap`ped signer was not connected to a provider',\n      );\n    const { chainId } = await signer.provider.getNetwork();\n    const cachedLeash = _cache.getLeash(BigInt(chainId));\n    if (cachedLeash !== undefined) {\n      // this happens only if neither overried nonce nor block are provided\n      // so the pendingNonce and latestBlock are compared with the cachedLeash\n      if (\n        cachedLeash.nonce > nonce &&\n        cachedLeash.block_number + blockRange > block.number + 2\n      ) {\n        // the cached leash can be still re-usable\n        return cachedLeash;\n      } else {\n        // the cached leash has been outdated\n        _cache.clear();\n      }\n    }\n  }\n\n  return {\n    nonce: overrides?.nonce ? overrides.nonce : nonce + DEFAULT_NONCE_RANGE,\n    block_number: block.number,\n    block_hash: ethers.getBytesCopy(block.hash),\n    block_range: blockRange,\n  };\n}\n\nexport function makeSignableCall(\n  call: EthCall | TransactionRequest,\n  leash: Leash,\n): SignableEthCall {\n  return {\n    from: call.from as any,\n    to: call.to ?? (zeroAddress() as any),\n    gasLimit: Number(\n      BigInt(call.gasLimit ?? call.gasLimit ?? DEFAULT_GAS_LIMIT),\n    ),\n    gasPrice: BigInt(call.gasPrice ?? DEFAULT_GAS_PRICE),\n    value: BigInt(call.value ?? DEFAULT_VALUE),\n    data: call.data ? stringifyBytesLike(call.data) : DEFAULT_DATA,\n    leash: {\n      nonce: leash.nonce,\n      blockNumber: leash.block_number,\n      blockHash: leash.block_hash,\n      blockRange: leash.block_range,\n    },\n  };\n}\n\ninterface TypedDataSigner {\n  _signTypedData(\n    domain: TypedDataDomain,\n    types: Record<string, Array<TypedDataField>>,\n    value: Record<string, any>,\n  ): Promise<string>;\n}\n\nasync function signCall(\n  call: SignableEthCall,\n  signer: Ethers5Signer | ethers.Signer,\n  overrides?: Partial<{ chainId: number | bigint }>,\n): Promise<Uint8Array> {\n  const address = await signer.getAddress();\n  let chainId: number | bigint;\n  if (overrides?.chainId) {\n    chainId = BigInt(overrides.chainId);\n  } else if (signer.provider) {\n    ({ chainId } = await signer.provider.getNetwork());\n  } else {\n    throw new Error(\n      'must either connect provider or provide manual chainId override',\n    );\n  }\n  const { domain, types } = signedCallEIP712Params(Number(chainId));\n  const upgradedDomain = upgradeDomain(domain);\n  const upgradedCall = upgradeCall(call);\n  const hash = ethers.TypedDataEncoder.hash(\n    upgradedDomain,\n    types,\n    upgradedCall,\n  );\n  let signature = _cache.get(address, hash);\n  if (signature !== undefined) return signature;\n\n  signature = ethers.getBytes(\n    '_signTypedData' in signer\n      ? await (signer as TypedDataSigner)._signTypedData(\n          upgradedDomain,\n          types,\n          upgradedCall,\n        )\n      : await (signer as ethers.Signer).signTypedData(\n          upgradedDomain,\n          types,\n          upgradedCall,\n        ),\n  );\n  _cache.cache(address, BigInt(chainId), call, hash, signature);\n  return signature;\n}\n\nfunction upgradeDomain(domain: TypedDataDomain): ethers.TypedDataDomain {\n  const x = {\n    ...domain,\n    chainId: domain.chainId ? toBeHex(domain.chainId) : undefined,\n  };\n  if (domain.salt) {\n    x['salt'] = parseBytesLike(domain.salt);\n  }\n  return x;\n}\n\nfunction upgradeCall(call: SignableEthCall) {\n  const big2int = (b?: bigint | number | string | any): string | undefined => {\n    if (b === undefined || b === null) return undefined;\n    if (typeof b === 'string') return b;\n    if (b instanceof BigInt) return toBeHex(b.toString());\n    return ethers.toQuantity(b);\n  };\n  return {\n    ...call,\n    gasPrice: big2int(call.gasPrice),\n    value: big2int(call.value),\n    data: call.data ? ethers.getBytes(call.data) : undefined,\n  };\n}\n\nexport type PrepareSignedCallOverrides = Partial<{\n  leash: LeashOverrides;\n  chainId: number;\n}>;\n\nexport type LeashOverrides = Partial<\n  {\n    nonce: number;\n    blockRange: number;\n  } & RequireExactlyOne<{\n    block: BlockId;\n    blockTag: BlockTag;\n  }>\n>;\n\nexport type EthCall = {\n  /** 0x-prefixed hex-encoded address. */\n  from?: string;\n  /** Optional 0x-prefixed hex-encoded address. */\n  to?: string;\n  value?: BigNumberish;\n  gasPrice?: BigNumberish;\n  data?: ethers.BytesLike;\n} & Partial<\n  RequireExactlyOne<{\n    gas: number | string; // web3.js\n    gasLimit: BigNumberish; // ethers\n  }>\n>;\n\n/**\n * The structure passed to eth_signTypedData_v4.\n *\n * `uint256`, `address`, and `bytes` are required to be hex-stringified.\n */\nexport type SignableEthCall = {\n  from: string;\n  to: string;\n  gasLimit?: number;\n  gasPrice?: bigint;\n  value?: bigint;\n  data?: string;\n  leash: CamelCasedProperties<Leash>;\n};\n\nexport type Leash = {\n  /** The largest sender account nonce whence the call will be valid. */\n  nonce: number;\n  /** The block number whence the call will be valid. */\n  block_number: number; // uint64\n  /** The expected block hash to be found at `block_number`. */\n  block_hash: Uint8Array | string;\n  /** The number of blocks past the block at `block_number` whence the call will be valid. */\n  block_range: number; // uint64\n};\n\nexport type BlockId = { hash: string; number: number };\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAKA,IAAI,MAAM,OAAO;AAC7B,SACEC,MAAM,EAKNC,OAAO,QAEF,QAAQ;AAUf,MAAMC,iBAAiB,GAAG,CAAC,CAAC,CAAC;AAC7B,MAAMC,iBAAiB,GAAG,QAAU;AACpC,MAAMC,aAAa,GAAG,CAAC;AACvB,MAAMC,mBAAmB,GAAG,EAAE;AAC9B,MAAMC,mBAAmB,GAAG,IAAI;AAChC,MAAMC,YAAY,GAAG,IAAI;AACzB,MAAMC,WAAW,GAAGA,CAAA,KAAM,KAAK,GAAG,CAACC,MAAM,CAAC,EAAE,CAAC,EAAE;AAE/C,MAAMC,eAAe;EAArBC,YAAA;IACE;IACQ,KAAAC,gBAAgB,GAAG,IAAIC,GAAG,EAAmC;IACrE;IACQ,KAAAC,aAAa,GAAG,IAAID,GAAG,EAAiB;EAgClD;EA9BSE,KAAKA,CAAA;IACV,IAAI,CAACH,gBAAgB,CAACG,KAAK,EAAE;IAC7B,IAAI,CAACD,aAAa,CAACC,KAAK,EAAE;EAC5B;EAEOC,KAAKA,CACVC,OAAe,EACfC,OAAe,EACfC,IAAqB,EACrBC,IAAY,EACZC,SAAqB;IAErB,IAAI,CAAC,IAAI,CAACT,gBAAgB,CAACU,GAAG,CAACL,OAAO,CAAC,EACrC,IAAI,CAACL,gBAAgB,CAACW,GAAG,CAACN,OAAO,EAAE,IAAIJ,GAAG,EAAsB,CAAC;IACnE,IAAI,CAACD,gBAAgB,CAACY,GAAG,CAACP,OAAO,CAAE,CAACM,GAAG,CAACH,IAAI,EAAEC,SAAS,CAAC;IACxD,IAAI,CAACP,aAAa,CAACS,GAAG,CAACL,OAAO,EAAE;MAC9BO,KAAK,EAAEN,IAAI,CAACO,KAAK,CAACD,KAAK;MACvBE,YAAY,EAAER,IAAI,CAACO,KAAK,CAACE,WAAW;MACpCC,UAAU,EAAEV,IAAI,CAACO,KAAK,CAACI,SAAS;MAChCC,WAAW,EAAEZ,IAAI,CAACO,KAAK,CAACM;KACzB,CAAC;EACJ;EAEOR,GAAGA,CAACP,OAAe,EAAEG,IAAY;;IACtC,OAAO,CAAAa,EAAA,OAAI,CAACrB,gBAAgB,CAACY,GAAG,CAACP,OAAO,CAAC,cAAAgB,EAAA,uBAAAA,EAAA,CAAET,GAAG,CAACJ,IAAI,CAAC;EACtD;EAEOc,QAAQA,CAAChB,OAAe;IAC7B,OAAO,IAAI,CAACJ,aAAa,CAACU,GAAG,CAACN,OAAO,CAAC;EACxC;;AAGF,MAAMiB,MAAM,GAAG,IAAIzB,eAAe,EAAE;AAEpC,OAAM,SAAU0B,sBAAsBA,CAAClB,OAAe;EAIpD,OAAO;IACLmB,MAAM,EAAE;MACNC,IAAI,EAAE,qCAAqC;MAC3CC,OAAO,EAAE,OAAO;MAChBrB;KACD;IACDsB,KAAK,EAAE;MACLC,IAAI,EAAE,CACJ;QAAEH,IAAI,EAAE,MAAM;QAAEI,IAAI,EAAE;MAAS,CAAE,EACjC;QAAEJ,IAAI,EAAE,IAAI;QAAEI,IAAI,EAAE;MAAS,CAAE,EAC/B;QAAEJ,IAAI,EAAE,UAAU;QAAEI,IAAI,EAAE;MAAQ,CAAE,EACpC;QAAEJ,IAAI,EAAE,UAAU;QAAEI,IAAI,EAAE;MAAS,CAAE,EACrC;QAAEJ,IAAI,EAAE,OAAO;QAAEI,IAAI,EAAE;MAAS,CAAE,EAClC;QAAEJ,IAAI,EAAE,MAAM;QAAEI,IAAI,EAAE;MAAO,CAAE,EAC/B;QAAEJ,IAAI,EAAE,OAAO;QAAEI,IAAI,EAAE;MAAO,CAAE,CACjC;MACDC,KAAK,EAAE,CACL;QAAEL,IAAI,EAAE,OAAO;QAAEI,IAAI,EAAE;MAAQ,CAAE,EACjC;QAAEJ,IAAI,EAAE,aAAa;QAAEI,IAAI,EAAE;MAAQ,CAAE,EACvC;QAAEJ,IAAI,EAAE,WAAW;QAAEI,IAAI,EAAE;MAAS,CAAE,EACtC;QAAEJ,IAAI,EAAE,YAAY;QAAEI,IAAI,EAAE;MAAQ,CAAE;;GAG3C;AACH;AAEA;;;;AAIA,OAAM,MAAOE,kBAAkB;EAC7B,OAAaC,IAAIA,CACf1B,IAAkC,EAClC2B,MAAqC,EACrCC,SAAsC;;MAEtC,MAAMrB,KAAK,GAAG,MAAMsB,SAAS,CAACF,MAAM,EAAEC,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAErB,KAAK,CAAC;MACvD,OAAO,IAAIkB,kBAAkB,CAC3BlB,KAAK,EACL,MAAMuB,QAAQ,CAACC,gBAAgB,CAAC/B,IAAI,EAAEO,KAAK,CAAC,EAAEoB,MAAM,EAAE;QACpD5B,OAAO,EAAE6B,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAE7B;OACrB,CAAC,EACFC,IAAI,CAACgC,IAAI,GAAGC,cAAc,CAACjC,IAAI,CAACgC,IAAI,CAAC,GAAGE,SAAS,CAClD;IACH,CAAC;;EAED1C,YACkBe,KAAY,EAC5B;EACgBL,SAAqB;EACrC;;;;;;EAMgB8B,IAAiB;IATjB,KAAAzB,KAAK,GAALA,KAAK;IAEL,KAAAL,SAAS,GAATA,SAAS;IAOT,KAAA8B,IAAI,GAAJA,IAAI;;EACnB;EAEIG,MAAMA,CAAA;IACX,OAAOC,sBAAA,KAAI,EAAAC,6BAAA,OAAAC,0BAAA,CAAQ,CAAAtC,IAAA,CAAZ,IAAI,EAAS,IAAI,CAACgC,IAAI,GAAG;MAAEO,IAAI,EAAE,IAAI,CAACP;IAAI,CAAE,GAAGE,SAAS,CAAC;EAClE;EAEA;EACaM,aAAaA,CAACC,MAAc;;MACvC,IAAI,IAAI,CAACT,IAAI,EAAE,OAAOI,sBAAA,KAAI,EAAAC,6BAAA,OAAAC,0BAAA,CAAQ,CAAAtC,IAAA,CAAZ,IAAI,EAAS,MAAMyC,MAAM,CAACC,eAAe,CAAC,IAAI,CAACV,IAAI,CAAC,CAAC;MAC3E,OAAO,IAAI,CAACG,MAAM,EAAE;IACtB,CAAC;;;gHAEOH,IAAsC;EAC5C,OAAOnD,MAAM,CAAC8D,OAAO,CACnB/D,IAAI,CAACuD,MAAM,CAAC;IACVH,IAAI,EAAEA,IAAI,GAAGA,IAAI,GAAGE,SAAS;IAC7B3B,KAAK,EAAE,IAAI,CAACA,KAAK;IACjBL,SAAS,EAAE,IAAI,CAACA;GACjB,CAAC,CACH;AACH,CAAC;AAGH,SAAS+B,cAAcA,CAACD,IAAsB;EAC5C,IAAIY,KAAK,CAACC,OAAO,CAACb,IAAI,CAAC,EAAE,OAAO,IAAIc,UAAU,CAACd,IAAI,CAAC;EACpD,OAAOnD,MAAM,CAACkE,YAAY,CAACf,IAA6B,CAAC;AAC3D;AAEA,SAASgB,kBAAkBA,CAAChB,IAAsB;EAChD,IAAIY,KAAK,CAACC,OAAO,CAACb,IAAI,CAAC,EAAE,OAAOnD,MAAM,CAAC8D,OAAO,CAAC,IAAIG,UAAU,CAACd,IAAI,CAAC,CAAC;EACpE,OAAOnD,MAAM,CAAC8D,OAAO,CAACX,IAA6B,CAAC;AACtD;AAEA,SAAeH,SAASA,CACtBF,MAAqC,EACrCC,SAA0B;;;IAE1B;IACA,IAAI,CAAAA,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEtB,KAAK,MAAK4B,SAAS,IAAI,CAAAN,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEqB,KAAK,MAAKf,SAAS,EAAE;MACpElB,MAAM,CAACpB,KAAK,EAAE;;IAGhB,IAAIsD,MAA0B;IAC9B,IAAItB,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEtB,KAAK,EAAE;MACpB4C,MAAM,GAAGtB,SAAS,CAACtB,KAAK;KACzB,MAAM,IAAI,UAAU,IAAIqB,MAAM,EAAE;MAC/B;MACAuB,MAAM,GAAGvB,MAAM,CAACwB,QAAQ,CAAC,SAAS,CAAC;KACpC,MAAM;MACL;MACA,MAAMC,IAAI,GAAG,MAAMzB,MAAM,CAAC0B,UAAU,EAAE;MACtCH,MAAM,GAAGvB,MAAM,CAAC2B,QAAS,CAACC,mBAAmB,CAACH,IAAI,EAAE,SAAS,CAAC;;IAGhE,IAAII,MAA2B;IAC/B,IAAI,CAAA5B,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEqB,KAAK,MAAKf,SAAS,EAAE;MAClCsB,MAAM,GAAG5B,SAAS,CAACqB,KAAK;KACzB,MAAM;MACL,IAAI,CAACtB,MAAM,CAAC2B,QAAQ,EAClB,MAAM,IAAIG,KAAK,CACb,2DAA2D,CAC5D;MACH,MAAMC,WAAW,GAAG,MAAM/B,MAAM,CAAC2B,QAAQ,CAACK,QAAQ,CAAC,QAAQ,CAAC;MAC5D,IAAI,CAACD,WAAW,EAAE,MAAM,IAAID,KAAK,CAAC,4BAA4B,CAAC;MAC/DD,MAAM,GAAG7B,MAAM,CAAC2B,QAAS,CAACK,QAAQ,CAChCD,WAAW,CAACE,MAAM,GAAG,CAAC,CACH;;IAEvB,MAAM,CAACtD,KAAK,EAAE2C,KAAK,CAAC,GAAG,MAAMY,OAAO,CAACC,GAAG,CAAC,CAACZ,MAAM,EAAEM,MAAM,CAAC,CAAC;IAC1D,MAAM3C,UAAU,GAAG,CAAAC,EAAA,GAAAc,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEf,UAAU,cAAAC,EAAA,cAAAA,EAAA,GAAI3B,mBAAmB;IAE/D;IACA,IAAI,CAAAyC,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEtB,KAAK,MAAK4B,SAAS,IAAI,CAAAN,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEqB,KAAK,MAAKf,SAAS,EAAE;MACpE,IAAI,CAACP,MAAM,CAAC2B,QAAQ,EAClB,MAAM,IAAIG,KAAK,CACb,2DAA2D,CAC5D;MACH,MAAM;QAAE1D;MAAO,CAAE,GAAG,MAAM4B,MAAM,CAAC2B,QAAQ,CAACS,UAAU,EAAE;MACtD,MAAMC,WAAW,GAAGhD,MAAM,CAACD,QAAQ,CAACkD,MAAM,CAAClE,OAAO,CAAC,CAAC;MACpD,IAAIiE,WAAW,KAAK9B,SAAS,EAAE;QAC7B;QACA;QACA,IACE8B,WAAW,CAAC1D,KAAK,GAAGA,KAAK,IACzB0D,WAAW,CAACxD,YAAY,GAAGK,UAAU,GAAGoC,KAAK,CAACW,MAAM,GAAG,CAAC,EACxD;UACA;UACA,OAAOI,WAAW;SACnB,MAAM;UACL;UACAhD,MAAM,CAACpB,KAAK,EAAE;;;;IAKpB,OAAO;MACLU,KAAK,EAAE,CAAAsB,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEtB,KAAK,IAAGsB,SAAS,CAACtB,KAAK,GAAGA,KAAK,GAAGpB,mBAAmB;MACvEsB,YAAY,EAAEyC,KAAK,CAACW,MAAM;MAC1BlD,UAAU,EAAE7B,MAAM,CAACkE,YAAY,CAACE,KAAK,CAAChD,IAAI,CAAC;MAC3CW,WAAW,EAAEC;KACd;;;AAGH,OAAM,SAAUkB,gBAAgBA,CAC9B/B,IAAkC,EAClCO,KAAY;;EAEZ,OAAO;IACL2D,IAAI,EAAElE,IAAI,CAACkE,IAAW;IACtBC,EAAE,EAAE,CAAArD,EAAA,GAAAd,IAAI,CAACmE,EAAE,cAAArD,EAAA,cAAAA,EAAA,GAAKzB,WAAW,EAAU;IACrC+E,QAAQ,EAAEC,MAAM,CACdJ,MAAM,CAAC,CAAAK,EAAA,IAAAC,EAAA,GAAAvE,IAAI,CAACoE,QAAQ,cAAAG,EAAA,cAAAA,EAAA,GAAIvE,IAAI,CAACoE,QAAQ,cAAAE,EAAA,cAAAA,EAAA,GAAItF,iBAAiB,CAAC,CAC5D;IACDwF,QAAQ,EAAEP,MAAM,CAAC,CAAAQ,EAAA,GAAAzE,IAAI,CAACwE,QAAQ,cAAAC,EAAA,cAAAA,EAAA,GAAI1F,iBAAiB,CAAC;IACpD2F,KAAK,EAAET,MAAM,CAAC,CAAAU,EAAA,GAAA3E,IAAI,CAAC0E,KAAK,cAAAC,EAAA,cAAAA,EAAA,GAAI1F,aAAa,CAAC;IAC1C+C,IAAI,EAAEhC,IAAI,CAACgC,IAAI,GAAGgB,kBAAkB,CAAChD,IAAI,CAACgC,IAAI,CAAC,GAAG5C,YAAY;IAC9DmB,KAAK,EAAE;MACLD,KAAK,EAAEC,KAAK,CAACD,KAAK;MAClBG,WAAW,EAAEF,KAAK,CAACC,YAAY;MAC/BG,SAAS,EAAEJ,KAAK,CAACG,UAAU;MAC3BG,UAAU,EAAEN,KAAK,CAACK;;GAErB;AACH;AAUA,SAAekB,QAAQA,CACrB9B,IAAqB,EACrB2B,MAAqC,EACrCC,SAAiD;;IAEjD,MAAM9B,OAAO,GAAG,MAAM6B,MAAM,CAAC0B,UAAU,EAAE;IACzC,IAAItD,OAAwB;IAC5B,IAAI6B,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAE7B,OAAO,EAAE;MACtBA,OAAO,GAAGkE,MAAM,CAACrC,SAAS,CAAC7B,OAAO,CAAC;KACpC,MAAM,IAAI4B,MAAM,CAAC2B,QAAQ,EAAE;MAC1B,CAAC;QAAEvD;MAAO,CAAE,GAAG,MAAM4B,MAAM,CAAC2B,QAAQ,CAACS,UAAU,EAAE;KAClD,MAAM;MACL,MAAM,IAAIN,KAAK,CACb,iEAAiE,CAClE;;IAEH,MAAM;MAAEvC,MAAM;MAAEG;IAAK,CAAE,GAAGJ,sBAAsB,CAACoD,MAAM,CAACtE,OAAO,CAAC,CAAC;IACjE,MAAM6E,cAAc,GAAGC,aAAa,CAAC3D,MAAM,CAAC;IAC5C,MAAM4D,YAAY,GAAGC,WAAW,CAAC/E,IAAI,CAAC;IACtC,MAAMC,IAAI,GAAGpB,MAAM,CAACmG,gBAAgB,CAAC/E,IAAI,CACvC2E,cAAc,EACdvD,KAAK,EACLyD,YAAY,CACb;IACD,IAAI5E,SAAS,GAAGc,MAAM,CAACX,GAAG,CAACP,OAAO,EAAEG,IAAI,CAAC;IACzC,IAAIC,SAAS,KAAKgC,SAAS,EAAE,OAAOhC,SAAS;IAE7CA,SAAS,GAAGrB,MAAM,CAACoG,QAAQ,CACzB,gBAAgB,IAAItD,MAAM,GACtB,MAAOA,MAA0B,CAACuD,cAAc,CAC9CN,cAAc,EACdvD,KAAK,EACLyD,YAAY,CACb,GACD,MAAOnD,MAAwB,CAACwD,aAAa,CAC3CP,cAAc,EACdvD,KAAK,EACLyD,YAAY,CACb,CACN;IACD9D,MAAM,CAACnB,KAAK,CAACC,OAAO,EAAEmE,MAAM,CAAClE,OAAO,CAAC,EAAEC,IAAI,EAAEC,IAAI,EAAEC,SAAS,CAAC;IAC7D,OAAOA,SAAS;EAClB,CAAC;;AAED,SAAS2E,aAAaA,CAAC3D,MAAuB;EAC5C,MAAMkE,CAAC,GAAAC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACFpE,MAAM;IACTnB,OAAO,EAAEmB,MAAM,CAACnB,OAAO,GAAGjB,OAAO,CAACoC,MAAM,CAACnB,OAAO,CAAC,GAAGmC;EAAS,EAC9D;EACD,IAAIhB,MAAM,CAACqE,IAAI,EAAE;IACfH,CAAC,CAAC,MAAM,CAAC,GAAGnD,cAAc,CAACf,MAAM,CAACqE,IAAI,CAAC;;EAEzC,OAAOH,CAAC;AACV;AAEA,SAASL,WAAWA,CAAC/E,IAAqB;EACxC,MAAMwF,OAAO,GAAIC,CAAkC,IAAwB;IACzE,IAAIA,CAAC,KAAKvD,SAAS,IAAIuD,CAAC,KAAK,IAAI,EAAE,OAAOvD,SAAS;IACnD,IAAI,OAAOuD,CAAC,KAAK,QAAQ,EAAE,OAAOA,CAAC;IACnC,IAAIA,CAAC,YAAYxB,MAAM,EAAE,OAAOnF,OAAO,CAAC2G,CAAC,CAACC,QAAQ,EAAE,CAAC;IACrD,OAAO7G,MAAM,CAAC8G,UAAU,CAACF,CAAC,CAAC;EAC7B,CAAC;EACD,OAAAJ,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKtF,IAAI;IACPwE,QAAQ,EAAEgB,OAAO,CAACxF,IAAI,CAACwE,QAAQ,CAAC;IAChCE,KAAK,EAAEc,OAAO,CAACxF,IAAI,CAAC0E,KAAK,CAAC;IAC1B1C,IAAI,EAAEhC,IAAI,CAACgC,IAAI,GAAGnD,MAAM,CAACoG,QAAQ,CAACjF,IAAI,CAACgC,IAAI,CAAC,GAAGE;EAAS;AAE5D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}